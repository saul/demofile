"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.CMsgNotificationOfSuspiciousActivity = exports.CMsgGCHUpdateSession = exports.CMsgGCMsgSetOptions = exports.CMsgGCMsgMasterSetClientMsgRouting_Response = exports.CMsgGCMsgMasterSetWebAPIRouting_Response = exports.CMsgGCMsgMasterSetClientMsgRouting = exports.CMsgGCMsgMasterSetWebAPIRouting = exports.CMsgGCRoutingInfo = exports.CMsgGCGetPartnerAccountLink_Response = exports.CMsgGCGetPartnerAccountLink = exports.CMsgGCHAccountVacStatusChange = exports.CGCSystemMsg_GetPurchaseTrust_Response = exports.CGCSystemMsg_GetPurchaseTrust_Request = exports.CMsgGCMsgWebAPIJobRequestForwardResponse = exports.CMsgGCMsgMasterSetDirectory_Response = exports.CMsgGCMsgMasterSetDirectory = exports.CMsgGCCheckFriendship_Response = exports.CMsgGCCheckFriendship = exports.CMsgGCGetPersonaNames_Response = exports.CMsgGCGetPersonaNames = exports.CGCSystemMsg_GetAccountDetails_Response = exports.CGCSystemMsg_GetAccountDetails = exports.CMsgAMGrantGuestPasses2Response = exports.CMsgAMGrantGuestPasses2 = exports.CMsgGCGetEmailTemplateResponse = exports.CMsgGCGetEmailTemplate = exports.CMsgAMSendEmailResponse = exports.CMsgAMSendEmail = exports.CGCMsgGetSystemStatsResponse = exports.CGCMsgGetSystemStats = exports.CGCMsgSystemStatsSchema = exports.CGCMsgGetIPLocationResponse = exports.CIPLocationInfo = exports.CGCMsgGetIPLocation = exports.CMsgAMAddFreeLicenseResponse = exports.CMsgAMAddFreeLicense = exports.CGCMsgSQLStatsResponse = exports.CGCMsgSQLStats = exports.CGCMsgMemCachedStatsResponse = exports.CGCMsgMemCachedStats = exports.CGCMsgMemCachedDelete = exports.CGCMsgMemCachedSet = exports.CGCMsgMemCachedGetResponse = exports.CGCMsgMemCachedGet = exports.CMsgGCGetCommandListResponse = exports.CMsgGCGetCommandList = exports.CMsgAMGetUserGameStatsResponse = exports.CMsgAMGetUserGameStats = exports.CMsgAMGetLicensesResponse = exports.CMsgPackageLicense = exports.CMsgAMGetLicenses = exports.CMsgNotifyWatchdog = exports.CMsgAMFindAccountsResponse = exports.CMsgAMFindAccounts = exports.CMsgHttpResponse = exports.CMsgWebAPIRequest = exports.CMsgHttpRequest = exports.CMsgWebAPIKey = exports.CMsgProtoBufHeader = exports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = exports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = exports.CMsgGCCStrike15_v2_AcknowledgePenalty = exports.CMsgGC_GlobalGame_Play = exports.CMsgGC_GlobalGame_Unsubscribe = exports.CMsgGC_GlobalGame_Subscribe = exports.CSOPersonaDataPublic = exports.CSOQuestProgress = exports.CSOEconCoupon = exports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = exports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = exports.CMsgGCCStrike15_v2_Server2GCClientValidate = exports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = exports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = exports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = exports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = exports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = exports.CMsgCStrike15Welcome = exports.CMsgGCToGCReloadVersions = exports.CAttribute_String = exports.CMsgGCCStrike15_v2_Fantasy = exports.CMsgGCCStrike15_v2_Predictions = exports.CMsgGCCStrike15_v2_MatchList = exports.CDataGCCStrike15_v2_TournamentInfo = exports.CDataGCCStrike15_v2_TournamentSection = exports.CDataGCCStrike15_v2_TournamentGroup = exports.CDataGCCStrike15_v2_TournamentGroupTeam = exports.CDataGCCStrike15_v2_MatchInfo = exports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = exports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = exports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = exports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = exports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = exports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = exports.CMsgItemAcknowledged = exports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = exports.CEconItemPreviewDataBlock = exports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = exports.CMsgGCCStrike15_v2_Client2GCTextMsg = exports.CMsgGCCStrike15_v2_GC2ClientTextMsg = exports.CClientHeaderOverwatchEvidence = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = exports.CMsgGCCStrike15_v2_PlayersProfile = exports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = exports.CMsgGCCStrike15_v2_WatchInfoUsers = exports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = exports.CMsgGCCstrike15_v2_ClientRequestNewMission = exports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = exports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = exports.WatchableMatchInfo = exports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = exports.CMsgGCCStrike15_v2_ClientReportResponse = exports.CMsgGCCStrike15_v2_ClientReportServer = exports.CMsgGCCStrike15_v2_ClientCommendPlayer = exports.CMsgGCCStrike15_v2_ClientReportPlayer = exports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = exports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = exports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = exports.CMsgGCCStrike15_v2_AccountPrivacySettings = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = exports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = exports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = exports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = exports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = exports.CPreMatchInfoData = exports.CDataGCCStrike15_v2_TournamentMatchDraft = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = exports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = exports.CMsgGCCStrike15_v2_MatchmakingStop = exports.CMsgGCCStrike15_v2_MatchmakingStart = exports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = exports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = exports.CMsgGC_ServerQuestUpdateData = exports.PlayerQuestData = exports.MatchEndItemUpdates = exports.XpProgressData = exports.IpAddressMask = exports.ServerHltvInfo = exports.TournamentMatchSetup = exports.AccountActivity = exports.PlayerMedalsInfo = exports.PlayerCommendationInfo = exports.PlayerRankingInfo = exports.OperationalStatisticsPacket = exports.OperationalStatisticElement = exports.OperationalStatisticDescription = exports.GlobalStatistics = exports.TournamentEvent = exports.TournamentTeam = exports.TournamentPlayer = exports.DetailedSearchStatistic = exports.GameServerPing = exports.CCLCMsg_HltvReplay = exports.CSVCMsg_HltvReplay = exports.CSVCMsg_EncryptedData = exports.CSVCMsg_CmdKeyValues = exports.CSVCMsg_EntityMsg = exports.CSVCMsg_Sounds = exports.CSVCMsg_PacketEntities = exports.CSVCMsg_TempEntities = exports.CSVCMsg_GameEventList = exports.CSVCMsg_GameEvent = exports.CSVCMsg_PaintmapData = exports.CSVCMsg_UserMessage = exports.CSVCMsg_Menu = exports.CSVCMsg_GetCvarValue = exports.CSVCMsg_SplitScreen = exports.CSVCMsg_BSPDecal = exports.CSVCMsg_Prefetch = exports.CSVCMsg_CrosshairAngle = exports.CSVCMsg_FixAngle = exports.CSVCMsg_VoiceData = exports.CSVCMsg_VoiceInit = exports.CSVCMsg_UpdateStringTable = exports.CSVCMsg_CreateStringTable = exports.CSVCMsg_SetView = exports.CSVCMsg_SetPause = exports.CSVCMsg_Print = exports.CSVCMsg_SendTable = exports.CSVCMsg_ClassInfo = exports.CSVCMsg_ServerInfo = exports.CCLCMsg_CmdKeyValues = exports.CCLCMsg_SplitPlayerConnect = exports.CCLCMsg_LoadingProgress = exports.CCLCMsg_FileCRCCheck = exports.CCLCMsg_RespondCvarValue = exports.CCLCMsg_ListenEvents = exports.CCLCMsg_BaselineAck = exports.CCLCMsg_VoiceData = exports.CCLCMsg_Move = exports.CCLCMsg_ClientInfo = exports.CNETMsg_PlayerAvatarData = exports.CNETMsg_SplitScreenUser = exports.CNETMsg_File = exports.CNETMsg_Disconnect = exports.CNETMsg_NOP = exports.CNETMsg_SetConVar = exports.CMsg_CVars = exports.CNETMsg_SignonState = exports.CNETMsg_StringCmd = exports.CNETMsg_Tick = exports.CMsgRGBA = exports.CMsgQAngle = exports.CMsgVector2D = exports.CMsgVector = exports.google = exports.CCSUsrMsg_ServerRankRevealAll = exports.CCSUsrMsg_ClientInfo = exports.CCSUsrMsg_WarmupHasEnded = exports.CCSUsrMsg_DisconnectToLobby = exports.CCSUsrMsg_StopSpectatorMode = exports.CCSUsrMsg_RequestState = exports.CCSUsrMsg_GameTitle = exports.CCSUsrMsg_ResetHud = exports.CCSUsrMsg_RoundBackupFilenames = exports.CCSUsrMsg_GlowPropTurnOff = exports.CCSUsrMsg_ItemDrop = exports.CCSUsrMsg_MatchStatsUpdate = exports.CCSUsrMsg_MarkAchievement = exports.CCSUsrMsg_AmmoDenied = exports.CCSUsrMsg_BarTime = exports.CCSUsrMsg_ShowMenu = exports.CCSUsrMsg_ItemPickup = exports.CCSUsrMsg_XpUpdate = exports.CCSUsrMsg_ServerRankUpdate = exports.CCSUsrMsg_SendLastKillerDamageToClient = exports.CCSUsrMsg_VoteSetup = exports.CCSUsrMsg_VoteFailed = exports.CCSUsrMsg_VotePass = exports.CCSUsrMsg_VoteStart = exports.CCSUsrMsg_CallVoteFailed = exports.CCSUsrMsg_XRankUpd = exports.CCSUsrMsg_XRankGet = exports.CCSUsrMsg_QuestProgress = exports.CCSUsrMsg_DisplayInventory = exports.CCSUsrMsg_PlayerStatsUpdate = exports.CCSUsrMsg_MatchEndConditions = exports.CCSUsrMsg_AchievementEvent = exports.CCSUsrMsg_CurrentTimescale = exports.CCSUsrMsg_DesiredTimescale = exports.CCSUsrMsg_KillCam = exports.CCSUsrMsg_ReportHit = exports.CCSUsrMsg_AdjustMoney = exports.CCSUsrMsg_ReloadEffect = exports.CCSUsrMsg_SendPlayerItemFound = exports.CCSUsrMsg_SendPlayerItemDrops = exports.CCSUsrMsg_ProcessSpottedEntityUpdate = exports.CCSUsrMsg_KeyHintText = exports.CCSUsrMsg_HintText = exports.CCSUsrMsg_RadioText = exports.CCSUsrMsg_Damage = exports.CCSUsrMsg_VoiceMask = exports.CCSUsrMsg_RawAudio = exports.CCSUsrMsg_SendAudio = exports.CCSUsrMsg_CloseCaptionDirect = exports.CCSUsrMsg_CloseCaption = exports.CCSUsrMsg_Rumble = exports.CCSUsrMsg_Fade = exports.CCSUsrMsg_Shake = exports.CCSUsrMsg_HudMsg = exports.CCSUsrMsg_TextMsg = exports.CCSUsrMsg_SayText2 = exports.CCSUsrMsg_SayText = exports.CCSUsrMsg_HudText = exports.CCSUsrMsg_Train = exports.CCSUsrMsg_Geiger = exports.CCSUsrMsg_VGUIMenu = exports.ECstrike15UserMessages = void 0;
/* tslint:disable */
const $protobuf = require("protobufjs/minimal");
// Common aliases
const $Reader = $protobuf.Reader, $util = $protobuf.util;
// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
exports.default = $root;
/**
 * ECstrike15UserMessages enum.
 * @exports ECstrike15UserMessages
 * @enum {string}
 * @property {number} CS_UM_VGUIMenu=1 CS_UM_VGUIMenu value
 * @property {number} CS_UM_Geiger=2 CS_UM_Geiger value
 * @property {number} CS_UM_Train=3 CS_UM_Train value
 * @property {number} CS_UM_HudText=4 CS_UM_HudText value
 * @property {number} CS_UM_SayText=5 CS_UM_SayText value
 * @property {number} CS_UM_SayText2=6 CS_UM_SayText2 value
 * @property {number} CS_UM_TextMsg=7 CS_UM_TextMsg value
 * @property {number} CS_UM_HudMsg=8 CS_UM_HudMsg value
 * @property {number} CS_UM_ResetHud=9 CS_UM_ResetHud value
 * @property {number} CS_UM_GameTitle=10 CS_UM_GameTitle value
 * @property {number} CS_UM_Shake=12 CS_UM_Shake value
 * @property {number} CS_UM_Fade=13 CS_UM_Fade value
 * @property {number} CS_UM_Rumble=14 CS_UM_Rumble value
 * @property {number} CS_UM_CloseCaption=15 CS_UM_CloseCaption value
 * @property {number} CS_UM_CloseCaptionDirect=16 CS_UM_CloseCaptionDirect value
 * @property {number} CS_UM_SendAudio=17 CS_UM_SendAudio value
 * @property {number} CS_UM_RawAudio=18 CS_UM_RawAudio value
 * @property {number} CS_UM_VoiceMask=19 CS_UM_VoiceMask value
 * @property {number} CS_UM_RequestState=20 CS_UM_RequestState value
 * @property {number} CS_UM_Damage=21 CS_UM_Damage value
 * @property {number} CS_UM_RadioText=22 CS_UM_RadioText value
 * @property {number} CS_UM_HintText=23 CS_UM_HintText value
 * @property {number} CS_UM_KeyHintText=24 CS_UM_KeyHintText value
 * @property {number} CS_UM_ProcessSpottedEntityUpdate=25 CS_UM_ProcessSpottedEntityUpdate value
 * @property {number} CS_UM_ReloadEffect=26 CS_UM_ReloadEffect value
 * @property {number} CS_UM_AdjustMoney=27 CS_UM_AdjustMoney value
 * @property {number} CS_UM_UpdateTeamMoney=28 CS_UM_UpdateTeamMoney value
 * @property {number} CS_UM_StopSpectatorMode=29 CS_UM_StopSpectatorMode value
 * @property {number} CS_UM_KillCam=30 CS_UM_KillCam value
 * @property {number} CS_UM_DesiredTimescale=31 CS_UM_DesiredTimescale value
 * @property {number} CS_UM_CurrentTimescale=32 CS_UM_CurrentTimescale value
 * @property {number} CS_UM_AchievementEvent=33 CS_UM_AchievementEvent value
 * @property {number} CS_UM_MatchEndConditions=34 CS_UM_MatchEndConditions value
 * @property {number} CS_UM_DisconnectToLobby=35 CS_UM_DisconnectToLobby value
 * @property {number} CS_UM_PlayerStatsUpdate=36 CS_UM_PlayerStatsUpdate value
 * @property {number} CS_UM_DisplayInventory=37 CS_UM_DisplayInventory value
 * @property {number} CS_UM_WarmupHasEnded=38 CS_UM_WarmupHasEnded value
 * @property {number} CS_UM_ClientInfo=39 CS_UM_ClientInfo value
 * @property {number} CS_UM_XRankGet=40 CS_UM_XRankGet value
 * @property {number} CS_UM_XRankUpd=41 CS_UM_XRankUpd value
 * @property {number} CS_UM_CallVoteFailed=45 CS_UM_CallVoteFailed value
 * @property {number} CS_UM_VoteStart=46 CS_UM_VoteStart value
 * @property {number} CS_UM_VotePass=47 CS_UM_VotePass value
 * @property {number} CS_UM_VoteFailed=48 CS_UM_VoteFailed value
 * @property {number} CS_UM_VoteSetup=49 CS_UM_VoteSetup value
 * @property {number} CS_UM_ServerRankRevealAll=50 CS_UM_ServerRankRevealAll value
 * @property {number} CS_UM_SendLastKillerDamageToClient=51 CS_UM_SendLastKillerDamageToClient value
 * @property {number} CS_UM_ServerRankUpdate=52 CS_UM_ServerRankUpdate value
 * @property {number} CS_UM_ItemPickup=53 CS_UM_ItemPickup value
 * @property {number} CS_UM_ShowMenu=54 CS_UM_ShowMenu value
 * @property {number} CS_UM_BarTime=55 CS_UM_BarTime value
 * @property {number} CS_UM_AmmoDenied=56 CS_UM_AmmoDenied value
 * @property {number} CS_UM_MarkAchievement=57 CS_UM_MarkAchievement value
 * @property {number} CS_UM_MatchStatsUpdate=58 CS_UM_MatchStatsUpdate value
 * @property {number} CS_UM_ItemDrop=59 CS_UM_ItemDrop value
 * @property {number} CS_UM_GlowPropTurnOff=60 CS_UM_GlowPropTurnOff value
 * @property {number} CS_UM_SendPlayerItemDrops=61 CS_UM_SendPlayerItemDrops value
 * @property {number} CS_UM_RoundBackupFilenames=62 CS_UM_RoundBackupFilenames value
 * @property {number} CS_UM_SendPlayerItemFound=63 CS_UM_SendPlayerItemFound value
 * @property {number} CS_UM_ReportHit=64 CS_UM_ReportHit value
 * @property {number} CS_UM_XpUpdate=65 CS_UM_XpUpdate value
 * @property {number} CS_UM_QuestProgress=66 CS_UM_QuestProgress value
 */
exports.ECstrike15UserMessages = ($root.ECstrike15UserMessages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[1] = "CS_UM_VGUIMenu")] = 1;
    values[(valuesById[2] = "CS_UM_Geiger")] = 2;
    values[(valuesById[3] = "CS_UM_Train")] = 3;
    values[(valuesById[4] = "CS_UM_HudText")] = 4;
    values[(valuesById[5] = "CS_UM_SayText")] = 5;
    values[(valuesById[6] = "CS_UM_SayText2")] = 6;
    values[(valuesById[7] = "CS_UM_TextMsg")] = 7;
    values[(valuesById[8] = "CS_UM_HudMsg")] = 8;
    values[(valuesById[9] = "CS_UM_ResetHud")] = 9;
    values[(valuesById[10] = "CS_UM_GameTitle")] = 10;
    values[(valuesById[12] = "CS_UM_Shake")] = 12;
    values[(valuesById[13] = "CS_UM_Fade")] = 13;
    values[(valuesById[14] = "CS_UM_Rumble")] = 14;
    values[(valuesById[15] = "CS_UM_CloseCaption")] = 15;
    values[(valuesById[16] = "CS_UM_CloseCaptionDirect")] = 16;
    values[(valuesById[17] = "CS_UM_SendAudio")] = 17;
    values[(valuesById[18] = "CS_UM_RawAudio")] = 18;
    values[(valuesById[19] = "CS_UM_VoiceMask")] = 19;
    values[(valuesById[20] = "CS_UM_RequestState")] = 20;
    values[(valuesById[21] = "CS_UM_Damage")] = 21;
    values[(valuesById[22] = "CS_UM_RadioText")] = 22;
    values[(valuesById[23] = "CS_UM_HintText")] = 23;
    values[(valuesById[24] = "CS_UM_KeyHintText")] = 24;
    values[(valuesById[25] = "CS_UM_ProcessSpottedEntityUpdate")] = 25;
    values[(valuesById[26] = "CS_UM_ReloadEffect")] = 26;
    values[(valuesById[27] = "CS_UM_AdjustMoney")] = 27;
    values[(valuesById[28] = "CS_UM_UpdateTeamMoney")] = 28;
    values[(valuesById[29] = "CS_UM_StopSpectatorMode")] = 29;
    values[(valuesById[30] = "CS_UM_KillCam")] = 30;
    values[(valuesById[31] = "CS_UM_DesiredTimescale")] = 31;
    values[(valuesById[32] = "CS_UM_CurrentTimescale")] = 32;
    values[(valuesById[33] = "CS_UM_AchievementEvent")] = 33;
    values[(valuesById[34] = "CS_UM_MatchEndConditions")] = 34;
    values[(valuesById[35] = "CS_UM_DisconnectToLobby")] = 35;
    values[(valuesById[36] = "CS_UM_PlayerStatsUpdate")] = 36;
    values[(valuesById[37] = "CS_UM_DisplayInventory")] = 37;
    values[(valuesById[38] = "CS_UM_WarmupHasEnded")] = 38;
    values[(valuesById[39] = "CS_UM_ClientInfo")] = 39;
    values[(valuesById[40] = "CS_UM_XRankGet")] = 40;
    values[(valuesById[41] = "CS_UM_XRankUpd")] = 41;
    values[(valuesById[45] = "CS_UM_CallVoteFailed")] = 45;
    values[(valuesById[46] = "CS_UM_VoteStart")] = 46;
    values[(valuesById[47] = "CS_UM_VotePass")] = 47;
    values[(valuesById[48] = "CS_UM_VoteFailed")] = 48;
    values[(valuesById[49] = "CS_UM_VoteSetup")] = 49;
    values[(valuesById[50] = "CS_UM_ServerRankRevealAll")] = 50;
    values[(valuesById[51] = "CS_UM_SendLastKillerDamageToClient")] = 51;
    values[(valuesById[52] = "CS_UM_ServerRankUpdate")] = 52;
    values[(valuesById[53] = "CS_UM_ItemPickup")] = 53;
    values[(valuesById[54] = "CS_UM_ShowMenu")] = 54;
    values[(valuesById[55] = "CS_UM_BarTime")] = 55;
    values[(valuesById[56] = "CS_UM_AmmoDenied")] = 56;
    values[(valuesById[57] = "CS_UM_MarkAchievement")] = 57;
    values[(valuesById[58] = "CS_UM_MatchStatsUpdate")] = 58;
    values[(valuesById[59] = "CS_UM_ItemDrop")] = 59;
    values[(valuesById[60] = "CS_UM_GlowPropTurnOff")] = 60;
    values[(valuesById[61] = "CS_UM_SendPlayerItemDrops")] = 61;
    values[(valuesById[62] = "CS_UM_RoundBackupFilenames")] = 62;
    values[(valuesById[63] = "CS_UM_SendPlayerItemFound")] = 63;
    values[(valuesById[64] = "CS_UM_ReportHit")] = 64;
    values[(valuesById[65] = "CS_UM_XpUpdate")] = 65;
    values[(valuesById[66] = "CS_UM_QuestProgress")] = 66;
    return values;
})());
exports.CCSUsrMsg_VGUIMenu = ($root.CCSUsrMsg_VGUIMenu = (() => {
    /**
     * Properties of a CCSUsrMsg_VGUIMenu.
     * @exports ICCSUsrMsg_VGUIMenu
     * @interface ICCSUsrMsg_VGUIMenu
     * @property {string|null} [name] CCSUsrMsg_VGUIMenu name
     * @property {boolean|null} [show] CCSUsrMsg_VGUIMenu show
     * @property {Array.<CCSUsrMsg_VGUIMenu.ISubkey>|null} [subkeys] CCSUsrMsg_VGUIMenu subkeys
     */
    /**
     * Constructs a new CCSUsrMsg_VGUIMenu.
     * @exports CCSUsrMsg_VGUIMenu
     * @classdesc Represents a CCSUsrMsg_VGUIMenu.
     * @implements ICCSUsrMsg_VGUIMenu
     * @constructor
     * @param {ICCSUsrMsg_VGUIMenu=} [properties] Properties to set
     */
    function CCSUsrMsg_VGUIMenu(properties) {
        this.subkeys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VGUIMenu name.
     * @member {string} name
     * @memberof CCSUsrMsg_VGUIMenu
     * @instance
     */
    CCSUsrMsg_VGUIMenu.prototype.name = "";
    /**
     * CCSUsrMsg_VGUIMenu show.
     * @member {boolean} show
     * @memberof CCSUsrMsg_VGUIMenu
     * @instance
     */
    CCSUsrMsg_VGUIMenu.prototype.show = false;
    /**
     * CCSUsrMsg_VGUIMenu subkeys.
     * @member {Array.<CCSUsrMsg_VGUIMenu.ISubkey>} subkeys
     * @memberof CCSUsrMsg_VGUIMenu
     * @instance
     */
    CCSUsrMsg_VGUIMenu.prototype.subkeys = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_VGUIMenu message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VGUIMenu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VGUIMenu} CCSUsrMsg_VGUIMenu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VGUIMenu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VGUIMenu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.show = reader.bool();
                    break;
                case 3:
                    if (!(message.subkeys && message.subkeys.length))
                        message.subkeys = [];
                    message.subkeys.push($root.CCSUsrMsg_VGUIMenu.Subkey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_VGUIMenu.Subkey = (function () {
        /**
         * Properties of a Subkey.
         * @memberof CCSUsrMsg_VGUIMenu
         * @interface ISubkey
         * @property {string|null} [name] Subkey name
         * @property {string|null} [str] Subkey str
         */
        /**
         * Constructs a new Subkey.
         * @memberof CCSUsrMsg_VGUIMenu
         * @classdesc Represents a Subkey.
         * @implements ISubkey
         * @constructor
         * @param {CCSUsrMsg_VGUIMenu.ISubkey=} [properties] Properties to set
         */
        function Subkey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Subkey name.
         * @member {string} name
         * @memberof CCSUsrMsg_VGUIMenu.Subkey
         * @instance
         */
        Subkey.prototype.name = "";
        /**
         * Subkey str.
         * @member {string} str
         * @memberof CCSUsrMsg_VGUIMenu.Subkey
         * @instance
         */
        Subkey.prototype.str = "";
        /**
         * Decodes a Subkey message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_VGUIMenu.Subkey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_VGUIMenu.Subkey} Subkey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Subkey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VGUIMenu.Subkey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.str = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Subkey;
    })();
    return CCSUsrMsg_VGUIMenu;
})());
exports.CCSUsrMsg_Geiger = ($root.CCSUsrMsg_Geiger = (() => {
    /**
     * Properties of a CCSUsrMsg_Geiger.
     * @exports ICCSUsrMsg_Geiger
     * @interface ICCSUsrMsg_Geiger
     * @property {number|null} [range] CCSUsrMsg_Geiger range
     */
    /**
     * Constructs a new CCSUsrMsg_Geiger.
     * @exports CCSUsrMsg_Geiger
     * @classdesc Represents a CCSUsrMsg_Geiger.
     * @implements ICCSUsrMsg_Geiger
     * @constructor
     * @param {ICCSUsrMsg_Geiger=} [properties] Properties to set
     */
    function CCSUsrMsg_Geiger(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Geiger range.
     * @member {number} range
     * @memberof CCSUsrMsg_Geiger
     * @instance
     */
    CCSUsrMsg_Geiger.prototype.range = 0;
    /**
     * Decodes a CCSUsrMsg_Geiger message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Geiger
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Geiger} CCSUsrMsg_Geiger
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Geiger.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Geiger();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.range = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Geiger;
})());
exports.CCSUsrMsg_Train = ($root.CCSUsrMsg_Train = (() => {
    /**
     * Properties of a CCSUsrMsg_Train.
     * @exports ICCSUsrMsg_Train
     * @interface ICCSUsrMsg_Train
     * @property {number|null} [train] CCSUsrMsg_Train train
     */
    /**
     * Constructs a new CCSUsrMsg_Train.
     * @exports CCSUsrMsg_Train
     * @classdesc Represents a CCSUsrMsg_Train.
     * @implements ICCSUsrMsg_Train
     * @constructor
     * @param {ICCSUsrMsg_Train=} [properties] Properties to set
     */
    function CCSUsrMsg_Train(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Train train.
     * @member {number} train
     * @memberof CCSUsrMsg_Train
     * @instance
     */
    CCSUsrMsg_Train.prototype.train = 0;
    /**
     * Decodes a CCSUsrMsg_Train message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Train
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Train} CCSUsrMsg_Train
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Train.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Train();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.train = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Train;
})());
exports.CCSUsrMsg_HudText = ($root.CCSUsrMsg_HudText = (() => {
    /**
     * Properties of a CCSUsrMsg_HudText.
     * @exports ICCSUsrMsg_HudText
     * @interface ICCSUsrMsg_HudText
     * @property {string|null} [text] CCSUsrMsg_HudText text
     */
    /**
     * Constructs a new CCSUsrMsg_HudText.
     * @exports CCSUsrMsg_HudText
     * @classdesc Represents a CCSUsrMsg_HudText.
     * @implements ICCSUsrMsg_HudText
     * @constructor
     * @param {ICCSUsrMsg_HudText=} [properties] Properties to set
     */
    function CCSUsrMsg_HudText(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_HudText text.
     * @member {string} text
     * @memberof CCSUsrMsg_HudText
     * @instance
     */
    CCSUsrMsg_HudText.prototype.text = "";
    /**
     * Decodes a CCSUsrMsg_HudText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_HudText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_HudText} CCSUsrMsg_HudText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_HudText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HudText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_HudText;
})());
exports.CCSUsrMsg_SayText = ($root.CCSUsrMsg_SayText = (() => {
    /**
     * Properties of a CCSUsrMsg_SayText.
     * @exports ICCSUsrMsg_SayText
     * @interface ICCSUsrMsg_SayText
     * @property {number|null} [entIdx] CCSUsrMsg_SayText entIdx
     * @property {string|null} [text] CCSUsrMsg_SayText text
     * @property {boolean|null} [chat] CCSUsrMsg_SayText chat
     * @property {boolean|null} [textallchat] CCSUsrMsg_SayText textallchat
     */
    /**
     * Constructs a new CCSUsrMsg_SayText.
     * @exports CCSUsrMsg_SayText
     * @classdesc Represents a CCSUsrMsg_SayText.
     * @implements ICCSUsrMsg_SayText
     * @constructor
     * @param {ICCSUsrMsg_SayText=} [properties] Properties to set
     */
    function CCSUsrMsg_SayText(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SayText entIdx.
     * @member {number} entIdx
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.entIdx = 0;
    /**
     * CCSUsrMsg_SayText text.
     * @member {string} text
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.text = "";
    /**
     * CCSUsrMsg_SayText chat.
     * @member {boolean} chat
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.chat = false;
    /**
     * CCSUsrMsg_SayText textallchat.
     * @member {boolean} textallchat
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.textallchat = false;
    /**
     * Decodes a CCSUsrMsg_SayText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SayText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SayText} CCSUsrMsg_SayText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SayText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SayText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIdx = reader.int32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.chat = reader.bool();
                    break;
                case 4:
                    message.textallchat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SayText;
})());
exports.CCSUsrMsg_SayText2 = ($root.CCSUsrMsg_SayText2 = (() => {
    /**
     * Properties of a CCSUsrMsg_SayText2.
     * @exports ICCSUsrMsg_SayText2
     * @interface ICCSUsrMsg_SayText2
     * @property {number|null} [entIdx] CCSUsrMsg_SayText2 entIdx
     * @property {boolean|null} [chat] CCSUsrMsg_SayText2 chat
     * @property {string|null} [msgName] CCSUsrMsg_SayText2 msgName
     * @property {Array.<string>|null} [params] CCSUsrMsg_SayText2 params
     * @property {boolean|null} [textallchat] CCSUsrMsg_SayText2 textallchat
     */
    /**
     * Constructs a new CCSUsrMsg_SayText2.
     * @exports CCSUsrMsg_SayText2
     * @classdesc Represents a CCSUsrMsg_SayText2.
     * @implements ICCSUsrMsg_SayText2
     * @constructor
     * @param {ICCSUsrMsg_SayText2=} [properties] Properties to set
     */
    function CCSUsrMsg_SayText2(properties) {
        this.params = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SayText2 entIdx.
     * @member {number} entIdx
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.entIdx = 0;
    /**
     * CCSUsrMsg_SayText2 chat.
     * @member {boolean} chat
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.chat = false;
    /**
     * CCSUsrMsg_SayText2 msgName.
     * @member {string} msgName
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.msgName = "";
    /**
     * CCSUsrMsg_SayText2 params.
     * @member {Array.<string>} params
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.params = $util.emptyArray;
    /**
     * CCSUsrMsg_SayText2 textallchat.
     * @member {boolean} textallchat
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.textallchat = false;
    /**
     * Decodes a CCSUsrMsg_SayText2 message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SayText2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SayText2} CCSUsrMsg_SayText2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SayText2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SayText2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIdx = reader.int32();
                    break;
                case 2:
                    message.chat = reader.bool();
                    break;
                case 3:
                    message.msgName = reader.string();
                    break;
                case 4:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                case 5:
                    message.textallchat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SayText2;
})());
exports.CCSUsrMsg_TextMsg = ($root.CCSUsrMsg_TextMsg = (() => {
    /**
     * Properties of a CCSUsrMsg_TextMsg.
     * @exports ICCSUsrMsg_TextMsg
     * @interface ICCSUsrMsg_TextMsg
     * @property {number|null} [msgDst] CCSUsrMsg_TextMsg msgDst
     * @property {Array.<string>|null} [params] CCSUsrMsg_TextMsg params
     */
    /**
     * Constructs a new CCSUsrMsg_TextMsg.
     * @exports CCSUsrMsg_TextMsg
     * @classdesc Represents a CCSUsrMsg_TextMsg.
     * @implements ICCSUsrMsg_TextMsg
     * @constructor
     * @param {ICCSUsrMsg_TextMsg=} [properties] Properties to set
     */
    function CCSUsrMsg_TextMsg(properties) {
        this.params = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_TextMsg msgDst.
     * @member {number} msgDst
     * @memberof CCSUsrMsg_TextMsg
     * @instance
     */
    CCSUsrMsg_TextMsg.prototype.msgDst = 0;
    /**
     * CCSUsrMsg_TextMsg params.
     * @member {Array.<string>} params
     * @memberof CCSUsrMsg_TextMsg
     * @instance
     */
    CCSUsrMsg_TextMsg.prototype.params = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_TextMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_TextMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_TextMsg} CCSUsrMsg_TextMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_TextMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_TextMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgDst = reader.int32();
                    break;
                case 3:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_TextMsg;
})());
exports.CCSUsrMsg_HudMsg = ($root.CCSUsrMsg_HudMsg = (() => {
    /**
     * Properties of a CCSUsrMsg_HudMsg.
     * @exports ICCSUsrMsg_HudMsg
     * @interface ICCSUsrMsg_HudMsg
     * @property {number|null} [channel] CCSUsrMsg_HudMsg channel
     * @property {ICMsgVector2D|null} [pos] CCSUsrMsg_HudMsg pos
     * @property {ICMsgRGBA|null} [clr1] CCSUsrMsg_HudMsg clr1
     * @property {ICMsgRGBA|null} [clr2] CCSUsrMsg_HudMsg clr2
     * @property {number|null} [effect] CCSUsrMsg_HudMsg effect
     * @property {number|null} [fadeInTime] CCSUsrMsg_HudMsg fadeInTime
     * @property {number|null} [fadeOutTime] CCSUsrMsg_HudMsg fadeOutTime
     * @property {number|null} [holdTime] CCSUsrMsg_HudMsg holdTime
     * @property {number|null} [fxTime] CCSUsrMsg_HudMsg fxTime
     * @property {string|null} [text] CCSUsrMsg_HudMsg text
     */
    /**
     * Constructs a new CCSUsrMsg_HudMsg.
     * @exports CCSUsrMsg_HudMsg
     * @classdesc Represents a CCSUsrMsg_HudMsg.
     * @implements ICCSUsrMsg_HudMsg
     * @constructor
     * @param {ICCSUsrMsg_HudMsg=} [properties] Properties to set
     */
    function CCSUsrMsg_HudMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_HudMsg channel.
     * @member {number} channel
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.channel = 0;
    /**
     * CCSUsrMsg_HudMsg pos.
     * @member {ICMsgVector2D|null|undefined} pos
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.pos = null;
    /**
     * CCSUsrMsg_HudMsg clr1.
     * @member {ICMsgRGBA|null|undefined} clr1
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.clr1 = null;
    /**
     * CCSUsrMsg_HudMsg clr2.
     * @member {ICMsgRGBA|null|undefined} clr2
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.clr2 = null;
    /**
     * CCSUsrMsg_HudMsg effect.
     * @member {number} effect
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.effect = 0;
    /**
     * CCSUsrMsg_HudMsg fadeInTime.
     * @member {number} fadeInTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.fadeInTime = 0;
    /**
     * CCSUsrMsg_HudMsg fadeOutTime.
     * @member {number} fadeOutTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.fadeOutTime = 0;
    /**
     * CCSUsrMsg_HudMsg holdTime.
     * @member {number} holdTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.holdTime = 0;
    /**
     * CCSUsrMsg_HudMsg fxTime.
     * @member {number} fxTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.fxTime = 0;
    /**
     * CCSUsrMsg_HudMsg text.
     * @member {string} text
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.text = "";
    /**
     * Decodes a CCSUsrMsg_HudMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_HudMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_HudMsg} CCSUsrMsg_HudMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_HudMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HudMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.channel = reader.int32();
                    break;
                case 2:
                    message.pos = $root.CMsgVector2D.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.clr1 = $root.CMsgRGBA.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clr2 = $root.CMsgRGBA.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.effect = reader.int32();
                    break;
                case 6:
                    message.fadeInTime = reader.float();
                    break;
                case 7:
                    message.fadeOutTime = reader.float();
                    break;
                case 9:
                    message.holdTime = reader.float();
                    break;
                case 10:
                    message.fxTime = reader.float();
                    break;
                case 11:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_HudMsg;
})());
exports.CCSUsrMsg_Shake = ($root.CCSUsrMsg_Shake = (() => {
    /**
     * Properties of a CCSUsrMsg_Shake.
     * @exports ICCSUsrMsg_Shake
     * @interface ICCSUsrMsg_Shake
     * @property {number|null} [command] CCSUsrMsg_Shake command
     * @property {number|null} [localAmplitude] CCSUsrMsg_Shake localAmplitude
     * @property {number|null} [frequency] CCSUsrMsg_Shake frequency
     * @property {number|null} [duration] CCSUsrMsg_Shake duration
     */
    /**
     * Constructs a new CCSUsrMsg_Shake.
     * @exports CCSUsrMsg_Shake
     * @classdesc Represents a CCSUsrMsg_Shake.
     * @implements ICCSUsrMsg_Shake
     * @constructor
     * @param {ICCSUsrMsg_Shake=} [properties] Properties to set
     */
    function CCSUsrMsg_Shake(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Shake command.
     * @member {number} command
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.command = 0;
    /**
     * CCSUsrMsg_Shake localAmplitude.
     * @member {number} localAmplitude
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.localAmplitude = 0;
    /**
     * CCSUsrMsg_Shake frequency.
     * @member {number} frequency
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.frequency = 0;
    /**
     * CCSUsrMsg_Shake duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.duration = 0;
    /**
     * Decodes a CCSUsrMsg_Shake message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Shake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Shake} CCSUsrMsg_Shake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Shake.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Shake();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.int32();
                    break;
                case 2:
                    message.localAmplitude = reader.float();
                    break;
                case 3:
                    message.frequency = reader.float();
                    break;
                case 4:
                    message.duration = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Shake;
})());
exports.CCSUsrMsg_Fade = ($root.CCSUsrMsg_Fade = (() => {
    /**
     * Properties of a CCSUsrMsg_Fade.
     * @exports ICCSUsrMsg_Fade
     * @interface ICCSUsrMsg_Fade
     * @property {number|null} [duration] CCSUsrMsg_Fade duration
     * @property {number|null} [holdTime] CCSUsrMsg_Fade holdTime
     * @property {number|null} [flags] CCSUsrMsg_Fade flags
     * @property {ICMsgRGBA|null} [clr] CCSUsrMsg_Fade clr
     */
    /**
     * Constructs a new CCSUsrMsg_Fade.
     * @exports CCSUsrMsg_Fade
     * @classdesc Represents a CCSUsrMsg_Fade.
     * @implements ICCSUsrMsg_Fade
     * @constructor
     * @param {ICCSUsrMsg_Fade=} [properties] Properties to set
     */
    function CCSUsrMsg_Fade(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Fade duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.duration = 0;
    /**
     * CCSUsrMsg_Fade holdTime.
     * @member {number} holdTime
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.holdTime = 0;
    /**
     * CCSUsrMsg_Fade flags.
     * @member {number} flags
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.flags = 0;
    /**
     * CCSUsrMsg_Fade clr.
     * @member {ICMsgRGBA|null|undefined} clr
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.clr = null;
    /**
     * Decodes a CCSUsrMsg_Fade message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Fade
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Fade} CCSUsrMsg_Fade
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Fade.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Fade();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.duration = reader.int32();
                    break;
                case 2:
                    message.holdTime = reader.int32();
                    break;
                case 3:
                    message.flags = reader.int32();
                    break;
                case 4:
                    message.clr = $root.CMsgRGBA.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Fade;
})());
exports.CCSUsrMsg_Rumble = ($root.CCSUsrMsg_Rumble = (() => {
    /**
     * Properties of a CCSUsrMsg_Rumble.
     * @exports ICCSUsrMsg_Rumble
     * @interface ICCSUsrMsg_Rumble
     * @property {number|null} [index] CCSUsrMsg_Rumble index
     * @property {number|null} [data] CCSUsrMsg_Rumble data
     * @property {number|null} [flags] CCSUsrMsg_Rumble flags
     */
    /**
     * Constructs a new CCSUsrMsg_Rumble.
     * @exports CCSUsrMsg_Rumble
     * @classdesc Represents a CCSUsrMsg_Rumble.
     * @implements ICCSUsrMsg_Rumble
     * @constructor
     * @param {ICCSUsrMsg_Rumble=} [properties] Properties to set
     */
    function CCSUsrMsg_Rumble(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Rumble index.
     * @member {number} index
     * @memberof CCSUsrMsg_Rumble
     * @instance
     */
    CCSUsrMsg_Rumble.prototype.index = 0;
    /**
     * CCSUsrMsg_Rumble data.
     * @member {number} data
     * @memberof CCSUsrMsg_Rumble
     * @instance
     */
    CCSUsrMsg_Rumble.prototype.data = 0;
    /**
     * CCSUsrMsg_Rumble flags.
     * @member {number} flags
     * @memberof CCSUsrMsg_Rumble
     * @instance
     */
    CCSUsrMsg_Rumble.prototype.flags = 0;
    /**
     * Decodes a CCSUsrMsg_Rumble message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Rumble
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Rumble} CCSUsrMsg_Rumble
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Rumble.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Rumble();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.data = reader.int32();
                    break;
                case 3:
                    message.flags = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Rumble;
})());
exports.CCSUsrMsg_CloseCaption = ($root.CCSUsrMsg_CloseCaption = (() => {
    /**
     * Properties of a CCSUsrMsg_CloseCaption.
     * @exports ICCSUsrMsg_CloseCaption
     * @interface ICCSUsrMsg_CloseCaption
     * @property {number|null} [hash] CCSUsrMsg_CloseCaption hash
     * @property {number|null} [duration] CCSUsrMsg_CloseCaption duration
     * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaption fromPlayer
     */
    /**
     * Constructs a new CCSUsrMsg_CloseCaption.
     * @exports CCSUsrMsg_CloseCaption
     * @classdesc Represents a CCSUsrMsg_CloseCaption.
     * @implements ICCSUsrMsg_CloseCaption
     * @constructor
     * @param {ICCSUsrMsg_CloseCaption=} [properties] Properties to set
     */
    function CCSUsrMsg_CloseCaption(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CloseCaption hash.
     * @member {number} hash
     * @memberof CCSUsrMsg_CloseCaption
     * @instance
     */
    CCSUsrMsg_CloseCaption.prototype.hash = 0;
    /**
     * CCSUsrMsg_CloseCaption duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_CloseCaption
     * @instance
     */
    CCSUsrMsg_CloseCaption.prototype.duration = 0;
    /**
     * CCSUsrMsg_CloseCaption fromPlayer.
     * @member {boolean} fromPlayer
     * @memberof CCSUsrMsg_CloseCaption
     * @instance
     */
    CCSUsrMsg_CloseCaption.prototype.fromPlayer = false;
    /**
     * Decodes a CCSUsrMsg_CloseCaption message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CloseCaption
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CloseCaption} CCSUsrMsg_CloseCaption
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CloseCaption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CloseCaption();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hash = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.int32();
                    break;
                case 3:
                    message.fromPlayer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CloseCaption;
})());
exports.CCSUsrMsg_CloseCaptionDirect = ($root.CCSUsrMsg_CloseCaptionDirect = (() => {
    /**
     * Properties of a CCSUsrMsg_CloseCaptionDirect.
     * @exports ICCSUsrMsg_CloseCaptionDirect
     * @interface ICCSUsrMsg_CloseCaptionDirect
     * @property {number|null} [hash] CCSUsrMsg_CloseCaptionDirect hash
     * @property {number|null} [duration] CCSUsrMsg_CloseCaptionDirect duration
     * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaptionDirect fromPlayer
     */
    /**
     * Constructs a new CCSUsrMsg_CloseCaptionDirect.
     * @exports CCSUsrMsg_CloseCaptionDirect
     * @classdesc Represents a CCSUsrMsg_CloseCaptionDirect.
     * @implements ICCSUsrMsg_CloseCaptionDirect
     * @constructor
     * @param {ICCSUsrMsg_CloseCaptionDirect=} [properties] Properties to set
     */
    function CCSUsrMsg_CloseCaptionDirect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CloseCaptionDirect hash.
     * @member {number} hash
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @instance
     */
    CCSUsrMsg_CloseCaptionDirect.prototype.hash = 0;
    /**
     * CCSUsrMsg_CloseCaptionDirect duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @instance
     */
    CCSUsrMsg_CloseCaptionDirect.prototype.duration = 0;
    /**
     * CCSUsrMsg_CloseCaptionDirect fromPlayer.
     * @member {boolean} fromPlayer
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @instance
     */
    CCSUsrMsg_CloseCaptionDirect.prototype.fromPlayer = false;
    /**
     * Decodes a CCSUsrMsg_CloseCaptionDirect message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CloseCaptionDirect} CCSUsrMsg_CloseCaptionDirect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CloseCaptionDirect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CloseCaptionDirect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hash = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.int32();
                    break;
                case 3:
                    message.fromPlayer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CloseCaptionDirect;
})());
exports.CCSUsrMsg_SendAudio = ($root.CCSUsrMsg_SendAudio = (() => {
    /**
     * Properties of a CCSUsrMsg_SendAudio.
     * @exports ICCSUsrMsg_SendAudio
     * @interface ICCSUsrMsg_SendAudio
     * @property {string|null} [radioSound] CCSUsrMsg_SendAudio radioSound
     */
    /**
     * Constructs a new CCSUsrMsg_SendAudio.
     * @exports CCSUsrMsg_SendAudio
     * @classdesc Represents a CCSUsrMsg_SendAudio.
     * @implements ICCSUsrMsg_SendAudio
     * @constructor
     * @param {ICCSUsrMsg_SendAudio=} [properties] Properties to set
     */
    function CCSUsrMsg_SendAudio(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendAudio radioSound.
     * @member {string} radioSound
     * @memberof CCSUsrMsg_SendAudio
     * @instance
     */
    CCSUsrMsg_SendAudio.prototype.radioSound = "";
    /**
     * Decodes a CCSUsrMsg_SendAudio message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendAudio
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendAudio} CCSUsrMsg_SendAudio
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendAudio.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendAudio();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.radioSound = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendAudio;
})());
exports.CCSUsrMsg_RawAudio = ($root.CCSUsrMsg_RawAudio = (() => {
    /**
     * Properties of a CCSUsrMsg_RawAudio.
     * @exports ICCSUsrMsg_RawAudio
     * @interface ICCSUsrMsg_RawAudio
     * @property {number|null} [pitch] CCSUsrMsg_RawAudio pitch
     * @property {number|null} [entidx] CCSUsrMsg_RawAudio entidx
     * @property {number|null} [duration] CCSUsrMsg_RawAudio duration
     * @property {string|null} [voiceFilename] CCSUsrMsg_RawAudio voiceFilename
     */
    /**
     * Constructs a new CCSUsrMsg_RawAudio.
     * @exports CCSUsrMsg_RawAudio
     * @classdesc Represents a CCSUsrMsg_RawAudio.
     * @implements ICCSUsrMsg_RawAudio
     * @constructor
     * @param {ICCSUsrMsg_RawAudio=} [properties] Properties to set
     */
    function CCSUsrMsg_RawAudio(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RawAudio pitch.
     * @member {number} pitch
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.pitch = 0;
    /**
     * CCSUsrMsg_RawAudio entidx.
     * @member {number} entidx
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.entidx = 0;
    /**
     * CCSUsrMsg_RawAudio duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.duration = 0;
    /**
     * CCSUsrMsg_RawAudio voiceFilename.
     * @member {string} voiceFilename
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.voiceFilename = "";
    /**
     * Decodes a CCSUsrMsg_RawAudio message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RawAudio
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RawAudio} CCSUsrMsg_RawAudio
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RawAudio.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RawAudio();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pitch = reader.int32();
                    break;
                case 2:
                    message.entidx = reader.int32();
                    break;
                case 3:
                    message.duration = reader.float();
                    break;
                case 4:
                    message.voiceFilename = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RawAudio;
})());
exports.CCSUsrMsg_VoiceMask = ($root.CCSUsrMsg_VoiceMask = (() => {
    /**
     * Properties of a CCSUsrMsg_VoiceMask.
     * @exports ICCSUsrMsg_VoiceMask
     * @interface ICCSUsrMsg_VoiceMask
     * @property {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>|null} [playerMasks] CCSUsrMsg_VoiceMask playerMasks
     * @property {boolean|null} [playerModEnable] CCSUsrMsg_VoiceMask playerModEnable
     */
    /**
     * Constructs a new CCSUsrMsg_VoiceMask.
     * @exports CCSUsrMsg_VoiceMask
     * @classdesc Represents a CCSUsrMsg_VoiceMask.
     * @implements ICCSUsrMsg_VoiceMask
     * @constructor
     * @param {ICCSUsrMsg_VoiceMask=} [properties] Properties to set
     */
    function CCSUsrMsg_VoiceMask(properties) {
        this.playerMasks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoiceMask playerMasks.
     * @member {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>} playerMasks
     * @memberof CCSUsrMsg_VoiceMask
     * @instance
     */
    CCSUsrMsg_VoiceMask.prototype.playerMasks = $util.emptyArray;
    /**
     * CCSUsrMsg_VoiceMask playerModEnable.
     * @member {boolean} playerModEnable
     * @memberof CCSUsrMsg_VoiceMask
     * @instance
     */
    CCSUsrMsg_VoiceMask.prototype.playerModEnable = false;
    /**
     * Decodes a CCSUsrMsg_VoiceMask message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoiceMask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoiceMask} CCSUsrMsg_VoiceMask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoiceMask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoiceMask();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.playerMasks && message.playerMasks.length))
                        message.playerMasks = [];
                    message.playerMasks.push($root.CCSUsrMsg_VoiceMask.PlayerMask.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.playerModEnable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_VoiceMask.PlayerMask = (function () {
        /**
         * Properties of a PlayerMask.
         * @memberof CCSUsrMsg_VoiceMask
         * @interface IPlayerMask
         * @property {number|null} [gameRulesMask] PlayerMask gameRulesMask
         * @property {number|null} [banMasks] PlayerMask banMasks
         */
        /**
         * Constructs a new PlayerMask.
         * @memberof CCSUsrMsg_VoiceMask
         * @classdesc Represents a PlayerMask.
         * @implements IPlayerMask
         * @constructor
         * @param {CCSUsrMsg_VoiceMask.IPlayerMask=} [properties] Properties to set
         */
        function PlayerMask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerMask gameRulesMask.
         * @member {number} gameRulesMask
         * @memberof CCSUsrMsg_VoiceMask.PlayerMask
         * @instance
         */
        PlayerMask.prototype.gameRulesMask = 0;
        /**
         * PlayerMask banMasks.
         * @member {number} banMasks
         * @memberof CCSUsrMsg_VoiceMask.PlayerMask
         * @instance
         */
        PlayerMask.prototype.banMasks = 0;
        /**
         * Decodes a PlayerMask message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_VoiceMask.PlayerMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_VoiceMask.PlayerMask} PlayerMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerMask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoiceMask.PlayerMask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.gameRulesMask = reader.int32();
                        break;
                    case 2:
                        message.banMasks = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return PlayerMask;
    })();
    return CCSUsrMsg_VoiceMask;
})());
exports.CCSUsrMsg_Damage = ($root.CCSUsrMsg_Damage = (() => {
    /**
     * Properties of a CCSUsrMsg_Damage.
     * @exports ICCSUsrMsg_Damage
     * @interface ICCSUsrMsg_Damage
     * @property {number|null} [amount] CCSUsrMsg_Damage amount
     * @property {ICMsgVector|null} [inflictorWorldPos] CCSUsrMsg_Damage inflictorWorldPos
     * @property {number|null} [victimEntindex] CCSUsrMsg_Damage victimEntindex
     */
    /**
     * Constructs a new CCSUsrMsg_Damage.
     * @exports CCSUsrMsg_Damage
     * @classdesc Represents a CCSUsrMsg_Damage.
     * @implements ICCSUsrMsg_Damage
     * @constructor
     * @param {ICCSUsrMsg_Damage=} [properties] Properties to set
     */
    function CCSUsrMsg_Damage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Damage amount.
     * @member {number} amount
     * @memberof CCSUsrMsg_Damage
     * @instance
     */
    CCSUsrMsg_Damage.prototype.amount = 0;
    /**
     * CCSUsrMsg_Damage inflictorWorldPos.
     * @member {ICMsgVector|null|undefined} inflictorWorldPos
     * @memberof CCSUsrMsg_Damage
     * @instance
     */
    CCSUsrMsg_Damage.prototype.inflictorWorldPos = null;
    /**
     * CCSUsrMsg_Damage victimEntindex.
     * @member {number} victimEntindex
     * @memberof CCSUsrMsg_Damage
     * @instance
     */
    CCSUsrMsg_Damage.prototype.victimEntindex = 0;
    /**
     * Decodes a CCSUsrMsg_Damage message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Damage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Damage} CCSUsrMsg_Damage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Damage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Damage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount = reader.int32();
                    break;
                case 2:
                    message.inflictorWorldPos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.victimEntindex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Damage;
})());
exports.CCSUsrMsg_RadioText = ($root.CCSUsrMsg_RadioText = (() => {
    /**
     * Properties of a CCSUsrMsg_RadioText.
     * @exports ICCSUsrMsg_RadioText
     * @interface ICCSUsrMsg_RadioText
     * @property {number|null} [msgDst] CCSUsrMsg_RadioText msgDst
     * @property {number|null} [client] CCSUsrMsg_RadioText client
     * @property {string|null} [msgName] CCSUsrMsg_RadioText msgName
     * @property {Array.<string>|null} [params] CCSUsrMsg_RadioText params
     */
    /**
     * Constructs a new CCSUsrMsg_RadioText.
     * @exports CCSUsrMsg_RadioText
     * @classdesc Represents a CCSUsrMsg_RadioText.
     * @implements ICCSUsrMsg_RadioText
     * @constructor
     * @param {ICCSUsrMsg_RadioText=} [properties] Properties to set
     */
    function CCSUsrMsg_RadioText(properties) {
        this.params = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RadioText msgDst.
     * @member {number} msgDst
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.msgDst = 0;
    /**
     * CCSUsrMsg_RadioText client.
     * @member {number} client
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.client = 0;
    /**
     * CCSUsrMsg_RadioText msgName.
     * @member {string} msgName
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.msgName = "";
    /**
     * CCSUsrMsg_RadioText params.
     * @member {Array.<string>} params
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.params = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_RadioText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RadioText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RadioText} CCSUsrMsg_RadioText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RadioText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RadioText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgDst = reader.int32();
                    break;
                case 2:
                    message.client = reader.int32();
                    break;
                case 3:
                    message.msgName = reader.string();
                    break;
                case 4:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RadioText;
})());
exports.CCSUsrMsg_HintText = ($root.CCSUsrMsg_HintText = (() => {
    /**
     * Properties of a CCSUsrMsg_HintText.
     * @exports ICCSUsrMsg_HintText
     * @interface ICCSUsrMsg_HintText
     * @property {string|null} [text] CCSUsrMsg_HintText text
     */
    /**
     * Constructs a new CCSUsrMsg_HintText.
     * @exports CCSUsrMsg_HintText
     * @classdesc Represents a CCSUsrMsg_HintText.
     * @implements ICCSUsrMsg_HintText
     * @constructor
     * @param {ICCSUsrMsg_HintText=} [properties] Properties to set
     */
    function CCSUsrMsg_HintText(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_HintText text.
     * @member {string} text
     * @memberof CCSUsrMsg_HintText
     * @instance
     */
    CCSUsrMsg_HintText.prototype.text = "";
    /**
     * Decodes a CCSUsrMsg_HintText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_HintText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_HintText} CCSUsrMsg_HintText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_HintText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HintText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_HintText;
})());
exports.CCSUsrMsg_KeyHintText = ($root.CCSUsrMsg_KeyHintText = (() => {
    /**
     * Properties of a CCSUsrMsg_KeyHintText.
     * @exports ICCSUsrMsg_KeyHintText
     * @interface ICCSUsrMsg_KeyHintText
     * @property {Array.<string>|null} [hints] CCSUsrMsg_KeyHintText hints
     */
    /**
     * Constructs a new CCSUsrMsg_KeyHintText.
     * @exports CCSUsrMsg_KeyHintText
     * @classdesc Represents a CCSUsrMsg_KeyHintText.
     * @implements ICCSUsrMsg_KeyHintText
     * @constructor
     * @param {ICCSUsrMsg_KeyHintText=} [properties] Properties to set
     */
    function CCSUsrMsg_KeyHintText(properties) {
        this.hints = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_KeyHintText hints.
     * @member {Array.<string>} hints
     * @memberof CCSUsrMsg_KeyHintText
     * @instance
     */
    CCSUsrMsg_KeyHintText.prototype.hints = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_KeyHintText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_KeyHintText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_KeyHintText} CCSUsrMsg_KeyHintText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_KeyHintText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_KeyHintText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.hints && message.hints.length))
                        message.hints = [];
                    message.hints.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_KeyHintText;
})());
exports.CCSUsrMsg_ProcessSpottedEntityUpdate = ($root.CCSUsrMsg_ProcessSpottedEntityUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_ProcessSpottedEntityUpdate.
     * @exports ICCSUsrMsg_ProcessSpottedEntityUpdate
     * @interface ICCSUsrMsg_ProcessSpottedEntityUpdate
     * @property {boolean|null} [newUpdate] CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate
     * @property {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>|null} [entityUpdates] CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates
     */
    /**
     * Constructs a new CCSUsrMsg_ProcessSpottedEntityUpdate.
     * @exports CCSUsrMsg_ProcessSpottedEntityUpdate
     * @classdesc Represents a CCSUsrMsg_ProcessSpottedEntityUpdate.
     * @implements ICCSUsrMsg_ProcessSpottedEntityUpdate
     * @constructor
     * @param {ICCSUsrMsg_ProcessSpottedEntityUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_ProcessSpottedEntityUpdate(properties) {
        this.entityUpdates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate.
     * @member {boolean} newUpdate
     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
     * @instance
     */
    CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.newUpdate = false;
    /**
     * CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates.
     * @member {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>} entityUpdates
     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
     * @instance
     */
    CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.entityUpdates =
        $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_ProcessSpottedEntityUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate} CCSUsrMsg_ProcessSpottedEntityUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ProcessSpottedEntityUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.newUpdate = reader.bool();
                    break;
                case 2:
                    if (!(message.entityUpdates && message.entityUpdates.length))
                        message.entityUpdates = [];
                    message.entityUpdates.push($root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate = (function () {
        /**
         * Properties of a SpottedEntityUpdate.
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
         * @interface ISpottedEntityUpdate
         * @property {number|null} [entityIdx] SpottedEntityUpdate entityIdx
         * @property {number|null} [classId] SpottedEntityUpdate classId
         * @property {number|null} [originX] SpottedEntityUpdate originX
         * @property {number|null} [originY] SpottedEntityUpdate originY
         * @property {number|null} [originZ] SpottedEntityUpdate originZ
         * @property {number|null} [angleY] SpottedEntityUpdate angleY
         * @property {boolean|null} [defuser] SpottedEntityUpdate defuser
         * @property {boolean|null} [playerHasDefuser] SpottedEntityUpdate playerHasDefuser
         * @property {boolean|null} [playerHasC4] SpottedEntityUpdate playerHasC4
         */
        /**
         * Constructs a new SpottedEntityUpdate.
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
         * @classdesc Represents a SpottedEntityUpdate.
         * @implements ISpottedEntityUpdate
         * @constructor
         * @param {CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate=} [properties] Properties to set
         */
        function SpottedEntityUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SpottedEntityUpdate entityIdx.
         * @member {number} entityIdx
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.entityIdx = 0;
        /**
         * SpottedEntityUpdate classId.
         * @member {number} classId
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.classId = 0;
        /**
         * SpottedEntityUpdate originX.
         * @member {number} originX
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.originX = 0;
        /**
         * SpottedEntityUpdate originY.
         * @member {number} originY
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.originY = 0;
        /**
         * SpottedEntityUpdate originZ.
         * @member {number} originZ
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.originZ = 0;
        /**
         * SpottedEntityUpdate angleY.
         * @member {number} angleY
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.angleY = 0;
        /**
         * SpottedEntityUpdate defuser.
         * @member {boolean} defuser
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.defuser = false;
        /**
         * SpottedEntityUpdate playerHasDefuser.
         * @member {boolean} playerHasDefuser
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.playerHasDefuser = false;
        /**
         * SpottedEntityUpdate playerHasC4.
         * @member {boolean} playerHasC4
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.playerHasC4 = false;
        /**
         * Decodes a SpottedEntityUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate} SpottedEntityUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpottedEntityUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.entityIdx = reader.int32();
                        break;
                    case 2:
                        message.classId = reader.int32();
                        break;
                    case 3:
                        message.originX = reader.int32();
                        break;
                    case 4:
                        message.originY = reader.int32();
                        break;
                    case 5:
                        message.originZ = reader.int32();
                        break;
                    case 6:
                        message.angleY = reader.int32();
                        break;
                    case 7:
                        message.defuser = reader.bool();
                        break;
                    case 8:
                        message.playerHasDefuser = reader.bool();
                        break;
                    case 9:
                        message.playerHasC4 = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return SpottedEntityUpdate;
    })();
    return CCSUsrMsg_ProcessSpottedEntityUpdate;
})());
exports.CCSUsrMsg_SendPlayerItemDrops = ($root.CCSUsrMsg_SendPlayerItemDrops = (() => {
    /**
     * Properties of a CCSUsrMsg_SendPlayerItemDrops.
     * @exports ICCSUsrMsg_SendPlayerItemDrops
     * @interface ICCSUsrMsg_SendPlayerItemDrops
     * @property {Array.<ICEconItemPreviewDataBlock>|null} [entityUpdates] CCSUsrMsg_SendPlayerItemDrops entityUpdates
     */
    /**
     * Constructs a new CCSUsrMsg_SendPlayerItemDrops.
     * @exports CCSUsrMsg_SendPlayerItemDrops
     * @classdesc Represents a CCSUsrMsg_SendPlayerItemDrops.
     * @implements ICCSUsrMsg_SendPlayerItemDrops
     * @constructor
     * @param {ICCSUsrMsg_SendPlayerItemDrops=} [properties] Properties to set
     */
    function CCSUsrMsg_SendPlayerItemDrops(properties) {
        this.entityUpdates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendPlayerItemDrops entityUpdates.
     * @member {Array.<ICEconItemPreviewDataBlock>} entityUpdates
     * @memberof CCSUsrMsg_SendPlayerItemDrops
     * @instance
     */
    CCSUsrMsg_SendPlayerItemDrops.prototype.entityUpdates = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_SendPlayerItemDrops message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendPlayerItemDrops
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendPlayerItemDrops} CCSUsrMsg_SendPlayerItemDrops
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendPlayerItemDrops.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendPlayerItemDrops();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.entityUpdates && message.entityUpdates.length))
                        message.entityUpdates = [];
                    message.entityUpdates.push($root.CEconItemPreviewDataBlock.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendPlayerItemDrops;
})());
exports.CCSUsrMsg_SendPlayerItemFound = ($root.CCSUsrMsg_SendPlayerItemFound = (() => {
    /**
     * Properties of a CCSUsrMsg_SendPlayerItemFound.
     * @exports ICCSUsrMsg_SendPlayerItemFound
     * @interface ICCSUsrMsg_SendPlayerItemFound
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CCSUsrMsg_SendPlayerItemFound iteminfo
     * @property {number|null} [entindex] CCSUsrMsg_SendPlayerItemFound entindex
     */
    /**
     * Constructs a new CCSUsrMsg_SendPlayerItemFound.
     * @exports CCSUsrMsg_SendPlayerItemFound
     * @classdesc Represents a CCSUsrMsg_SendPlayerItemFound.
     * @implements ICCSUsrMsg_SendPlayerItemFound
     * @constructor
     * @param {ICCSUsrMsg_SendPlayerItemFound=} [properties] Properties to set
     */
    function CCSUsrMsg_SendPlayerItemFound(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendPlayerItemFound iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CCSUsrMsg_SendPlayerItemFound
     * @instance
     */
    CCSUsrMsg_SendPlayerItemFound.prototype.iteminfo = null;
    /**
     * CCSUsrMsg_SendPlayerItemFound entindex.
     * @member {number} entindex
     * @memberof CCSUsrMsg_SendPlayerItemFound
     * @instance
     */
    CCSUsrMsg_SendPlayerItemFound.prototype.entindex = 0;
    /**
     * Decodes a CCSUsrMsg_SendPlayerItemFound message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendPlayerItemFound
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendPlayerItemFound} CCSUsrMsg_SendPlayerItemFound
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendPlayerItemFound.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendPlayerItemFound();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.entindex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendPlayerItemFound;
})());
exports.CCSUsrMsg_ReloadEffect = ($root.CCSUsrMsg_ReloadEffect = (() => {
    /**
     * Properties of a CCSUsrMsg_ReloadEffect.
     * @exports ICCSUsrMsg_ReloadEffect
     * @interface ICCSUsrMsg_ReloadEffect
     * @property {number|null} [entidx] CCSUsrMsg_ReloadEffect entidx
     * @property {number|null} [actanim] CCSUsrMsg_ReloadEffect actanim
     * @property {number|null} [originX] CCSUsrMsg_ReloadEffect originX
     * @property {number|null} [originY] CCSUsrMsg_ReloadEffect originY
     * @property {number|null} [originZ] CCSUsrMsg_ReloadEffect originZ
     */
    /**
     * Constructs a new CCSUsrMsg_ReloadEffect.
     * @exports CCSUsrMsg_ReloadEffect
     * @classdesc Represents a CCSUsrMsg_ReloadEffect.
     * @implements ICCSUsrMsg_ReloadEffect
     * @constructor
     * @param {ICCSUsrMsg_ReloadEffect=} [properties] Properties to set
     */
    function CCSUsrMsg_ReloadEffect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ReloadEffect entidx.
     * @member {number} entidx
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.entidx = 0;
    /**
     * CCSUsrMsg_ReloadEffect actanim.
     * @member {number} actanim
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.actanim = 0;
    /**
     * CCSUsrMsg_ReloadEffect originX.
     * @member {number} originX
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.originX = 0;
    /**
     * CCSUsrMsg_ReloadEffect originY.
     * @member {number} originY
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.originY = 0;
    /**
     * CCSUsrMsg_ReloadEffect originZ.
     * @member {number} originZ
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.originZ = 0;
    /**
     * Decodes a CCSUsrMsg_ReloadEffect message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ReloadEffect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ReloadEffect} CCSUsrMsg_ReloadEffect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ReloadEffect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ReloadEffect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entidx = reader.int32();
                    break;
                case 2:
                    message.actanim = reader.int32();
                    break;
                case 3:
                    message.originX = reader.float();
                    break;
                case 4:
                    message.originY = reader.float();
                    break;
                case 5:
                    message.originZ = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ReloadEffect;
})());
exports.CCSUsrMsg_AdjustMoney = ($root.CCSUsrMsg_AdjustMoney = (() => {
    /**
     * Properties of a CCSUsrMsg_AdjustMoney.
     * @exports ICCSUsrMsg_AdjustMoney
     * @interface ICCSUsrMsg_AdjustMoney
     * @property {number|null} [amount] CCSUsrMsg_AdjustMoney amount
     */
    /**
     * Constructs a new CCSUsrMsg_AdjustMoney.
     * @exports CCSUsrMsg_AdjustMoney
     * @classdesc Represents a CCSUsrMsg_AdjustMoney.
     * @implements ICCSUsrMsg_AdjustMoney
     * @constructor
     * @param {ICCSUsrMsg_AdjustMoney=} [properties] Properties to set
     */
    function CCSUsrMsg_AdjustMoney(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_AdjustMoney amount.
     * @member {number} amount
     * @memberof CCSUsrMsg_AdjustMoney
     * @instance
     */
    CCSUsrMsg_AdjustMoney.prototype.amount = 0;
    /**
     * Decodes a CCSUsrMsg_AdjustMoney message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_AdjustMoney
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_AdjustMoney} CCSUsrMsg_AdjustMoney
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_AdjustMoney.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AdjustMoney();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_AdjustMoney;
})());
exports.CCSUsrMsg_ReportHit = ($root.CCSUsrMsg_ReportHit = (() => {
    /**
     * Properties of a CCSUsrMsg_ReportHit.
     * @exports ICCSUsrMsg_ReportHit
     * @interface ICCSUsrMsg_ReportHit
     * @property {number|null} [posX] CCSUsrMsg_ReportHit posX
     * @property {number|null} [posY] CCSUsrMsg_ReportHit posY
     * @property {number|null} [timestamp] CCSUsrMsg_ReportHit timestamp
     * @property {number|null} [posZ] CCSUsrMsg_ReportHit posZ
     */
    /**
     * Constructs a new CCSUsrMsg_ReportHit.
     * @exports CCSUsrMsg_ReportHit
     * @classdesc Represents a CCSUsrMsg_ReportHit.
     * @implements ICCSUsrMsg_ReportHit
     * @constructor
     * @param {ICCSUsrMsg_ReportHit=} [properties] Properties to set
     */
    function CCSUsrMsg_ReportHit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ReportHit posX.
     * @member {number} posX
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.posX = 0;
    /**
     * CCSUsrMsg_ReportHit posY.
     * @member {number} posY
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.posY = 0;
    /**
     * CCSUsrMsg_ReportHit timestamp.
     * @member {number} timestamp
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.timestamp = 0;
    /**
     * CCSUsrMsg_ReportHit posZ.
     * @member {number} posZ
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.posZ = 0;
    /**
     * Decodes a CCSUsrMsg_ReportHit message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ReportHit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ReportHit} CCSUsrMsg_ReportHit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ReportHit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ReportHit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.posX = reader.float();
                    break;
                case 2:
                    message.posY = reader.float();
                    break;
                case 4:
                    message.timestamp = reader.float();
                    break;
                case 3:
                    message.posZ = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ReportHit;
})());
exports.CCSUsrMsg_KillCam = ($root.CCSUsrMsg_KillCam = (() => {
    /**
     * Properties of a CCSUsrMsg_KillCam.
     * @exports ICCSUsrMsg_KillCam
     * @interface ICCSUsrMsg_KillCam
     * @property {number|null} [obsMode] CCSUsrMsg_KillCam obsMode
     * @property {number|null} [firstTarget] CCSUsrMsg_KillCam firstTarget
     * @property {number|null} [secondTarget] CCSUsrMsg_KillCam secondTarget
     */
    /**
     * Constructs a new CCSUsrMsg_KillCam.
     * @exports CCSUsrMsg_KillCam
     * @classdesc Represents a CCSUsrMsg_KillCam.
     * @implements ICCSUsrMsg_KillCam
     * @constructor
     * @param {ICCSUsrMsg_KillCam=} [properties] Properties to set
     */
    function CCSUsrMsg_KillCam(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_KillCam obsMode.
     * @member {number} obsMode
     * @memberof CCSUsrMsg_KillCam
     * @instance
     */
    CCSUsrMsg_KillCam.prototype.obsMode = 0;
    /**
     * CCSUsrMsg_KillCam firstTarget.
     * @member {number} firstTarget
     * @memberof CCSUsrMsg_KillCam
     * @instance
     */
    CCSUsrMsg_KillCam.prototype.firstTarget = 0;
    /**
     * CCSUsrMsg_KillCam secondTarget.
     * @member {number} secondTarget
     * @memberof CCSUsrMsg_KillCam
     * @instance
     */
    CCSUsrMsg_KillCam.prototype.secondTarget = 0;
    /**
     * Decodes a CCSUsrMsg_KillCam message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_KillCam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_KillCam} CCSUsrMsg_KillCam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_KillCam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_KillCam();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.obsMode = reader.int32();
                    break;
                case 2:
                    message.firstTarget = reader.int32();
                    break;
                case 3:
                    message.secondTarget = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_KillCam;
})());
exports.CCSUsrMsg_DesiredTimescale = ($root.CCSUsrMsg_DesiredTimescale = (() => {
    /**
     * Properties of a CCSUsrMsg_DesiredTimescale.
     * @exports ICCSUsrMsg_DesiredTimescale
     * @interface ICCSUsrMsg_DesiredTimescale
     * @property {number|null} [desiredTimescale] CCSUsrMsg_DesiredTimescale desiredTimescale
     * @property {number|null} [durationRealtimeSec] CCSUsrMsg_DesiredTimescale durationRealtimeSec
     * @property {number|null} [interpolatorType] CCSUsrMsg_DesiredTimescale interpolatorType
     * @property {number|null} [startBlendTime] CCSUsrMsg_DesiredTimescale startBlendTime
     */
    /**
     * Constructs a new CCSUsrMsg_DesiredTimescale.
     * @exports CCSUsrMsg_DesiredTimescale
     * @classdesc Represents a CCSUsrMsg_DesiredTimescale.
     * @implements ICCSUsrMsg_DesiredTimescale
     * @constructor
     * @param {ICCSUsrMsg_DesiredTimescale=} [properties] Properties to set
     */
    function CCSUsrMsg_DesiredTimescale(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_DesiredTimescale desiredTimescale.
     * @member {number} desiredTimescale
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.desiredTimescale = 0;
    /**
     * CCSUsrMsg_DesiredTimescale durationRealtimeSec.
     * @member {number} durationRealtimeSec
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.durationRealtimeSec = 0;
    /**
     * CCSUsrMsg_DesiredTimescale interpolatorType.
     * @member {number} interpolatorType
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.interpolatorType = 0;
    /**
     * CCSUsrMsg_DesiredTimescale startBlendTime.
     * @member {number} startBlendTime
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.startBlendTime = 0;
    /**
     * Decodes a CCSUsrMsg_DesiredTimescale message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_DesiredTimescale
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_DesiredTimescale} CCSUsrMsg_DesiredTimescale
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_DesiredTimescale.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DesiredTimescale();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.desiredTimescale = reader.float();
                    break;
                case 2:
                    message.durationRealtimeSec = reader.float();
                    break;
                case 3:
                    message.interpolatorType = reader.int32();
                    break;
                case 4:
                    message.startBlendTime = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_DesiredTimescale;
})());
exports.CCSUsrMsg_CurrentTimescale = ($root.CCSUsrMsg_CurrentTimescale = (() => {
    /**
     * Properties of a CCSUsrMsg_CurrentTimescale.
     * @exports ICCSUsrMsg_CurrentTimescale
     * @interface ICCSUsrMsg_CurrentTimescale
     * @property {number|null} [curTimescale] CCSUsrMsg_CurrentTimescale curTimescale
     */
    /**
     * Constructs a new CCSUsrMsg_CurrentTimescale.
     * @exports CCSUsrMsg_CurrentTimescale
     * @classdesc Represents a CCSUsrMsg_CurrentTimescale.
     * @implements ICCSUsrMsg_CurrentTimescale
     * @constructor
     * @param {ICCSUsrMsg_CurrentTimescale=} [properties] Properties to set
     */
    function CCSUsrMsg_CurrentTimescale(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CurrentTimescale curTimescale.
     * @member {number} curTimescale
     * @memberof CCSUsrMsg_CurrentTimescale
     * @instance
     */
    CCSUsrMsg_CurrentTimescale.prototype.curTimescale = 0;
    /**
     * Decodes a CCSUsrMsg_CurrentTimescale message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CurrentTimescale
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CurrentTimescale} CCSUsrMsg_CurrentTimescale
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CurrentTimescale.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CurrentTimescale();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.curTimescale = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CurrentTimescale;
})());
exports.CCSUsrMsg_AchievementEvent = ($root.CCSUsrMsg_AchievementEvent = (() => {
    /**
     * Properties of a CCSUsrMsg_AchievementEvent.
     * @exports ICCSUsrMsg_AchievementEvent
     * @interface ICCSUsrMsg_AchievementEvent
     * @property {number|null} [achievement] CCSUsrMsg_AchievementEvent achievement
     * @property {number|null} [count] CCSUsrMsg_AchievementEvent count
     * @property {number|null} [userId] CCSUsrMsg_AchievementEvent userId
     */
    /**
     * Constructs a new CCSUsrMsg_AchievementEvent.
     * @exports CCSUsrMsg_AchievementEvent
     * @classdesc Represents a CCSUsrMsg_AchievementEvent.
     * @implements ICCSUsrMsg_AchievementEvent
     * @constructor
     * @param {ICCSUsrMsg_AchievementEvent=} [properties] Properties to set
     */
    function CCSUsrMsg_AchievementEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_AchievementEvent achievement.
     * @member {number} achievement
     * @memberof CCSUsrMsg_AchievementEvent
     * @instance
     */
    CCSUsrMsg_AchievementEvent.prototype.achievement = 0;
    /**
     * CCSUsrMsg_AchievementEvent count.
     * @member {number} count
     * @memberof CCSUsrMsg_AchievementEvent
     * @instance
     */
    CCSUsrMsg_AchievementEvent.prototype.count = 0;
    /**
     * CCSUsrMsg_AchievementEvent userId.
     * @member {number} userId
     * @memberof CCSUsrMsg_AchievementEvent
     * @instance
     */
    CCSUsrMsg_AchievementEvent.prototype.userId = 0;
    /**
     * Decodes a CCSUsrMsg_AchievementEvent message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_AchievementEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_AchievementEvent} CCSUsrMsg_AchievementEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_AchievementEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AchievementEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.achievement = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                case 3:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_AchievementEvent;
})());
exports.CCSUsrMsg_MatchEndConditions = ($root.CCSUsrMsg_MatchEndConditions = (() => {
    /**
     * Properties of a CCSUsrMsg_MatchEndConditions.
     * @exports ICCSUsrMsg_MatchEndConditions
     * @interface ICCSUsrMsg_MatchEndConditions
     * @property {number|null} [fraglimit] CCSUsrMsg_MatchEndConditions fraglimit
     * @property {number|null} [mpMaxrounds] CCSUsrMsg_MatchEndConditions mpMaxrounds
     * @property {number|null} [mpWinlimit] CCSUsrMsg_MatchEndConditions mpWinlimit
     * @property {number|null} [mpTimelimit] CCSUsrMsg_MatchEndConditions mpTimelimit
     */
    /**
     * Constructs a new CCSUsrMsg_MatchEndConditions.
     * @exports CCSUsrMsg_MatchEndConditions
     * @classdesc Represents a CCSUsrMsg_MatchEndConditions.
     * @implements ICCSUsrMsg_MatchEndConditions
     * @constructor
     * @param {ICCSUsrMsg_MatchEndConditions=} [properties] Properties to set
     */
    function CCSUsrMsg_MatchEndConditions(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_MatchEndConditions fraglimit.
     * @member {number} fraglimit
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.fraglimit = 0;
    /**
     * CCSUsrMsg_MatchEndConditions mpMaxrounds.
     * @member {number} mpMaxrounds
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.mpMaxrounds = 0;
    /**
     * CCSUsrMsg_MatchEndConditions mpWinlimit.
     * @member {number} mpWinlimit
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.mpWinlimit = 0;
    /**
     * CCSUsrMsg_MatchEndConditions mpTimelimit.
     * @member {number} mpTimelimit
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.mpTimelimit = 0;
    /**
     * Decodes a CCSUsrMsg_MatchEndConditions message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_MatchEndConditions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_MatchEndConditions} CCSUsrMsg_MatchEndConditions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_MatchEndConditions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MatchEndConditions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fraglimit = reader.int32();
                    break;
                case 2:
                    message.mpMaxrounds = reader.int32();
                    break;
                case 3:
                    message.mpWinlimit = reader.int32();
                    break;
                case 4:
                    message.mpTimelimit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_MatchEndConditions;
})());
exports.CCSUsrMsg_PlayerStatsUpdate = ($root.CCSUsrMsg_PlayerStatsUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_PlayerStatsUpdate.
     * @exports ICCSUsrMsg_PlayerStatsUpdate
     * @interface ICCSUsrMsg_PlayerStatsUpdate
     * @property {number|null} [version] CCSUsrMsg_PlayerStatsUpdate version
     * @property {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>|null} [stats] CCSUsrMsg_PlayerStatsUpdate stats
     * @property {number|null} [userId] CCSUsrMsg_PlayerStatsUpdate userId
     * @property {number|null} [crc] CCSUsrMsg_PlayerStatsUpdate crc
     */
    /**
     * Constructs a new CCSUsrMsg_PlayerStatsUpdate.
     * @exports CCSUsrMsg_PlayerStatsUpdate
     * @classdesc Represents a CCSUsrMsg_PlayerStatsUpdate.
     * @implements ICCSUsrMsg_PlayerStatsUpdate
     * @constructor
     * @param {ICCSUsrMsg_PlayerStatsUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_PlayerStatsUpdate(properties) {
        this.stats = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_PlayerStatsUpdate version.
     * @member {number} version
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.version = 0;
    /**
     * CCSUsrMsg_PlayerStatsUpdate stats.
     * @member {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>} stats
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.stats = $util.emptyArray;
    /**
     * CCSUsrMsg_PlayerStatsUpdate userId.
     * @member {number} userId
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.userId = 0;
    /**
     * CCSUsrMsg_PlayerStatsUpdate crc.
     * @member {number} crc
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.crc = 0;
    /**
     * Decodes a CCSUsrMsg_PlayerStatsUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_PlayerStatsUpdate} CCSUsrMsg_PlayerStatsUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_PlayerStatsUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_PlayerStatsUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 4:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CCSUsrMsg_PlayerStatsUpdate.Stat.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.userId = reader.int32();
                    break;
                case 6:
                    message.crc = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_PlayerStatsUpdate.Stat = (function () {
        /**
         * Properties of a Stat.
         * @memberof CCSUsrMsg_PlayerStatsUpdate
         * @interface IStat
         * @property {number|null} [idx] Stat idx
         * @property {number|null} [delta] Stat delta
         */
        /**
         * Constructs a new Stat.
         * @memberof CCSUsrMsg_PlayerStatsUpdate
         * @classdesc Represents a Stat.
         * @implements IStat
         * @constructor
         * @param {CCSUsrMsg_PlayerStatsUpdate.IStat=} [properties] Properties to set
         */
        function Stat(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Stat idx.
         * @member {number} idx
         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat
         * @instance
         */
        Stat.prototype.idx = 0;
        /**
         * Stat delta.
         * @member {number} delta
         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat
         * @instance
         */
        Stat.prototype.delta = 0;
        /**
         * Decodes a Stat message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_PlayerStatsUpdate.Stat} Stat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Stat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_PlayerStatsUpdate.Stat();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.idx = reader.int32();
                        break;
                    case 2:
                        message.delta = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Stat;
    })();
    return CCSUsrMsg_PlayerStatsUpdate;
})());
exports.CCSUsrMsg_DisplayInventory = ($root.CCSUsrMsg_DisplayInventory = (() => {
    /**
     * Properties of a CCSUsrMsg_DisplayInventory.
     * @exports ICCSUsrMsg_DisplayInventory
     * @interface ICCSUsrMsg_DisplayInventory
     * @property {boolean|null} [display] CCSUsrMsg_DisplayInventory display
     * @property {number|null} [userId] CCSUsrMsg_DisplayInventory userId
     */
    /**
     * Constructs a new CCSUsrMsg_DisplayInventory.
     * @exports CCSUsrMsg_DisplayInventory
     * @classdesc Represents a CCSUsrMsg_DisplayInventory.
     * @implements ICCSUsrMsg_DisplayInventory
     * @constructor
     * @param {ICCSUsrMsg_DisplayInventory=} [properties] Properties to set
     */
    function CCSUsrMsg_DisplayInventory(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_DisplayInventory display.
     * @member {boolean} display
     * @memberof CCSUsrMsg_DisplayInventory
     * @instance
     */
    CCSUsrMsg_DisplayInventory.prototype.display = false;
    /**
     * CCSUsrMsg_DisplayInventory userId.
     * @member {number} userId
     * @memberof CCSUsrMsg_DisplayInventory
     * @instance
     */
    CCSUsrMsg_DisplayInventory.prototype.userId = 0;
    /**
     * Decodes a CCSUsrMsg_DisplayInventory message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_DisplayInventory
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_DisplayInventory} CCSUsrMsg_DisplayInventory
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_DisplayInventory.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DisplayInventory();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.display = reader.bool();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_DisplayInventory;
})());
exports.CCSUsrMsg_QuestProgress = ($root.CCSUsrMsg_QuestProgress = (() => {
    /**
     * Properties of a CCSUsrMsg_QuestProgress.
     * @exports ICCSUsrMsg_QuestProgress
     * @interface ICCSUsrMsg_QuestProgress
     * @property {number|null} [questId] CCSUsrMsg_QuestProgress questId
     * @property {number|null} [normalPoints] CCSUsrMsg_QuestProgress normalPoints
     * @property {number|null} [bonusPoints] CCSUsrMsg_QuestProgress bonusPoints
     */
    /**
     * Constructs a new CCSUsrMsg_QuestProgress.
     * @exports CCSUsrMsg_QuestProgress
     * @classdesc Represents a CCSUsrMsg_QuestProgress.
     * @implements ICCSUsrMsg_QuestProgress
     * @constructor
     * @param {ICCSUsrMsg_QuestProgress=} [properties] Properties to set
     */
    function CCSUsrMsg_QuestProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_QuestProgress questId.
     * @member {number} questId
     * @memberof CCSUsrMsg_QuestProgress
     * @instance
     */
    CCSUsrMsg_QuestProgress.prototype.questId = 0;
    /**
     * CCSUsrMsg_QuestProgress normalPoints.
     * @member {number} normalPoints
     * @memberof CCSUsrMsg_QuestProgress
     * @instance
     */
    CCSUsrMsg_QuestProgress.prototype.normalPoints = 0;
    /**
     * CCSUsrMsg_QuestProgress bonusPoints.
     * @member {number} bonusPoints
     * @memberof CCSUsrMsg_QuestProgress
     * @instance
     */
    CCSUsrMsg_QuestProgress.prototype.bonusPoints = 0;
    /**
     * Decodes a CCSUsrMsg_QuestProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_QuestProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_QuestProgress} CCSUsrMsg_QuestProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_QuestProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_QuestProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.questId = reader.uint32();
                    break;
                case 2:
                    message.normalPoints = reader.uint32();
                    break;
                case 3:
                    message.bonusPoints = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_QuestProgress;
})());
exports.CCSUsrMsg_XRankGet = ($root.CCSUsrMsg_XRankGet = (() => {
    /**
     * Properties of a CCSUsrMsg_XRankGet.
     * @exports ICCSUsrMsg_XRankGet
     * @interface ICCSUsrMsg_XRankGet
     * @property {number|null} [modeIdx] CCSUsrMsg_XRankGet modeIdx
     * @property {number|null} [controller] CCSUsrMsg_XRankGet controller
     */
    /**
     * Constructs a new CCSUsrMsg_XRankGet.
     * @exports CCSUsrMsg_XRankGet
     * @classdesc Represents a CCSUsrMsg_XRankGet.
     * @implements ICCSUsrMsg_XRankGet
     * @constructor
     * @param {ICCSUsrMsg_XRankGet=} [properties] Properties to set
     */
    function CCSUsrMsg_XRankGet(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_XRankGet modeIdx.
     * @member {number} modeIdx
     * @memberof CCSUsrMsg_XRankGet
     * @instance
     */
    CCSUsrMsg_XRankGet.prototype.modeIdx = 0;
    /**
     * CCSUsrMsg_XRankGet controller.
     * @member {number} controller
     * @memberof CCSUsrMsg_XRankGet
     * @instance
     */
    CCSUsrMsg_XRankGet.prototype.controller = 0;
    /**
     * Decodes a CCSUsrMsg_XRankGet message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_XRankGet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_XRankGet} CCSUsrMsg_XRankGet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_XRankGet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XRankGet();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.modeIdx = reader.int32();
                    break;
                case 2:
                    message.controller = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_XRankGet;
})());
exports.CCSUsrMsg_XRankUpd = ($root.CCSUsrMsg_XRankUpd = (() => {
    /**
     * Properties of a CCSUsrMsg_XRankUpd.
     * @exports ICCSUsrMsg_XRankUpd
     * @interface ICCSUsrMsg_XRankUpd
     * @property {number|null} [modeIdx] CCSUsrMsg_XRankUpd modeIdx
     * @property {number|null} [controller] CCSUsrMsg_XRankUpd controller
     * @property {number|null} [ranking] CCSUsrMsg_XRankUpd ranking
     */
    /**
     * Constructs a new CCSUsrMsg_XRankUpd.
     * @exports CCSUsrMsg_XRankUpd
     * @classdesc Represents a CCSUsrMsg_XRankUpd.
     * @implements ICCSUsrMsg_XRankUpd
     * @constructor
     * @param {ICCSUsrMsg_XRankUpd=} [properties] Properties to set
     */
    function CCSUsrMsg_XRankUpd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_XRankUpd modeIdx.
     * @member {number} modeIdx
     * @memberof CCSUsrMsg_XRankUpd
     * @instance
     */
    CCSUsrMsg_XRankUpd.prototype.modeIdx = 0;
    /**
     * CCSUsrMsg_XRankUpd controller.
     * @member {number} controller
     * @memberof CCSUsrMsg_XRankUpd
     * @instance
     */
    CCSUsrMsg_XRankUpd.prototype.controller = 0;
    /**
     * CCSUsrMsg_XRankUpd ranking.
     * @member {number} ranking
     * @memberof CCSUsrMsg_XRankUpd
     * @instance
     */
    CCSUsrMsg_XRankUpd.prototype.ranking = 0;
    /**
     * Decodes a CCSUsrMsg_XRankUpd message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_XRankUpd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_XRankUpd} CCSUsrMsg_XRankUpd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_XRankUpd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XRankUpd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.modeIdx = reader.int32();
                    break;
                case 2:
                    message.controller = reader.int32();
                    break;
                case 3:
                    message.ranking = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_XRankUpd;
})());
exports.CCSUsrMsg_CallVoteFailed = ($root.CCSUsrMsg_CallVoteFailed = (() => {
    /**
     * Properties of a CCSUsrMsg_CallVoteFailed.
     * @exports ICCSUsrMsg_CallVoteFailed
     * @interface ICCSUsrMsg_CallVoteFailed
     * @property {number|null} [reason] CCSUsrMsg_CallVoteFailed reason
     * @property {number|null} [time] CCSUsrMsg_CallVoteFailed time
     */
    /**
     * Constructs a new CCSUsrMsg_CallVoteFailed.
     * @exports CCSUsrMsg_CallVoteFailed
     * @classdesc Represents a CCSUsrMsg_CallVoteFailed.
     * @implements ICCSUsrMsg_CallVoteFailed
     * @constructor
     * @param {ICCSUsrMsg_CallVoteFailed=} [properties] Properties to set
     */
    function CCSUsrMsg_CallVoteFailed(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CallVoteFailed reason.
     * @member {number} reason
     * @memberof CCSUsrMsg_CallVoteFailed
     * @instance
     */
    CCSUsrMsg_CallVoteFailed.prototype.reason = 0;
    /**
     * CCSUsrMsg_CallVoteFailed time.
     * @member {number} time
     * @memberof CCSUsrMsg_CallVoteFailed
     * @instance
     */
    CCSUsrMsg_CallVoteFailed.prototype.time = 0;
    /**
     * Decodes a CCSUsrMsg_CallVoteFailed message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CallVoteFailed
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CallVoteFailed} CCSUsrMsg_CallVoteFailed
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CallVoteFailed.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CallVoteFailed();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.time = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CallVoteFailed;
})());
exports.CCSUsrMsg_VoteStart = ($root.CCSUsrMsg_VoteStart = (() => {
    /**
     * Properties of a CCSUsrMsg_VoteStart.
     * @exports ICCSUsrMsg_VoteStart
     * @interface ICCSUsrMsg_VoteStart
     * @property {number|null} [team] CCSUsrMsg_VoteStart team
     * @property {number|null} [entIdx] CCSUsrMsg_VoteStart entIdx
     * @property {number|null} [voteType] CCSUsrMsg_VoteStart voteType
     * @property {string|null} [dispStr] CCSUsrMsg_VoteStart dispStr
     * @property {string|null} [detailsStr] CCSUsrMsg_VoteStart detailsStr
     * @property {string|null} [otherTeamStr] CCSUsrMsg_VoteStart otherTeamStr
     * @property {boolean|null} [isYesNoVote] CCSUsrMsg_VoteStart isYesNoVote
     */
    /**
     * Constructs a new CCSUsrMsg_VoteStart.
     * @exports CCSUsrMsg_VoteStart
     * @classdesc Represents a CCSUsrMsg_VoteStart.
     * @implements ICCSUsrMsg_VoteStart
     * @constructor
     * @param {ICCSUsrMsg_VoteStart=} [properties] Properties to set
     */
    function CCSUsrMsg_VoteStart(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoteStart team.
     * @member {number} team
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.team = 0;
    /**
     * CCSUsrMsg_VoteStart entIdx.
     * @member {number} entIdx
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.entIdx = 0;
    /**
     * CCSUsrMsg_VoteStart voteType.
     * @member {number} voteType
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.voteType = 0;
    /**
     * CCSUsrMsg_VoteStart dispStr.
     * @member {string} dispStr
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.dispStr = "";
    /**
     * CCSUsrMsg_VoteStart detailsStr.
     * @member {string} detailsStr
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.detailsStr = "";
    /**
     * CCSUsrMsg_VoteStart otherTeamStr.
     * @member {string} otherTeamStr
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.otherTeamStr = "";
    /**
     * CCSUsrMsg_VoteStart isYesNoVote.
     * @member {boolean} isYesNoVote
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.isYesNoVote = false;
    /**
     * Decodes a CCSUsrMsg_VoteStart message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoteStart
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoteStart} CCSUsrMsg_VoteStart
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoteStart.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteStart();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.team = reader.int32();
                    break;
                case 2:
                    message.entIdx = reader.int32();
                    break;
                case 3:
                    message.voteType = reader.int32();
                    break;
                case 4:
                    message.dispStr = reader.string();
                    break;
                case 5:
                    message.detailsStr = reader.string();
                    break;
                case 6:
                    message.otherTeamStr = reader.string();
                    break;
                case 7:
                    message.isYesNoVote = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VoteStart;
})());
exports.CCSUsrMsg_VotePass = ($root.CCSUsrMsg_VotePass = (() => {
    /**
     * Properties of a CCSUsrMsg_VotePass.
     * @exports ICCSUsrMsg_VotePass
     * @interface ICCSUsrMsg_VotePass
     * @property {number|null} [team] CCSUsrMsg_VotePass team
     * @property {number|null} [voteType] CCSUsrMsg_VotePass voteType
     * @property {string|null} [dispStr] CCSUsrMsg_VotePass dispStr
     * @property {string|null} [detailsStr] CCSUsrMsg_VotePass detailsStr
     */
    /**
     * Constructs a new CCSUsrMsg_VotePass.
     * @exports CCSUsrMsg_VotePass
     * @classdesc Represents a CCSUsrMsg_VotePass.
     * @implements ICCSUsrMsg_VotePass
     * @constructor
     * @param {ICCSUsrMsg_VotePass=} [properties] Properties to set
     */
    function CCSUsrMsg_VotePass(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VotePass team.
     * @member {number} team
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.team = 0;
    /**
     * CCSUsrMsg_VotePass voteType.
     * @member {number} voteType
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.voteType = 0;
    /**
     * CCSUsrMsg_VotePass dispStr.
     * @member {string} dispStr
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.dispStr = "";
    /**
     * CCSUsrMsg_VotePass detailsStr.
     * @member {string} detailsStr
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.detailsStr = "";
    /**
     * Decodes a CCSUsrMsg_VotePass message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VotePass
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VotePass} CCSUsrMsg_VotePass
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VotePass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VotePass();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.team = reader.int32();
                    break;
                case 2:
                    message.voteType = reader.int32();
                    break;
                case 3:
                    message.dispStr = reader.string();
                    break;
                case 4:
                    message.detailsStr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VotePass;
})());
exports.CCSUsrMsg_VoteFailed = ($root.CCSUsrMsg_VoteFailed = (() => {
    /**
     * Properties of a CCSUsrMsg_VoteFailed.
     * @exports ICCSUsrMsg_VoteFailed
     * @interface ICCSUsrMsg_VoteFailed
     * @property {number|null} [team] CCSUsrMsg_VoteFailed team
     * @property {number|null} [reason] CCSUsrMsg_VoteFailed reason
     */
    /**
     * Constructs a new CCSUsrMsg_VoteFailed.
     * @exports CCSUsrMsg_VoteFailed
     * @classdesc Represents a CCSUsrMsg_VoteFailed.
     * @implements ICCSUsrMsg_VoteFailed
     * @constructor
     * @param {ICCSUsrMsg_VoteFailed=} [properties] Properties to set
     */
    function CCSUsrMsg_VoteFailed(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoteFailed team.
     * @member {number} team
     * @memberof CCSUsrMsg_VoteFailed
     * @instance
     */
    CCSUsrMsg_VoteFailed.prototype.team = 0;
    /**
     * CCSUsrMsg_VoteFailed reason.
     * @member {number} reason
     * @memberof CCSUsrMsg_VoteFailed
     * @instance
     */
    CCSUsrMsg_VoteFailed.prototype.reason = 0;
    /**
     * Decodes a CCSUsrMsg_VoteFailed message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoteFailed
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoteFailed} CCSUsrMsg_VoteFailed
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoteFailed.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteFailed();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.team = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VoteFailed;
})());
exports.CCSUsrMsg_VoteSetup = ($root.CCSUsrMsg_VoteSetup = (() => {
    /**
     * Properties of a CCSUsrMsg_VoteSetup.
     * @exports ICCSUsrMsg_VoteSetup
     * @interface ICCSUsrMsg_VoteSetup
     * @property {Array.<string>|null} [potentialIssues] CCSUsrMsg_VoteSetup potentialIssues
     */
    /**
     * Constructs a new CCSUsrMsg_VoteSetup.
     * @exports CCSUsrMsg_VoteSetup
     * @classdesc Represents a CCSUsrMsg_VoteSetup.
     * @implements ICCSUsrMsg_VoteSetup
     * @constructor
     * @param {ICCSUsrMsg_VoteSetup=} [properties] Properties to set
     */
    function CCSUsrMsg_VoteSetup(properties) {
        this.potentialIssues = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoteSetup potentialIssues.
     * @member {Array.<string>} potentialIssues
     * @memberof CCSUsrMsg_VoteSetup
     * @instance
     */
    CCSUsrMsg_VoteSetup.prototype.potentialIssues = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_VoteSetup message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoteSetup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoteSetup} CCSUsrMsg_VoteSetup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoteSetup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteSetup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.potentialIssues && message.potentialIssues.length))
                        message.potentialIssues = [];
                    message.potentialIssues.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VoteSetup;
})());
exports.CCSUsrMsg_SendLastKillerDamageToClient = ($root.CCSUsrMsg_SendLastKillerDamageToClient = (() => {
    /**
     * Properties of a CCSUsrMsg_SendLastKillerDamageToClient.
     * @exports ICCSUsrMsg_SendLastKillerDamageToClient
     * @interface ICCSUsrMsg_SendLastKillerDamageToClient
     * @property {number|null} [numHitsGiven] CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven
     * @property {number|null} [damageGiven] CCSUsrMsg_SendLastKillerDamageToClient damageGiven
     * @property {number|null} [numHitsTaken] CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken
     * @property {number|null} [damageTaken] CCSUsrMsg_SendLastKillerDamageToClient damageTaken
     */
    /**
     * Constructs a new CCSUsrMsg_SendLastKillerDamageToClient.
     * @exports CCSUsrMsg_SendLastKillerDamageToClient
     * @classdesc Represents a CCSUsrMsg_SendLastKillerDamageToClient.
     * @implements ICCSUsrMsg_SendLastKillerDamageToClient
     * @constructor
     * @param {ICCSUsrMsg_SendLastKillerDamageToClient=} [properties] Properties to set
     */
    function CCSUsrMsg_SendLastKillerDamageToClient(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven.
     * @member {number} numHitsGiven
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsGiven = 0;
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient damageGiven.
     * @member {number} damageGiven
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageGiven = 0;
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken.
     * @member {number} numHitsTaken
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsTaken = 0;
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient damageTaken.
     * @member {number} damageTaken
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageTaken = 0;
    /**
     * Decodes a CCSUsrMsg_SendLastKillerDamageToClient message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendLastKillerDamageToClient} CCSUsrMsg_SendLastKillerDamageToClient
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendLastKillerDamageToClient.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendLastKillerDamageToClient();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numHitsGiven = reader.int32();
                    break;
                case 2:
                    message.damageGiven = reader.int32();
                    break;
                case 3:
                    message.numHitsTaken = reader.int32();
                    break;
                case 4:
                    message.damageTaken = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendLastKillerDamageToClient;
})());
exports.CCSUsrMsg_ServerRankUpdate = ($root.CCSUsrMsg_ServerRankUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_ServerRankUpdate.
     * @exports ICCSUsrMsg_ServerRankUpdate
     * @interface ICCSUsrMsg_ServerRankUpdate
     * @property {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>|null} [rankUpdate] CCSUsrMsg_ServerRankUpdate rankUpdate
     */
    /**
     * Constructs a new CCSUsrMsg_ServerRankUpdate.
     * @exports CCSUsrMsg_ServerRankUpdate
     * @classdesc Represents a CCSUsrMsg_ServerRankUpdate.
     * @implements ICCSUsrMsg_ServerRankUpdate
     * @constructor
     * @param {ICCSUsrMsg_ServerRankUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_ServerRankUpdate(properties) {
        this.rankUpdate = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ServerRankUpdate rankUpdate.
     * @member {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>} rankUpdate
     * @memberof CCSUsrMsg_ServerRankUpdate
     * @instance
     */
    CCSUsrMsg_ServerRankUpdate.prototype.rankUpdate = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_ServerRankUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ServerRankUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ServerRankUpdate} CCSUsrMsg_ServerRankUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ServerRankUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.rankUpdate && message.rankUpdate.length))
                        message.rankUpdate = [];
                    message.rankUpdate.push($root.CCSUsrMsg_ServerRankUpdate.RankUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_ServerRankUpdate.RankUpdate = (function () {
        /**
         * Properties of a RankUpdate.
         * @memberof CCSUsrMsg_ServerRankUpdate
         * @interface IRankUpdate
         * @property {number|null} [accountId] RankUpdate accountId
         * @property {number|null} [rankOld] RankUpdate rankOld
         * @property {number|null} [rankNew] RankUpdate rankNew
         * @property {number|null} [numWins] RankUpdate numWins
         * @property {number|null} [rankChange] RankUpdate rankChange
         */
        /**
         * Constructs a new RankUpdate.
         * @memberof CCSUsrMsg_ServerRankUpdate
         * @classdesc Represents a RankUpdate.
         * @implements IRankUpdate
         * @constructor
         * @param {CCSUsrMsg_ServerRankUpdate.IRankUpdate=} [properties] Properties to set
         */
        function RankUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RankUpdate accountId.
         * @member {number} accountId
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.accountId = 0;
        /**
         * RankUpdate rankOld.
         * @member {number} rankOld
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.rankOld = 0;
        /**
         * RankUpdate rankNew.
         * @member {number} rankNew
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.rankNew = 0;
        /**
         * RankUpdate numWins.
         * @member {number} numWins
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.numWins = 0;
        /**
         * RankUpdate rankChange.
         * @member {number} rankChange
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.rankChange = 0;
        /**
         * Decodes a RankUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_ServerRankUpdate.RankUpdate} RankUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankUpdate.RankUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountId = reader.int32();
                        break;
                    case 2:
                        message.rankOld = reader.int32();
                        break;
                    case 3:
                        message.rankNew = reader.int32();
                        break;
                    case 4:
                        message.numWins = reader.int32();
                        break;
                    case 5:
                        message.rankChange = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return RankUpdate;
    })();
    return CCSUsrMsg_ServerRankUpdate;
})());
exports.CCSUsrMsg_XpUpdate = ($root.CCSUsrMsg_XpUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_XpUpdate.
     * @exports ICCSUsrMsg_XpUpdate
     * @interface ICCSUsrMsg_XpUpdate
     * @property {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null} [data] CCSUsrMsg_XpUpdate data
     */
    /**
     * Constructs a new CCSUsrMsg_XpUpdate.
     * @exports CCSUsrMsg_XpUpdate
     * @classdesc Represents a CCSUsrMsg_XpUpdate.
     * @implements ICCSUsrMsg_XpUpdate
     * @constructor
     * @param {ICCSUsrMsg_XpUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_XpUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_XpUpdate data.
     * @member {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null|undefined} data
     * @memberof CCSUsrMsg_XpUpdate
     * @instance
     */
    CCSUsrMsg_XpUpdate.prototype.data = null;
    /**
     * Decodes a CCSUsrMsg_XpUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_XpUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_XpUpdate} CCSUsrMsg_XpUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_XpUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XpUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_XpUpdate;
})());
exports.CCSUsrMsg_ItemPickup = ($root.CCSUsrMsg_ItemPickup = (() => {
    /**
     * Properties of a CCSUsrMsg_ItemPickup.
     * @exports ICCSUsrMsg_ItemPickup
     * @interface ICCSUsrMsg_ItemPickup
     * @property {string|null} [item] CCSUsrMsg_ItemPickup item
     */
    /**
     * Constructs a new CCSUsrMsg_ItemPickup.
     * @exports CCSUsrMsg_ItemPickup
     * @classdesc Represents a CCSUsrMsg_ItemPickup.
     * @implements ICCSUsrMsg_ItemPickup
     * @constructor
     * @param {ICCSUsrMsg_ItemPickup=} [properties] Properties to set
     */
    function CCSUsrMsg_ItemPickup(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ItemPickup item.
     * @member {string} item
     * @memberof CCSUsrMsg_ItemPickup
     * @instance
     */
    CCSUsrMsg_ItemPickup.prototype.item = "";
    /**
     * Decodes a CCSUsrMsg_ItemPickup message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ItemPickup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ItemPickup} CCSUsrMsg_ItemPickup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ItemPickup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ItemPickup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.item = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ItemPickup;
})());
exports.CCSUsrMsg_ShowMenu = ($root.CCSUsrMsg_ShowMenu = (() => {
    /**
     * Properties of a CCSUsrMsg_ShowMenu.
     * @exports ICCSUsrMsg_ShowMenu
     * @interface ICCSUsrMsg_ShowMenu
     * @property {number|null} [bitsValidSlots] CCSUsrMsg_ShowMenu bitsValidSlots
     * @property {number|null} [displayTime] CCSUsrMsg_ShowMenu displayTime
     * @property {string|null} [menuString] CCSUsrMsg_ShowMenu menuString
     */
    /**
     * Constructs a new CCSUsrMsg_ShowMenu.
     * @exports CCSUsrMsg_ShowMenu
     * @classdesc Represents a CCSUsrMsg_ShowMenu.
     * @implements ICCSUsrMsg_ShowMenu
     * @constructor
     * @param {ICCSUsrMsg_ShowMenu=} [properties] Properties to set
     */
    function CCSUsrMsg_ShowMenu(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ShowMenu bitsValidSlots.
     * @member {number} bitsValidSlots
     * @memberof CCSUsrMsg_ShowMenu
     * @instance
     */
    CCSUsrMsg_ShowMenu.prototype.bitsValidSlots = 0;
    /**
     * CCSUsrMsg_ShowMenu displayTime.
     * @member {number} displayTime
     * @memberof CCSUsrMsg_ShowMenu
     * @instance
     */
    CCSUsrMsg_ShowMenu.prototype.displayTime = 0;
    /**
     * CCSUsrMsg_ShowMenu menuString.
     * @member {string} menuString
     * @memberof CCSUsrMsg_ShowMenu
     * @instance
     */
    CCSUsrMsg_ShowMenu.prototype.menuString = "";
    /**
     * Decodes a CCSUsrMsg_ShowMenu message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ShowMenu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ShowMenu} CCSUsrMsg_ShowMenu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ShowMenu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ShowMenu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bitsValidSlots = reader.int32();
                    break;
                case 2:
                    message.displayTime = reader.int32();
                    break;
                case 3:
                    message.menuString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ShowMenu;
})());
exports.CCSUsrMsg_BarTime = ($root.CCSUsrMsg_BarTime = (() => {
    /**
     * Properties of a CCSUsrMsg_BarTime.
     * @exports ICCSUsrMsg_BarTime
     * @interface ICCSUsrMsg_BarTime
     * @property {string|null} [time] CCSUsrMsg_BarTime time
     */
    /**
     * Constructs a new CCSUsrMsg_BarTime.
     * @exports CCSUsrMsg_BarTime
     * @classdesc Represents a CCSUsrMsg_BarTime.
     * @implements ICCSUsrMsg_BarTime
     * @constructor
     * @param {ICCSUsrMsg_BarTime=} [properties] Properties to set
     */
    function CCSUsrMsg_BarTime(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_BarTime time.
     * @member {string} time
     * @memberof CCSUsrMsg_BarTime
     * @instance
     */
    CCSUsrMsg_BarTime.prototype.time = "";
    /**
     * Decodes a CCSUsrMsg_BarTime message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_BarTime
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_BarTime} CCSUsrMsg_BarTime
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_BarTime.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_BarTime();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_BarTime;
})());
exports.CCSUsrMsg_AmmoDenied = ($root.CCSUsrMsg_AmmoDenied = (() => {
    /**
     * Properties of a CCSUsrMsg_AmmoDenied.
     * @exports ICCSUsrMsg_AmmoDenied
     * @interface ICCSUsrMsg_AmmoDenied
     * @property {number|null} [ammoIdx] CCSUsrMsg_AmmoDenied ammoIdx
     */
    /**
     * Constructs a new CCSUsrMsg_AmmoDenied.
     * @exports CCSUsrMsg_AmmoDenied
     * @classdesc Represents a CCSUsrMsg_AmmoDenied.
     * @implements ICCSUsrMsg_AmmoDenied
     * @constructor
     * @param {ICCSUsrMsg_AmmoDenied=} [properties] Properties to set
     */
    function CCSUsrMsg_AmmoDenied(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_AmmoDenied ammoIdx.
     * @member {number} ammoIdx
     * @memberof CCSUsrMsg_AmmoDenied
     * @instance
     */
    CCSUsrMsg_AmmoDenied.prototype.ammoIdx = 0;
    /**
     * Decodes a CCSUsrMsg_AmmoDenied message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_AmmoDenied
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_AmmoDenied} CCSUsrMsg_AmmoDenied
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_AmmoDenied.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AmmoDenied();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ammoIdx = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_AmmoDenied;
})());
exports.CCSUsrMsg_MarkAchievement = ($root.CCSUsrMsg_MarkAchievement = (() => {
    /**
     * Properties of a CCSUsrMsg_MarkAchievement.
     * @exports ICCSUsrMsg_MarkAchievement
     * @interface ICCSUsrMsg_MarkAchievement
     * @property {string|null} [achievement] CCSUsrMsg_MarkAchievement achievement
     */
    /**
     * Constructs a new CCSUsrMsg_MarkAchievement.
     * @exports CCSUsrMsg_MarkAchievement
     * @classdesc Represents a CCSUsrMsg_MarkAchievement.
     * @implements ICCSUsrMsg_MarkAchievement
     * @constructor
     * @param {ICCSUsrMsg_MarkAchievement=} [properties] Properties to set
     */
    function CCSUsrMsg_MarkAchievement(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_MarkAchievement achievement.
     * @member {string} achievement
     * @memberof CCSUsrMsg_MarkAchievement
     * @instance
     */
    CCSUsrMsg_MarkAchievement.prototype.achievement = "";
    /**
     * Decodes a CCSUsrMsg_MarkAchievement message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_MarkAchievement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_MarkAchievement} CCSUsrMsg_MarkAchievement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_MarkAchievement.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MarkAchievement();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.achievement = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_MarkAchievement;
})());
exports.CCSUsrMsg_MatchStatsUpdate = ($root.CCSUsrMsg_MatchStatsUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_MatchStatsUpdate.
     * @exports ICCSUsrMsg_MatchStatsUpdate
     * @interface ICCSUsrMsg_MatchStatsUpdate
     * @property {string|null} [update] CCSUsrMsg_MatchStatsUpdate update
     */
    /**
     * Constructs a new CCSUsrMsg_MatchStatsUpdate.
     * @exports CCSUsrMsg_MatchStatsUpdate
     * @classdesc Represents a CCSUsrMsg_MatchStatsUpdate.
     * @implements ICCSUsrMsg_MatchStatsUpdate
     * @constructor
     * @param {ICCSUsrMsg_MatchStatsUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_MatchStatsUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_MatchStatsUpdate update.
     * @member {string} update
     * @memberof CCSUsrMsg_MatchStatsUpdate
     * @instance
     */
    CCSUsrMsg_MatchStatsUpdate.prototype.update = "";
    /**
     * Decodes a CCSUsrMsg_MatchStatsUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_MatchStatsUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_MatchStatsUpdate} CCSUsrMsg_MatchStatsUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_MatchStatsUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MatchStatsUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.update = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_MatchStatsUpdate;
})());
exports.CCSUsrMsg_ItemDrop = ($root.CCSUsrMsg_ItemDrop = (() => {
    /**
     * Properties of a CCSUsrMsg_ItemDrop.
     * @exports ICCSUsrMsg_ItemDrop
     * @interface ICCSUsrMsg_ItemDrop
     * @property {number|Long|null} [itemid] CCSUsrMsg_ItemDrop itemid
     * @property {boolean|null} [death] CCSUsrMsg_ItemDrop death
     */
    /**
     * Constructs a new CCSUsrMsg_ItemDrop.
     * @exports CCSUsrMsg_ItemDrop
     * @classdesc Represents a CCSUsrMsg_ItemDrop.
     * @implements ICCSUsrMsg_ItemDrop
     * @constructor
     * @param {ICCSUsrMsg_ItemDrop=} [properties] Properties to set
     */
    function CCSUsrMsg_ItemDrop(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ItemDrop itemid.
     * @member {number|Long} itemid
     * @memberof CCSUsrMsg_ItemDrop
     * @instance
     */
    CCSUsrMsg_ItemDrop.prototype.itemid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CCSUsrMsg_ItemDrop death.
     * @member {boolean} death
     * @memberof CCSUsrMsg_ItemDrop
     * @instance
     */
    CCSUsrMsg_ItemDrop.prototype.death = false;
    /**
     * Decodes a CCSUsrMsg_ItemDrop message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ItemDrop
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ItemDrop} CCSUsrMsg_ItemDrop
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ItemDrop.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ItemDrop();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemid = reader.int64();
                    break;
                case 2:
                    message.death = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ItemDrop;
})());
exports.CCSUsrMsg_GlowPropTurnOff = ($root.CCSUsrMsg_GlowPropTurnOff = (() => {
    /**
     * Properties of a CCSUsrMsg_GlowPropTurnOff.
     * @exports ICCSUsrMsg_GlowPropTurnOff
     * @interface ICCSUsrMsg_GlowPropTurnOff
     * @property {number|null} [entidx] CCSUsrMsg_GlowPropTurnOff entidx
     */
    /**
     * Constructs a new CCSUsrMsg_GlowPropTurnOff.
     * @exports CCSUsrMsg_GlowPropTurnOff
     * @classdesc Represents a CCSUsrMsg_GlowPropTurnOff.
     * @implements ICCSUsrMsg_GlowPropTurnOff
     * @constructor
     * @param {ICCSUsrMsg_GlowPropTurnOff=} [properties] Properties to set
     */
    function CCSUsrMsg_GlowPropTurnOff(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_GlowPropTurnOff entidx.
     * @member {number} entidx
     * @memberof CCSUsrMsg_GlowPropTurnOff
     * @instance
     */
    CCSUsrMsg_GlowPropTurnOff.prototype.entidx = 0;
    /**
     * Decodes a CCSUsrMsg_GlowPropTurnOff message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_GlowPropTurnOff
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_GlowPropTurnOff} CCSUsrMsg_GlowPropTurnOff
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_GlowPropTurnOff.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_GlowPropTurnOff();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entidx = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_GlowPropTurnOff;
})());
exports.CCSUsrMsg_RoundBackupFilenames = ($root.CCSUsrMsg_RoundBackupFilenames = (() => {
    /**
     * Properties of a CCSUsrMsg_RoundBackupFilenames.
     * @exports ICCSUsrMsg_RoundBackupFilenames
     * @interface ICCSUsrMsg_RoundBackupFilenames
     * @property {number|null} [count] CCSUsrMsg_RoundBackupFilenames count
     * @property {number|null} [index] CCSUsrMsg_RoundBackupFilenames index
     * @property {string|null} [filename] CCSUsrMsg_RoundBackupFilenames filename
     * @property {string|null} [nicename] CCSUsrMsg_RoundBackupFilenames nicename
     */
    /**
     * Constructs a new CCSUsrMsg_RoundBackupFilenames.
     * @exports CCSUsrMsg_RoundBackupFilenames
     * @classdesc Represents a CCSUsrMsg_RoundBackupFilenames.
     * @implements ICCSUsrMsg_RoundBackupFilenames
     * @constructor
     * @param {ICCSUsrMsg_RoundBackupFilenames=} [properties] Properties to set
     */
    function CCSUsrMsg_RoundBackupFilenames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RoundBackupFilenames count.
     * @member {number} count
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.count = 0;
    /**
     * CCSUsrMsg_RoundBackupFilenames index.
     * @member {number} index
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.index = 0;
    /**
     * CCSUsrMsg_RoundBackupFilenames filename.
     * @member {string} filename
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.filename = "";
    /**
     * CCSUsrMsg_RoundBackupFilenames nicename.
     * @member {string} nicename
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.nicename = "";
    /**
     * Decodes a CCSUsrMsg_RoundBackupFilenames message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RoundBackupFilenames} CCSUsrMsg_RoundBackupFilenames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RoundBackupFilenames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RoundBackupFilenames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.filename = reader.string();
                    break;
                case 4:
                    message.nicename = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RoundBackupFilenames;
})());
exports.CCSUsrMsg_ResetHud = ($root.CCSUsrMsg_ResetHud = (() => {
    /**
     * Properties of a CCSUsrMsg_ResetHud.
     * @exports ICCSUsrMsg_ResetHud
     * @interface ICCSUsrMsg_ResetHud
     * @property {boolean|null} [reset] CCSUsrMsg_ResetHud reset
     */
    /**
     * Constructs a new CCSUsrMsg_ResetHud.
     * @exports CCSUsrMsg_ResetHud
     * @classdesc Represents a CCSUsrMsg_ResetHud.
     * @implements ICCSUsrMsg_ResetHud
     * @constructor
     * @param {ICCSUsrMsg_ResetHud=} [properties] Properties to set
     */
    function CCSUsrMsg_ResetHud(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ResetHud reset.
     * @member {boolean} reset
     * @memberof CCSUsrMsg_ResetHud
     * @instance
     */
    CCSUsrMsg_ResetHud.prototype.reset = false;
    /**
     * Decodes a CCSUsrMsg_ResetHud message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ResetHud
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ResetHud} CCSUsrMsg_ResetHud
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ResetHud.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ResetHud();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reset = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ResetHud;
})());
exports.CCSUsrMsg_GameTitle = ($root.CCSUsrMsg_GameTitle = (() => {
    /**
     * Properties of a CCSUsrMsg_GameTitle.
     * @exports ICCSUsrMsg_GameTitle
     * @interface ICCSUsrMsg_GameTitle
     * @property {number|null} [dummy] CCSUsrMsg_GameTitle dummy
     */
    /**
     * Constructs a new CCSUsrMsg_GameTitle.
     * @exports CCSUsrMsg_GameTitle
     * @classdesc Represents a CCSUsrMsg_GameTitle.
     * @implements ICCSUsrMsg_GameTitle
     * @constructor
     * @param {ICCSUsrMsg_GameTitle=} [properties] Properties to set
     */
    function CCSUsrMsg_GameTitle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_GameTitle dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_GameTitle
     * @instance
     */
    CCSUsrMsg_GameTitle.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_GameTitle message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_GameTitle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_GameTitle} CCSUsrMsg_GameTitle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_GameTitle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_GameTitle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_GameTitle;
})());
exports.CCSUsrMsg_RequestState = ($root.CCSUsrMsg_RequestState = (() => {
    /**
     * Properties of a CCSUsrMsg_RequestState.
     * @exports ICCSUsrMsg_RequestState
     * @interface ICCSUsrMsg_RequestState
     * @property {number|null} [dummy] CCSUsrMsg_RequestState dummy
     */
    /**
     * Constructs a new CCSUsrMsg_RequestState.
     * @exports CCSUsrMsg_RequestState
     * @classdesc Represents a CCSUsrMsg_RequestState.
     * @implements ICCSUsrMsg_RequestState
     * @constructor
     * @param {ICCSUsrMsg_RequestState=} [properties] Properties to set
     */
    function CCSUsrMsg_RequestState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RequestState dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_RequestState
     * @instance
     */
    CCSUsrMsg_RequestState.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_RequestState message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RequestState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RequestState} CCSUsrMsg_RequestState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RequestState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RequestState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RequestState;
})());
exports.CCSUsrMsg_StopSpectatorMode = ($root.CCSUsrMsg_StopSpectatorMode = (() => {
    /**
     * Properties of a CCSUsrMsg_StopSpectatorMode.
     * @exports ICCSUsrMsg_StopSpectatorMode
     * @interface ICCSUsrMsg_StopSpectatorMode
     * @property {number|null} [dummy] CCSUsrMsg_StopSpectatorMode dummy
     */
    /**
     * Constructs a new CCSUsrMsg_StopSpectatorMode.
     * @exports CCSUsrMsg_StopSpectatorMode
     * @classdesc Represents a CCSUsrMsg_StopSpectatorMode.
     * @implements ICCSUsrMsg_StopSpectatorMode
     * @constructor
     * @param {ICCSUsrMsg_StopSpectatorMode=} [properties] Properties to set
     */
    function CCSUsrMsg_StopSpectatorMode(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_StopSpectatorMode dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_StopSpectatorMode
     * @instance
     */
    CCSUsrMsg_StopSpectatorMode.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_StopSpectatorMode message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_StopSpectatorMode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_StopSpectatorMode} CCSUsrMsg_StopSpectatorMode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_StopSpectatorMode.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_StopSpectatorMode();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_StopSpectatorMode;
})());
exports.CCSUsrMsg_DisconnectToLobby = ($root.CCSUsrMsg_DisconnectToLobby = (() => {
    /**
     * Properties of a CCSUsrMsg_DisconnectToLobby.
     * @exports ICCSUsrMsg_DisconnectToLobby
     * @interface ICCSUsrMsg_DisconnectToLobby
     * @property {number|null} [dummy] CCSUsrMsg_DisconnectToLobby dummy
     */
    /**
     * Constructs a new CCSUsrMsg_DisconnectToLobby.
     * @exports CCSUsrMsg_DisconnectToLobby
     * @classdesc Represents a CCSUsrMsg_DisconnectToLobby.
     * @implements ICCSUsrMsg_DisconnectToLobby
     * @constructor
     * @param {ICCSUsrMsg_DisconnectToLobby=} [properties] Properties to set
     */
    function CCSUsrMsg_DisconnectToLobby(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_DisconnectToLobby dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_DisconnectToLobby
     * @instance
     */
    CCSUsrMsg_DisconnectToLobby.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_DisconnectToLobby message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_DisconnectToLobby
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_DisconnectToLobby} CCSUsrMsg_DisconnectToLobby
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_DisconnectToLobby.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DisconnectToLobby();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_DisconnectToLobby;
})());
exports.CCSUsrMsg_WarmupHasEnded = ($root.CCSUsrMsg_WarmupHasEnded = (() => {
    /**
     * Properties of a CCSUsrMsg_WarmupHasEnded.
     * @exports ICCSUsrMsg_WarmupHasEnded
     * @interface ICCSUsrMsg_WarmupHasEnded
     * @property {number|null} [dummy] CCSUsrMsg_WarmupHasEnded dummy
     */
    /**
     * Constructs a new CCSUsrMsg_WarmupHasEnded.
     * @exports CCSUsrMsg_WarmupHasEnded
     * @classdesc Represents a CCSUsrMsg_WarmupHasEnded.
     * @implements ICCSUsrMsg_WarmupHasEnded
     * @constructor
     * @param {ICCSUsrMsg_WarmupHasEnded=} [properties] Properties to set
     */
    function CCSUsrMsg_WarmupHasEnded(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_WarmupHasEnded dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_WarmupHasEnded
     * @instance
     */
    CCSUsrMsg_WarmupHasEnded.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_WarmupHasEnded message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_WarmupHasEnded
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_WarmupHasEnded} CCSUsrMsg_WarmupHasEnded
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_WarmupHasEnded.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_WarmupHasEnded();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_WarmupHasEnded;
})());
exports.CCSUsrMsg_ClientInfo = ($root.CCSUsrMsg_ClientInfo = (() => {
    /**
     * Properties of a CCSUsrMsg_ClientInfo.
     * @exports ICCSUsrMsg_ClientInfo
     * @interface ICCSUsrMsg_ClientInfo
     * @property {number|null} [dummy] CCSUsrMsg_ClientInfo dummy
     */
    /**
     * Constructs a new CCSUsrMsg_ClientInfo.
     * @exports CCSUsrMsg_ClientInfo
     * @classdesc Represents a CCSUsrMsg_ClientInfo.
     * @implements ICCSUsrMsg_ClientInfo
     * @constructor
     * @param {ICCSUsrMsg_ClientInfo=} [properties] Properties to set
     */
    function CCSUsrMsg_ClientInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ClientInfo dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_ClientInfo
     * @instance
     */
    CCSUsrMsg_ClientInfo.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_ClientInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ClientInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ClientInfo} CCSUsrMsg_ClientInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ClientInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ClientInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ClientInfo;
})());
exports.CCSUsrMsg_ServerRankRevealAll = ($root.CCSUsrMsg_ServerRankRevealAll = (() => {
    /**
     * Properties of a CCSUsrMsg_ServerRankRevealAll.
     * @exports ICCSUsrMsg_ServerRankRevealAll
     * @interface ICCSUsrMsg_ServerRankRevealAll
     * @property {number|null} [secondsTillShutdown] CCSUsrMsg_ServerRankRevealAll secondsTillShutdown
     */
    /**
     * Constructs a new CCSUsrMsg_ServerRankRevealAll.
     * @exports CCSUsrMsg_ServerRankRevealAll
     * @classdesc Represents a CCSUsrMsg_ServerRankRevealAll.
     * @implements ICCSUsrMsg_ServerRankRevealAll
     * @constructor
     * @param {ICCSUsrMsg_ServerRankRevealAll=} [properties] Properties to set
     */
    function CCSUsrMsg_ServerRankRevealAll(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ServerRankRevealAll secondsTillShutdown.
     * @member {number} secondsTillShutdown
     * @memberof CCSUsrMsg_ServerRankRevealAll
     * @instance
     */
    CCSUsrMsg_ServerRankRevealAll.prototype.secondsTillShutdown = 0;
    /**
     * Decodes a CCSUsrMsg_ServerRankRevealAll message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ServerRankRevealAll
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ServerRankRevealAll} CCSUsrMsg_ServerRankRevealAll
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ServerRankRevealAll.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankRevealAll();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.secondsTillShutdown = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ServerRankRevealAll;
})());
exports.google = ($root.google = (() => {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};
    google.protobuf = (function () {
        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};
        protobuf.FileDescriptorSet = (function () {
            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */
            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;
            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return FileDescriptorSet;
        })();
        protobuf.FileDescriptorProto = (function () {
            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */
            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";
            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";
            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;
            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;
            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;
            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;
            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;
            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;
            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;
            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;
            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;
            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";
            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 10:
                            if (!(message.publicDependency && message.publicDependency.length))
                                message.publicDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.publicDependency.push(reader.int32());
                            }
                            else
                                message.publicDependency.push(reader.int32());
                            break;
                        case 11:
                            if (!(message.weakDependency && message.weakDependency.length))
                                message.weakDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weakDependency.push(reader.int32());
                            }
                            else
                                message.weakDependency.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.messageType && message.messageType.length))
                                message.messageType = [];
                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.syntax = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return FileDescriptorProto;
        })();
        protobuf.DescriptorProto = (function () {
            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */
            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";
            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;
            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;
            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;
            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;
            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;
            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;
            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;
            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;
            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;
            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nestedType && message.nestedType.length))
                                message.nestedType = [];
                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extensionRange && message.extensionRange.length))
                                message.extensionRange = [];
                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.oneofDecl && message.oneofDecl.length))
                                message.oneofDecl = [];
                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            DescriptorProto.ExtensionRange = (function () {
                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */
                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;
                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;
                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return ExtensionRange;
            })();
            DescriptorProto.ReservedRange = (function () {
                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */
                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;
                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;
                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return ReservedRange;
            })();
            return DescriptorProto;
        })();
        protobuf.FieldDescriptorProto = (function () {
            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */
            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";
            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;
            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;
            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;
            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";
            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";
            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";
            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;
            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";
            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;
            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.typeName = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.defaultValue = reader.string();
                            break;
                        case 9:
                            message.oneofIndex = reader.int32();
                            break;
                        case 10:
                            message.jsonName = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[(valuesById[1] = "TYPE_DOUBLE")] = 1;
                values[(valuesById[2] = "TYPE_FLOAT")] = 2;
                values[(valuesById[3] = "TYPE_INT64")] = 3;
                values[(valuesById[4] = "TYPE_UINT64")] = 4;
                values[(valuesById[5] = "TYPE_INT32")] = 5;
                values[(valuesById[6] = "TYPE_FIXED64")] = 6;
                values[(valuesById[7] = "TYPE_FIXED32")] = 7;
                values[(valuesById[8] = "TYPE_BOOL")] = 8;
                values[(valuesById[9] = "TYPE_STRING")] = 9;
                values[(valuesById[10] = "TYPE_GROUP")] = 10;
                values[(valuesById[11] = "TYPE_MESSAGE")] = 11;
                values[(valuesById[12] = "TYPE_BYTES")] = 12;
                values[(valuesById[13] = "TYPE_UINT32")] = 13;
                values[(valuesById[14] = "TYPE_ENUM")] = 14;
                values[(valuesById[15] = "TYPE_SFIXED32")] = 15;
                values[(valuesById[16] = "TYPE_SFIXED64")] = 16;
                values[(valuesById[17] = "TYPE_SINT32")] = 17;
                values[(valuesById[18] = "TYPE_SINT64")] = 18;
                return values;
            })();
            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[(valuesById[1] = "LABEL_OPTIONAL")] = 1;
                values[(valuesById[2] = "LABEL_REQUIRED")] = 2;
                values[(valuesById[3] = "LABEL_REPEATED")] = 3;
                return values;
            })();
            return FieldDescriptorProto;
        })();
        protobuf.OneofDescriptorProto = (function () {
            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */
            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";
            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;
            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return OneofDescriptorProto;
        })();
        protobuf.EnumDescriptorProto = (function () {
            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */
            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";
            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;
            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;
            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumDescriptorProto;
        })();
        protobuf.EnumValueDescriptorProto = (function () {
            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */
            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";
            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;
            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;
            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumValueDescriptorProto;
        })();
        protobuf.ServiceDescriptorProto = (function () {
            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */
            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";
            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;
            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;
            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return ServiceDescriptorProto;
        })();
        protobuf.MethodDescriptorProto = (function () {
            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */
            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";
            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";
            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";
            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;
            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;
            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;
            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.inputType = reader.string();
                            break;
                        case 3:
                            message.outputType = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.clientStreaming = reader.bool();
                            break;
                        case 6:
                            message.serverStreaming = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return MethodDescriptorProto;
        })();
        protobuf.FileOptions = (function () {
            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */
            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";
            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";
            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;
            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;
            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;
            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;
            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";
            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;
            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;
            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;
            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;
            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;
            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";
            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";
            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.javaPackage = reader.string();
                            break;
                        case 8:
                            message.javaOuterClassname = reader.string();
                            break;
                        case 10:
                            message.javaMultipleFiles = reader.bool();
                            break;
                        case 20:
                            message.javaGenerateEqualsAndHash = reader.bool();
                            break;
                        case 27:
                            message.javaStringCheckUtf8 = reader.bool();
                            break;
                        case 9:
                            message.optimizeFor = reader.int32();
                            break;
                        case 11:
                            message.goPackage = reader.string();
                            break;
                        case 16:
                            message.ccGenericServices = reader.bool();
                            break;
                        case 17:
                            message.javaGenericServices = reader.bool();
                            break;
                        case 18:
                            message.pyGenericServices = reader.bool();
                            break;
                        case 23:
                            message.deprecated = reader.bool();
                            break;
                        case 31:
                            message.ccEnableArenas = reader.bool();
                            break;
                        case 36:
                            message.objcClassPrefix = reader.string();
                            break;
                        case 37:
                            message.csharpNamespace = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[(valuesById[1] = "SPEED")] = 1;
                values[(valuesById[2] = "CODE_SIZE")] = 2;
                values[(valuesById[3] = "LITE_RUNTIME")] = 3;
                return values;
            })();
            return FileOptions;
        })();
        protobuf.MessageOptions = (function () {
            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             * @property {number|null} [".msgpoolSoftLimit"] MessageOptions .msgpoolSoftLimit
             * @property {number|null} [".msgpoolHardLimit"] MessageOptions .msgpoolHardLimit
             */
            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;
            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;
            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;
            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;
            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * MessageOptions .msgpoolSoftLimit.
             * @member {number} .msgpoolSoftLimit
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".msgpoolSoftLimit"] = 32;
            /**
             * MessageOptions .msgpoolHardLimit.
             * @member {number} .msgpoolHardLimit
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".msgpoolHardLimit"] = 384;
            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.messageSetWireFormat = reader.bool();
                            break;
                        case 2:
                            message.noStandardDescriptorAccessor = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 7:
                            message.mapEntry = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 60000:
                            message[".msgpoolSoftLimit"] = reader.int32();
                            break;
                        case 60001:
                            message[".msgpoolHardLimit"] = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return MessageOptions;
        })();
        protobuf.FieldOptions = (function () {
            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".keyField"] FieldOptions .keyField
             */
            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;
            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;
            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;
            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;
            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;
            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;
            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * FieldOptions .keyField.
             * @member {boolean} .keyField
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".keyField"] = false;
            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 6:
                            message.jstype = reader.int32();
                            break;
                        case 5:
                            message.lazy = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 10:
                            message.weak = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 60000:
                            message[".keyField"] = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[(valuesById[0] = "STRING")] = 0;
                values[(valuesById[1] = "CORD")] = 1;
                values[(valuesById[2] = "STRING_PIECE")] = 2;
                return values;
            })();
            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[(valuesById[0] = "JS_NORMAL")] = 0;
                values[(valuesById[1] = "JS_STRING")] = 1;
                values[(valuesById[2] = "JS_NUMBER")] = 2;
                return values;
            })();
            return FieldOptions;
        })();
        protobuf.OneofOptions = (function () {
            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */
            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return OneofOptions;
        })();
        protobuf.EnumOptions = (function () {
            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */
            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;
            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;
            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 2:
                            message.allowAlias = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumOptions;
        })();
        protobuf.EnumValueOptions = (function () {
            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */
            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;
            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumValueOptions;
        })();
        protobuf.ServiceOptions = (function () {
            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */
            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;
            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return ServiceOptions;
        })();
        protobuf.MethodOptions = (function () {
            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */
            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;
            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption &&
                                message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return MethodOptions;
        })();
        protobuf.UninterpretedOption = (function () {
            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */
            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;
            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";
            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long
                ? $util.Long.fromBits(0, 0, true)
                : 0;
            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long
                ? $util.Long.fromBits(0, 0, false)
                : 0;
            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;
            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);
            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";
            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifierValue = reader.string();
                            break;
                        case 4:
                            message.positiveIntValue = reader.uint64();
                            break;
                        case 5:
                            message.negativeIntValue = reader.int64();
                            break;
                        case 6:
                            message.doubleValue = reader.double();
                            break;
                        case 7:
                            message.stringValue = reader.bytes();
                            break;
                        case 8:
                            message.aggregateValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            UninterpretedOption.NamePart = (function () {
                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */
                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";
                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;
                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.namePart = reader.string();
                                break;
                            case 2:
                                message.isExtension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", {
                            instance: message
                        });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", {
                            instance: message
                        });
                    return message;
                };
                return NamePart;
            })();
            return UninterpretedOption;
        })();
        protobuf.SourceCodeInfo = (function () {
            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */
            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;
            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            SourceCodeInfo.Location = (function () {
                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */
                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;
                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;
                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";
                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";
                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;
                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                }
                                else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                }
                                else
                                    message.span.push(reader.int32());
                                break;
                            case 3:
                                message.leadingComments = reader.string();
                                break;
                            case 4:
                                message.trailingComments = reader.string();
                                break;
                            case 6:
                                if (!(message.leadingDetachedComments &&
                                    message.leadingDetachedComments.length))
                                    message.leadingDetachedComments = [];
                                message.leadingDetachedComments.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return Location;
            })();
            return SourceCodeInfo;
        })();
        protobuf.GeneratedCodeInfo = (function () {
            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */
            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            GeneratedCodeInfo.Annotation = (function () {
                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */
                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;
                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";
                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;
                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;
                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                }
                                else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                message.sourceFile = reader.string();
                                break;
                            case 3:
                                message.begin = reader.int32();
                                break;
                            case 4:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return Annotation;
            })();
            return GeneratedCodeInfo;
        })();
        return protobuf;
    })();
    return google;
})());
/**
 * NET_Messages enum.
 * @exports NET_Messages
 * @enum {string}
 * @property {number} net_NOP=0 net_NOP value
 * @property {number} net_Disconnect=1 net_Disconnect value
 * @property {number} net_File=2 net_File value
 * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
 * @property {number} net_Tick=4 net_Tick value
 * @property {number} net_StringCmd=5 net_StringCmd value
 * @property {number} net_SetConVar=6 net_SetConVar value
 * @property {number} net_SignonState=7 net_SignonState value
 * @property {number} net_PlayerAvatarData=100 net_PlayerAvatarData value
 */
$root.NET_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[0] = "net_NOP")] = 0;
    values[(valuesById[1] = "net_Disconnect")] = 1;
    values[(valuesById[2] = "net_File")] = 2;
    values[(valuesById[3] = "net_SplitScreenUser")] = 3;
    values[(valuesById[4] = "net_Tick")] = 4;
    values[(valuesById[5] = "net_StringCmd")] = 5;
    values[(valuesById[6] = "net_SetConVar")] = 6;
    values[(valuesById[7] = "net_SignonState")] = 7;
    values[(valuesById[100] = "net_PlayerAvatarData")] = 100;
    return values;
})();
/**
 * CLC_Messages enum.
 * @exports CLC_Messages
 * @enum {string}
 * @property {number} clc_ClientInfo=8 clc_ClientInfo value
 * @property {number} clc_Move=9 clc_Move value
 * @property {number} clc_VoiceData=10 clc_VoiceData value
 * @property {number} clc_BaselineAck=11 clc_BaselineAck value
 * @property {number} clc_ListenEvents=12 clc_ListenEvents value
 * @property {number} clc_RespondCvarValue=13 clc_RespondCvarValue value
 * @property {number} clc_FileCRCCheck=14 clc_FileCRCCheck value
 * @property {number} clc_LoadingProgress=15 clc_LoadingProgress value
 * @property {number} clc_SplitPlayerConnect=16 clc_SplitPlayerConnect value
 * @property {number} clc_ClientMessage=17 clc_ClientMessage value
 * @property {number} clc_CmdKeyValues=18 clc_CmdKeyValues value
 * @property {number} clc_HltvReplay=20 clc_HltvReplay value
 */
$root.CLC_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[8] = "clc_ClientInfo")] = 8;
    values[(valuesById[9] = "clc_Move")] = 9;
    values[(valuesById[10] = "clc_VoiceData")] = 10;
    values[(valuesById[11] = "clc_BaselineAck")] = 11;
    values[(valuesById[12] = "clc_ListenEvents")] = 12;
    values[(valuesById[13] = "clc_RespondCvarValue")] = 13;
    values[(valuesById[14] = "clc_FileCRCCheck")] = 14;
    values[(valuesById[15] = "clc_LoadingProgress")] = 15;
    values[(valuesById[16] = "clc_SplitPlayerConnect")] = 16;
    values[(valuesById[17] = "clc_ClientMessage")] = 17;
    values[(valuesById[18] = "clc_CmdKeyValues")] = 18;
    values[(valuesById[20] = "clc_HltvReplay")] = 20;
    return values;
})();
/**
 * VoiceDataFormat_t enum.
 * @exports VoiceDataFormat_t
 * @enum {string}
 * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value
 * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value
 */
$root.VoiceDataFormat_t = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[0] = "VOICEDATA_FORMAT_STEAM")] = 0;
    values[(valuesById[1] = "VOICEDATA_FORMAT_ENGINE")] = 1;
    return values;
})();
/**
 * ESplitScreenMessageType enum.
 * @exports ESplitScreenMessageType
 * @enum {string}
 * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value
 * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value
 * @property {number} MSG_SPLITSCREEN_TYPE_BITS=1 MSG_SPLITSCREEN_TYPE_BITS value
 */
$root.ESplitScreenMessageType = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[0] = "MSG_SPLITSCREEN_ADDUSER")] = 0;
    values[(valuesById[1] = "MSG_SPLITSCREEN_REMOVEUSER")] = 1;
    values["MSG_SPLITSCREEN_TYPE_BITS"] = 1;
    return values;
})();
/**
 * SVC_Messages enum.
 * @exports SVC_Messages
 * @enum {string}
 * @property {number} svc_ServerInfo=8 svc_ServerInfo value
 * @property {number} svc_SendTable=9 svc_SendTable value
 * @property {number} svc_ClassInfo=10 svc_ClassInfo value
 * @property {number} svc_SetPause=11 svc_SetPause value
 * @property {number} svc_CreateStringTable=12 svc_CreateStringTable value
 * @property {number} svc_UpdateStringTable=13 svc_UpdateStringTable value
 * @property {number} svc_VoiceInit=14 svc_VoiceInit value
 * @property {number} svc_VoiceData=15 svc_VoiceData value
 * @property {number} svc_Print=16 svc_Print value
 * @property {number} svc_Sounds=17 svc_Sounds value
 * @property {number} svc_SetView=18 svc_SetView value
 * @property {number} svc_FixAngle=19 svc_FixAngle value
 * @property {number} svc_CrosshairAngle=20 svc_CrosshairAngle value
 * @property {number} svc_BSPDecal=21 svc_BSPDecal value
 * @property {number} svc_SplitScreen=22 svc_SplitScreen value
 * @property {number} svc_UserMessage=23 svc_UserMessage value
 * @property {number} svc_EntityMessage=24 svc_EntityMessage value
 * @property {number} svc_GameEvent=25 svc_GameEvent value
 * @property {number} svc_PacketEntities=26 svc_PacketEntities value
 * @property {number} svc_TempEntities=27 svc_TempEntities value
 * @property {number} svc_Prefetch=28 svc_Prefetch value
 * @property {number} svc_Menu=29 svc_Menu value
 * @property {number} svc_GameEventList=30 svc_GameEventList value
 * @property {number} svc_GetCvarValue=31 svc_GetCvarValue value
 * @property {number} svc_PaintmapData=33 svc_PaintmapData value
 * @property {number} svc_CmdKeyValues=34 svc_CmdKeyValues value
 * @property {number} svc_EncryptedData=35 svc_EncryptedData value
 * @property {number} svc_HltvReplay=36 svc_HltvReplay value
 */
$root.SVC_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[8] = "svc_ServerInfo")] = 8;
    values[(valuesById[9] = "svc_SendTable")] = 9;
    values[(valuesById[10] = "svc_ClassInfo")] = 10;
    values[(valuesById[11] = "svc_SetPause")] = 11;
    values[(valuesById[12] = "svc_CreateStringTable")] = 12;
    values[(valuesById[13] = "svc_UpdateStringTable")] = 13;
    values[(valuesById[14] = "svc_VoiceInit")] = 14;
    values[(valuesById[15] = "svc_VoiceData")] = 15;
    values[(valuesById[16] = "svc_Print")] = 16;
    values[(valuesById[17] = "svc_Sounds")] = 17;
    values[(valuesById[18] = "svc_SetView")] = 18;
    values[(valuesById[19] = "svc_FixAngle")] = 19;
    values[(valuesById[20] = "svc_CrosshairAngle")] = 20;
    values[(valuesById[21] = "svc_BSPDecal")] = 21;
    values[(valuesById[22] = "svc_SplitScreen")] = 22;
    values[(valuesById[23] = "svc_UserMessage")] = 23;
    values[(valuesById[24] = "svc_EntityMessage")] = 24;
    values[(valuesById[25] = "svc_GameEvent")] = 25;
    values[(valuesById[26] = "svc_PacketEntities")] = 26;
    values[(valuesById[27] = "svc_TempEntities")] = 27;
    values[(valuesById[28] = "svc_Prefetch")] = 28;
    values[(valuesById[29] = "svc_Menu")] = 29;
    values[(valuesById[30] = "svc_GameEventList")] = 30;
    values[(valuesById[31] = "svc_GetCvarValue")] = 31;
    values[(valuesById[33] = "svc_PaintmapData")] = 33;
    values[(valuesById[34] = "svc_CmdKeyValues")] = 34;
    values[(valuesById[35] = "svc_EncryptedData")] = 35;
    values[(valuesById[36] = "svc_HltvReplay")] = 36;
    return values;
})();
/**
 * ReplayEventType_t enum.
 * @exports ReplayEventType_t
 * @enum {string}
 * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value
 * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value
 * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value
 */
$root.ReplayEventType_t = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[0] = "REPLAY_EVENT_CANCEL")] = 0;
    values[(valuesById[1] = "REPLAY_EVENT_DEATH")] = 1;
    values[(valuesById[2] = "REPLAY_EVENT_GENERIC")] = 2;
    return values;
})();
exports.CMsgVector = ($root.CMsgVector = (() => {
    /**
     * Properties of a CMsgVector.
     * @exports ICMsgVector
     * @interface ICMsgVector
     * @property {number|null} [x] CMsgVector x
     * @property {number|null} [y] CMsgVector y
     * @property {number|null} [z] CMsgVector z
     */
    /**
     * Constructs a new CMsgVector.
     * @exports CMsgVector
     * @classdesc Represents a CMsgVector.
     * @implements ICMsgVector
     * @constructor
     * @param {ICMsgVector=} [properties] Properties to set
     */
    function CMsgVector(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgVector x.
     * @member {number} x
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.x = 0;
    /**
     * CMsgVector y.
     * @member {number} y
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.y = 0;
    /**
     * CMsgVector z.
     * @member {number} z
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.z = 0;
    /**
     * Decodes a CMsgVector message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgVector
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgVector} CMsgVector
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgVector.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgVector;
})());
exports.CMsgVector2D = ($root.CMsgVector2D = (() => {
    /**
     * Properties of a CMsgVector2D.
     * @exports ICMsgVector2D
     * @interface ICMsgVector2D
     * @property {number|null} [x] CMsgVector2D x
     * @property {number|null} [y] CMsgVector2D y
     */
    /**
     * Constructs a new CMsgVector2D.
     * @exports CMsgVector2D
     * @classdesc Represents a CMsgVector2D.
     * @implements ICMsgVector2D
     * @constructor
     * @param {ICMsgVector2D=} [properties] Properties to set
     */
    function CMsgVector2D(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgVector2D x.
     * @member {number} x
     * @memberof CMsgVector2D
     * @instance
     */
    CMsgVector2D.prototype.x = 0;
    /**
     * CMsgVector2D y.
     * @member {number} y
     * @memberof CMsgVector2D
     * @instance
     */
    CMsgVector2D.prototype.y = 0;
    /**
     * Decodes a CMsgVector2D message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgVector2D
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgVector2D} CMsgVector2D
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgVector2D.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgVector2D;
})());
exports.CMsgQAngle = ($root.CMsgQAngle = (() => {
    /**
     * Properties of a CMsgQAngle.
     * @exports ICMsgQAngle
     * @interface ICMsgQAngle
     * @property {number|null} [x] CMsgQAngle x
     * @property {number|null} [y] CMsgQAngle y
     * @property {number|null} [z] CMsgQAngle z
     */
    /**
     * Constructs a new CMsgQAngle.
     * @exports CMsgQAngle
     * @classdesc Represents a CMsgQAngle.
     * @implements ICMsgQAngle
     * @constructor
     * @param {ICMsgQAngle=} [properties] Properties to set
     */
    function CMsgQAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgQAngle x.
     * @member {number} x
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.x = 0;
    /**
     * CMsgQAngle y.
     * @member {number} y
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.y = 0;
    /**
     * CMsgQAngle z.
     * @member {number} z
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.z = 0;
    /**
     * Decodes a CMsgQAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgQAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgQAngle} CMsgQAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgQAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgQAngle;
})());
exports.CMsgRGBA = ($root.CMsgRGBA = (() => {
    /**
     * Properties of a CMsgRGBA.
     * @exports ICMsgRGBA
     * @interface ICMsgRGBA
     * @property {number|null} [r] CMsgRGBA r
     * @property {number|null} [g] CMsgRGBA g
     * @property {number|null} [b] CMsgRGBA b
     * @property {number|null} [a] CMsgRGBA a
     */
    /**
     * Constructs a new CMsgRGBA.
     * @exports CMsgRGBA
     * @classdesc Represents a CMsgRGBA.
     * @implements ICMsgRGBA
     * @constructor
     * @param {ICMsgRGBA=} [properties] Properties to set
     */
    function CMsgRGBA(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgRGBA r.
     * @member {number} r
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.r = 0;
    /**
     * CMsgRGBA g.
     * @member {number} g
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.g = 0;
    /**
     * CMsgRGBA b.
     * @member {number} b
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.b = 0;
    /**
     * CMsgRGBA a.
     * @member {number} a
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.a = 0;
    /**
     * Decodes a CMsgRGBA message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgRGBA
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgRGBA} CMsgRGBA
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgRGBA.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgRGBA;
})());
exports.CNETMsg_Tick = ($root.CNETMsg_Tick = (() => {
    /**
     * Properties of a CNETMsg_Tick.
     * @exports ICNETMsg_Tick
     * @interface ICNETMsg_Tick
     * @property {number|null} [tick] CNETMsg_Tick tick
     * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime
     * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation
     * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation
     * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags
     */
    /**
     * Constructs a new CNETMsg_Tick.
     * @exports CNETMsg_Tick
     * @classdesc Represents a CNETMsg_Tick.
     * @implements ICNETMsg_Tick
     * @constructor
     * @param {ICNETMsg_Tick=} [properties] Properties to set
     */
    function CNETMsg_Tick(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_Tick tick.
     * @member {number} tick
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.tick = 0;
    /**
     * CNETMsg_Tick hostComputationtime.
     * @member {number} hostComputationtime
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostComputationtime = 0;
    /**
     * CNETMsg_Tick hostComputationtimeStdDeviation.
     * @member {number} hostComputationtimeStdDeviation
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;
    /**
     * CNETMsg_Tick hostFramestarttimeStdDeviation.
     * @member {number} hostFramestarttimeStdDeviation
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;
    /**
     * CNETMsg_Tick hltvReplayFlags.
     * @member {number} hltvReplayFlags
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hltvReplayFlags = 0;
    /**
     * Decodes a CNETMsg_Tick message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_Tick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_Tick} CNETMsg_Tick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_Tick.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 4:
                    message.hostComputationtime = reader.uint32();
                    break;
                case 5:
                    message.hostComputationtimeStdDeviation = reader.uint32();
                    break;
                case 6:
                    message.hostFramestarttimeStdDeviation = reader.uint32();
                    break;
                case 7:
                    message.hltvReplayFlags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_Tick;
})());
exports.CNETMsg_StringCmd = ($root.CNETMsg_StringCmd = (() => {
    /**
     * Properties of a CNETMsg_StringCmd.
     * @exports ICNETMsg_StringCmd
     * @interface ICNETMsg_StringCmd
     * @property {string|null} [command] CNETMsg_StringCmd command
     */
    /**
     * Constructs a new CNETMsg_StringCmd.
     * @exports CNETMsg_StringCmd
     * @classdesc Represents a CNETMsg_StringCmd.
     * @implements ICNETMsg_StringCmd
     * @constructor
     * @param {ICNETMsg_StringCmd=} [properties] Properties to set
     */
    function CNETMsg_StringCmd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_StringCmd command.
     * @member {string} command
     * @memberof CNETMsg_StringCmd
     * @instance
     */
    CNETMsg_StringCmd.prototype.command = "";
    /**
     * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_StringCmd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_StringCmd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_StringCmd;
})());
exports.CNETMsg_SignonState = ($root.CNETMsg_SignonState = (() => {
    /**
     * Properties of a CNETMsg_SignonState.
     * @exports ICNETMsg_SignonState
     * @interface ICNETMsg_SignonState
     * @property {number|null} [signonState] CNETMsg_SignonState signonState
     * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount
     * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers
     * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids
     * @property {string|null} [mapName] CNETMsg_SignonState mapName
     */
    /**
     * Constructs a new CNETMsg_SignonState.
     * @exports CNETMsg_SignonState
     * @classdesc Represents a CNETMsg_SignonState.
     * @implements ICNETMsg_SignonState
     * @constructor
     * @param {ICNETMsg_SignonState=} [properties] Properties to set
     */
    function CNETMsg_SignonState(properties) {
        this.playersNetworkids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SignonState signonState.
     * @member {number} signonState
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.signonState = 0;
    /**
     * CNETMsg_SignonState spawnCount.
     * @member {number} spawnCount
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.spawnCount = 0;
    /**
     * CNETMsg_SignonState numServerPlayers.
     * @member {number} numServerPlayers
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.numServerPlayers = 0;
    /**
     * CNETMsg_SignonState playersNetworkids.
     * @member {Array.<string>} playersNetworkids
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;
    /**
     * CNETMsg_SignonState mapName.
     * @member {string} mapName
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.mapName = "";
    /**
     * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SignonState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SignonState} CNETMsg_SignonState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SignonState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signonState = reader.uint32();
                    break;
                case 2:
                    message.spawnCount = reader.uint32();
                    break;
                case 3:
                    message.numServerPlayers = reader.uint32();
                    break;
                case 4:
                    if (!(message.playersNetworkids && message.playersNetworkids.length))
                        message.playersNetworkids = [];
                    message.playersNetworkids.push(reader.string());
                    break;
                case 5:
                    message.mapName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SignonState;
})());
exports.CMsg_CVars = ($root.CMsg_CVars = (() => {
    /**
     * Properties of a CMsg_CVars.
     * @exports ICMsg_CVars
     * @interface ICMsg_CVars
     * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
     */
    /**
     * Constructs a new CMsg_CVars.
     * @exports CMsg_CVars
     * @classdesc Represents a CMsg_CVars.
     * @implements ICMsg_CVars
     * @constructor
     * @param {ICMsg_CVars=} [properties] Properties to set
     */
    function CMsg_CVars(properties) {
        this.cvars = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsg_CVars cvars.
     * @member {Array.<CMsg_CVars.ICVar>} cvars
     * @memberof CMsg_CVars
     * @instance
     */
    CMsg_CVars.prototype.cvars = $util.emptyArray;
    /**
     * Decodes a CMsg_CVars message from the specified reader or buffer.
     * @function decode
     * @memberof CMsg_CVars
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsg_CVars} CMsg_CVars
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsg_CVars.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsg_CVars.CVar = (function () {
        /**
         * Properties of a CVar.
         * @memberof CMsg_CVars
         * @interface ICVar
         * @property {string|null} [name] CVar name
         * @property {string|null} [value] CVar value
         * @property {number|null} [dictionaryName] CVar dictionaryName
         */
        /**
         * Constructs a new CVar.
         * @memberof CMsg_CVars
         * @classdesc Represents a CVar.
         * @implements ICVar
         * @constructor
         * @param {CMsg_CVars.ICVar=} [properties] Properties to set
         */
        function CVar(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CVar name.
         * @member {string} name
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.name = "";
        /**
         * CVar value.
         * @member {string} value
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.value = "";
        /**
         * CVar dictionaryName.
         * @member {number} dictionaryName
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.dictionaryName = 0;
        /**
         * Decodes a CVar message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars.CVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars.CVar} CVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    case 3:
                        message.dictionaryName = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return CVar;
    })();
    return CMsg_CVars;
})());
exports.CNETMsg_SetConVar = ($root.CNETMsg_SetConVar = (() => {
    /**
     * Properties of a CNETMsg_SetConVar.
     * @exports ICNETMsg_SetConVar
     * @interface ICNETMsg_SetConVar
     * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
     */
    /**
     * Constructs a new CNETMsg_SetConVar.
     * @exports CNETMsg_SetConVar
     * @classdesc Represents a CNETMsg_SetConVar.
     * @implements ICNETMsg_SetConVar
     * @constructor
     * @param {ICNETMsg_SetConVar=} [properties] Properties to set
     */
    function CNETMsg_SetConVar(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SetConVar convars.
     * @member {ICMsg_CVars|null|undefined} convars
     * @memberof CNETMsg_SetConVar
     * @instance
     */
    CNETMsg_SetConVar.prototype.convars = null;
    /**
     * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SetConVar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SetConVar.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SetConVar;
})());
exports.CNETMsg_NOP = ($root.CNETMsg_NOP = (() => {
    /**
     * Properties of a CNETMsg_NOP.
     * @exports ICNETMsg_NOP
     * @interface ICNETMsg_NOP
     */
    /**
     * Constructs a new CNETMsg_NOP.
     * @exports CNETMsg_NOP
     * @classdesc Represents a CNETMsg_NOP.
     * @implements ICNETMsg_NOP
     * @constructor
     * @param {ICNETMsg_NOP=} [properties] Properties to set
     */
    function CNETMsg_NOP(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CNETMsg_NOP message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_NOP
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_NOP} CNETMsg_NOP
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_NOP.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_NOP;
})());
exports.CNETMsg_Disconnect = ($root.CNETMsg_Disconnect = (() => {
    /**
     * Properties of a CNETMsg_Disconnect.
     * @exports ICNETMsg_Disconnect
     * @interface ICNETMsg_Disconnect
     * @property {string|null} [text] CNETMsg_Disconnect text
     */
    /**
     * Constructs a new CNETMsg_Disconnect.
     * @exports CNETMsg_Disconnect
     * @classdesc Represents a CNETMsg_Disconnect.
     * @implements ICNETMsg_Disconnect
     * @constructor
     * @param {ICNETMsg_Disconnect=} [properties] Properties to set
     */
    function CNETMsg_Disconnect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_Disconnect text.
     * @member {string} text
     * @memberof CNETMsg_Disconnect
     * @instance
     */
    CNETMsg_Disconnect.prototype.text = "";
    /**
     * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_Disconnect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_Disconnect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_Disconnect;
})());
exports.CNETMsg_File = ($root.CNETMsg_File = (() => {
    /**
     * Properties of a CNETMsg_File.
     * @exports ICNETMsg_File
     * @interface ICNETMsg_File
     * @property {number|null} [transferId] CNETMsg_File transferId
     * @property {string|null} [fileName] CNETMsg_File fileName
     * @property {boolean|null} [isReplayDemoFile] CNETMsg_File isReplayDemoFile
     * @property {boolean|null} [deny] CNETMsg_File deny
     */
    /**
     * Constructs a new CNETMsg_File.
     * @exports CNETMsg_File
     * @classdesc Represents a CNETMsg_File.
     * @implements ICNETMsg_File
     * @constructor
     * @param {ICNETMsg_File=} [properties] Properties to set
     */
    function CNETMsg_File(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_File transferId.
     * @member {number} transferId
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.transferId = 0;
    /**
     * CNETMsg_File fileName.
     * @member {string} fileName
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.fileName = "";
    /**
     * CNETMsg_File isReplayDemoFile.
     * @member {boolean} isReplayDemoFile
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.isReplayDemoFile = false;
    /**
     * CNETMsg_File deny.
     * @member {boolean} deny
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.deny = false;
    /**
     * Decodes a CNETMsg_File message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_File
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_File} CNETMsg_File
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_File.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_File();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transferId = reader.int32();
                    break;
                case 2:
                    message.fileName = reader.string();
                    break;
                case 3:
                    message.isReplayDemoFile = reader.bool();
                    break;
                case 4:
                    message.deny = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_File;
})());
exports.CNETMsg_SplitScreenUser = ($root.CNETMsg_SplitScreenUser = (() => {
    /**
     * Properties of a CNETMsg_SplitScreenUser.
     * @exports ICNETMsg_SplitScreenUser
     * @interface ICNETMsg_SplitScreenUser
     * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
     */
    /**
     * Constructs a new CNETMsg_SplitScreenUser.
     * @exports CNETMsg_SplitScreenUser
     * @classdesc Represents a CNETMsg_SplitScreenUser.
     * @implements ICNETMsg_SplitScreenUser
     * @constructor
     * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
     */
    function CNETMsg_SplitScreenUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SplitScreenUser slot.
     * @member {number} slot
     * @memberof CNETMsg_SplitScreenUser
     * @instance
     */
    CNETMsg_SplitScreenUser.prototype.slot = 0;
    /**
     * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SplitScreenUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SplitScreenUser;
})());
exports.CNETMsg_PlayerAvatarData = ($root.CNETMsg_PlayerAvatarData = (() => {
    /**
     * Properties of a CNETMsg_PlayerAvatarData.
     * @exports ICNETMsg_PlayerAvatarData
     * @interface ICNETMsg_PlayerAvatarData
     * @property {number|null} [accountid] CNETMsg_PlayerAvatarData accountid
     * @property {Uint8Array|null} [rgb] CNETMsg_PlayerAvatarData rgb
     */
    /**
     * Constructs a new CNETMsg_PlayerAvatarData.
     * @exports CNETMsg_PlayerAvatarData
     * @classdesc Represents a CNETMsg_PlayerAvatarData.
     * @implements ICNETMsg_PlayerAvatarData
     * @constructor
     * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set
     */
    function CNETMsg_PlayerAvatarData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_PlayerAvatarData accountid.
     * @member {number} accountid
     * @memberof CNETMsg_PlayerAvatarData
     * @instance
     */
    CNETMsg_PlayerAvatarData.prototype.accountid = 0;
    /**
     * CNETMsg_PlayerAvatarData rgb.
     * @member {Uint8Array} rgb
     * @memberof CNETMsg_PlayerAvatarData
     * @instance
     */
    CNETMsg_PlayerAvatarData.prototype.rgb = $util.newBuffer([]);
    /**
     * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_PlayerAvatarData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_PlayerAvatarData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_PlayerAvatarData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.rgb = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_PlayerAvatarData;
})());
exports.CCLCMsg_ClientInfo = ($root.CCLCMsg_ClientInfo = (() => {
    /**
     * Properties of a CCLCMsg_ClientInfo.
     * @exports ICCLCMsg_ClientInfo
     * @interface ICCLCMsg_ClientInfo
     * @property {number|null} [sendTableCrc] CCLCMsg_ClientInfo sendTableCrc
     * @property {number|null} [serverCount] CCLCMsg_ClientInfo serverCount
     * @property {boolean|null} [isHltv] CCLCMsg_ClientInfo isHltv
     * @property {boolean|null} [isReplay] CCLCMsg_ClientInfo isReplay
     * @property {number|null} [friendsId] CCLCMsg_ClientInfo friendsId
     * @property {string|null} [friendsName] CCLCMsg_ClientInfo friendsName
     * @property {Array.<number>|null} [customFiles] CCLCMsg_ClientInfo customFiles
     */
    /**
     * Constructs a new CCLCMsg_ClientInfo.
     * @exports CCLCMsg_ClientInfo
     * @classdesc Represents a CCLCMsg_ClientInfo.
     * @implements ICCLCMsg_ClientInfo
     * @constructor
     * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
     */
    function CCLCMsg_ClientInfo(properties) {
        this.customFiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_ClientInfo sendTableCrc.
     * @member {number} sendTableCrc
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.sendTableCrc = 0;
    /**
     * CCLCMsg_ClientInfo serverCount.
     * @member {number} serverCount
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.serverCount = 0;
    /**
     * CCLCMsg_ClientInfo isHltv.
     * @member {boolean} isHltv
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.isHltv = false;
    /**
     * CCLCMsg_ClientInfo isReplay.
     * @member {boolean} isReplay
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.isReplay = false;
    /**
     * CCLCMsg_ClientInfo friendsId.
     * @member {number} friendsId
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.friendsId = 0;
    /**
     * CCLCMsg_ClientInfo friendsName.
     * @member {string} friendsName
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.friendsName = "";
    /**
     * CCLCMsg_ClientInfo customFiles.
     * @member {Array.<number>} customFiles
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.customFiles = $util.emptyArray;
    /**
     * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_ClientInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_ClientInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sendTableCrc = reader.fixed32();
                    break;
                case 2:
                    message.serverCount = reader.uint32();
                    break;
                case 3:
                    message.isHltv = reader.bool();
                    break;
                case 4:
                    message.isReplay = reader.bool();
                    break;
                case 5:
                    message.friendsId = reader.uint32();
                    break;
                case 6:
                    message.friendsName = reader.string();
                    break;
                case 7:
                    if (!(message.customFiles && message.customFiles.length))
                        message.customFiles = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.customFiles.push(reader.fixed32());
                    }
                    else
                        message.customFiles.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_ClientInfo;
})());
exports.CCLCMsg_Move = ($root.CCLCMsg_Move = (() => {
    /**
     * Properties of a CCLCMsg_Move.
     * @exports ICCLCMsg_Move
     * @interface ICCLCMsg_Move
     * @property {number|null} [numBackupCommands] CCLCMsg_Move numBackupCommands
     * @property {number|null} [numNewCommands] CCLCMsg_Move numNewCommands
     * @property {Uint8Array|null} [data] CCLCMsg_Move data
     */
    /**
     * Constructs a new CCLCMsg_Move.
     * @exports CCLCMsg_Move
     * @classdesc Represents a CCLCMsg_Move.
     * @implements ICCLCMsg_Move
     * @constructor
     * @param {ICCLCMsg_Move=} [properties] Properties to set
     */
    function CCLCMsg_Move(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_Move numBackupCommands.
     * @member {number} numBackupCommands
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.numBackupCommands = 0;
    /**
     * CCLCMsg_Move numNewCommands.
     * @member {number} numNewCommands
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.numNewCommands = 0;
    /**
     * CCLCMsg_Move data.
     * @member {Uint8Array} data
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.data = $util.newBuffer([]);
    /**
     * Decodes a CCLCMsg_Move message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_Move
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_Move} CCLCMsg_Move
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_Move.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numBackupCommands = reader.uint32();
                    break;
                case 2:
                    message.numNewCommands = reader.uint32();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_Move;
})());
exports.CCLCMsg_VoiceData = ($root.CCLCMsg_VoiceData = (() => {
    /**
     * Properties of a CCLCMsg_VoiceData.
     * @exports ICCLCMsg_VoiceData
     * @interface ICCLCMsg_VoiceData
     * @property {Uint8Array|null} [data] CCLCMsg_VoiceData data
     * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid
     * @property {VoiceDataFormat_t|null} [format] CCLCMsg_VoiceData format
     * @property {number|null} [sequenceBytes] CCLCMsg_VoiceData sequenceBytes
     * @property {number|null} [sectionNumber] CCLCMsg_VoiceData sectionNumber
     * @property {number|null} [uncompressedSampleOffset] CCLCMsg_VoiceData uncompressedSampleOffset
     */
    /**
     * Constructs a new CCLCMsg_VoiceData.
     * @exports CCLCMsg_VoiceData
     * @classdesc Represents a CCLCMsg_VoiceData.
     * @implements ICCLCMsg_VoiceData
     * @constructor
     * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
     */
    function CCLCMsg_VoiceData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_VoiceData data.
     * @member {Uint8Array} data
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.data = $util.newBuffer([]);
    /**
     * CCLCMsg_VoiceData xuid.
     * @member {number|Long} xuid
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.xuid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CCLCMsg_VoiceData format.
     * @member {VoiceDataFormat_t} format
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.format = 1;
    /**
     * CCLCMsg_VoiceData sequenceBytes.
     * @member {number} sequenceBytes
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.sequenceBytes = 0;
    /**
     * CCLCMsg_VoiceData sectionNumber.
     * @member {number} sectionNumber
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.sectionNumber = 0;
    /**
     * CCLCMsg_VoiceData uncompressedSampleOffset.
     * @member {number} uncompressedSampleOffset
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;
    /**
     * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_VoiceData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_VoiceData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.format = reader.int32();
                    break;
                case 4:
                    message.sequenceBytes = reader.int32();
                    break;
                case 5:
                    message.sectionNumber = reader.uint32();
                    break;
                case 6:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_VoiceData;
})());
exports.CCLCMsg_BaselineAck = ($root.CCLCMsg_BaselineAck = (() => {
    /**
     * Properties of a CCLCMsg_BaselineAck.
     * @exports ICCLCMsg_BaselineAck
     * @interface ICCLCMsg_BaselineAck
     * @property {number|null} [baselineTick] CCLCMsg_BaselineAck baselineTick
     * @property {number|null} [baselineNr] CCLCMsg_BaselineAck baselineNr
     */
    /**
     * Constructs a new CCLCMsg_BaselineAck.
     * @exports CCLCMsg_BaselineAck
     * @classdesc Represents a CCLCMsg_BaselineAck.
     * @implements ICCLCMsg_BaselineAck
     * @constructor
     * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
     */
    function CCLCMsg_BaselineAck(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_BaselineAck baselineTick.
     * @member {number} baselineTick
     * @memberof CCLCMsg_BaselineAck
     * @instance
     */
    CCLCMsg_BaselineAck.prototype.baselineTick = 0;
    /**
     * CCLCMsg_BaselineAck baselineNr.
     * @member {number} baselineNr
     * @memberof CCLCMsg_BaselineAck
     * @instance
     */
    CCLCMsg_BaselineAck.prototype.baselineNr = 0;
    /**
     * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_BaselineAck
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_BaselineAck.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.baselineTick = reader.int32();
                    break;
                case 2:
                    message.baselineNr = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_BaselineAck;
})());
exports.CCLCMsg_ListenEvents = ($root.CCLCMsg_ListenEvents = (() => {
    /**
     * Properties of a CCLCMsg_ListenEvents.
     * @exports ICCLCMsg_ListenEvents
     * @interface ICCLCMsg_ListenEvents
     * @property {Array.<number>|null} [eventMask] CCLCMsg_ListenEvents eventMask
     */
    /**
     * Constructs a new CCLCMsg_ListenEvents.
     * @exports CCLCMsg_ListenEvents
     * @classdesc Represents a CCLCMsg_ListenEvents.
     * @implements ICCLCMsg_ListenEvents
     * @constructor
     * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
     */
    function CCLCMsg_ListenEvents(properties) {
        this.eventMask = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_ListenEvents eventMask.
     * @member {Array.<number>} eventMask
     * @memberof CCLCMsg_ListenEvents
     * @instance
     */
    CCLCMsg_ListenEvents.prototype.eventMask = $util.emptyArray;
    /**
     * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_ListenEvents
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_ListenEvents.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.eventMask && message.eventMask.length))
                        message.eventMask = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.eventMask.push(reader.fixed32());
                    }
                    else
                        message.eventMask.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_ListenEvents;
})());
exports.CCLCMsg_RespondCvarValue = ($root.CCLCMsg_RespondCvarValue = (() => {
    /**
     * Properties of a CCLCMsg_RespondCvarValue.
     * @exports ICCLCMsg_RespondCvarValue
     * @interface ICCLCMsg_RespondCvarValue
     * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie
     * @property {number|null} [statusCode] CCLCMsg_RespondCvarValue statusCode
     * @property {string|null} [name] CCLCMsg_RespondCvarValue name
     * @property {string|null} [value] CCLCMsg_RespondCvarValue value
     */
    /**
     * Constructs a new CCLCMsg_RespondCvarValue.
     * @exports CCLCMsg_RespondCvarValue
     * @classdesc Represents a CCLCMsg_RespondCvarValue.
     * @implements ICCLCMsg_RespondCvarValue
     * @constructor
     * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
     */
    function CCLCMsg_RespondCvarValue(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_RespondCvarValue cookie.
     * @member {number} cookie
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.cookie = 0;
    /**
     * CCLCMsg_RespondCvarValue statusCode.
     * @member {number} statusCode
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.statusCode = 0;
    /**
     * CCLCMsg_RespondCvarValue name.
     * @member {string} name
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.name = "";
    /**
     * CCLCMsg_RespondCvarValue value.
     * @member {string} value
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.value = "";
    /**
     * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_RespondCvarValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.statusCode = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_RespondCvarValue;
})());
exports.CCLCMsg_FileCRCCheck = ($root.CCLCMsg_FileCRCCheck = (() => {
    /**
     * Properties of a CCLCMsg_FileCRCCheck.
     * @exports ICCLCMsg_FileCRCCheck
     * @interface ICCLCMsg_FileCRCCheck
     * @property {number|null} [codePath] CCLCMsg_FileCRCCheck codePath
     * @property {string|null} [path] CCLCMsg_FileCRCCheck path
     * @property {number|null} [codeFilename] CCLCMsg_FileCRCCheck codeFilename
     * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename
     * @property {number|null} [fileFraction] CCLCMsg_FileCRCCheck fileFraction
     * @property {Uint8Array|null} [md5] CCLCMsg_FileCRCCheck md5
     * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc
     * @property {number|null} [fileHashType] CCLCMsg_FileCRCCheck fileHashType
     * @property {number|null} [fileLen] CCLCMsg_FileCRCCheck fileLen
     * @property {number|null} [packFileId] CCLCMsg_FileCRCCheck packFileId
     * @property {number|null} [packFileNumber] CCLCMsg_FileCRCCheck packFileNumber
     */
    /**
     * Constructs a new CCLCMsg_FileCRCCheck.
     * @exports CCLCMsg_FileCRCCheck
     * @classdesc Represents a CCLCMsg_FileCRCCheck.
     * @implements ICCLCMsg_FileCRCCheck
     * @constructor
     * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
     */
    function CCLCMsg_FileCRCCheck(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_FileCRCCheck codePath.
     * @member {number} codePath
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.codePath = 0;
    /**
     * CCLCMsg_FileCRCCheck path.
     * @member {string} path
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.path = "";
    /**
     * CCLCMsg_FileCRCCheck codeFilename.
     * @member {number} codeFilename
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.codeFilename = 0;
    /**
     * CCLCMsg_FileCRCCheck filename.
     * @member {string} filename
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.filename = "";
    /**
     * CCLCMsg_FileCRCCheck fileFraction.
     * @member {number} fileFraction
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileFraction = 0;
    /**
     * CCLCMsg_FileCRCCheck md5.
     * @member {Uint8Array} md5
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.md5 = $util.newBuffer([]);
    /**
     * CCLCMsg_FileCRCCheck crc.
     * @member {number} crc
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.crc = 0;
    /**
     * CCLCMsg_FileCRCCheck fileHashType.
     * @member {number} fileHashType
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileHashType = 0;
    /**
     * CCLCMsg_FileCRCCheck fileLen.
     * @member {number} fileLen
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileLen = 0;
    /**
     * CCLCMsg_FileCRCCheck packFileId.
     * @member {number} packFileId
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.packFileId = 0;
    /**
     * CCLCMsg_FileCRCCheck packFileNumber.
     * @member {number} packFileNumber
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.packFileNumber = 0;
    /**
     * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_FileCRCCheck
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.codePath = reader.int32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.codeFilename = reader.int32();
                    break;
                case 4:
                    message.filename = reader.string();
                    break;
                case 5:
                    message.fileFraction = reader.int32();
                    break;
                case 6:
                    message.md5 = reader.bytes();
                    break;
                case 7:
                    message.crc = reader.uint32();
                    break;
                case 8:
                    message.fileHashType = reader.int32();
                    break;
                case 9:
                    message.fileLen = reader.int32();
                    break;
                case 10:
                    message.packFileId = reader.int32();
                    break;
                case 11:
                    message.packFileNumber = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_FileCRCCheck;
})());
exports.CCLCMsg_LoadingProgress = ($root.CCLCMsg_LoadingProgress = (() => {
    /**
     * Properties of a CCLCMsg_LoadingProgress.
     * @exports ICCLCMsg_LoadingProgress
     * @interface ICCLCMsg_LoadingProgress
     * @property {number|null} [progress] CCLCMsg_LoadingProgress progress
     */
    /**
     * Constructs a new CCLCMsg_LoadingProgress.
     * @exports CCLCMsg_LoadingProgress
     * @classdesc Represents a CCLCMsg_LoadingProgress.
     * @implements ICCLCMsg_LoadingProgress
     * @constructor
     * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
     */
    function CCLCMsg_LoadingProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_LoadingProgress progress.
     * @member {number} progress
     * @memberof CCLCMsg_LoadingProgress
     * @instance
     */
    CCLCMsg_LoadingProgress.prototype.progress = 0;
    /**
     * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_LoadingProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_LoadingProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.progress = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_LoadingProgress;
})());
exports.CCLCMsg_SplitPlayerConnect = ($root.CCLCMsg_SplitPlayerConnect = (() => {
    /**
     * Properties of a CCLCMsg_SplitPlayerConnect.
     * @exports ICCLCMsg_SplitPlayerConnect
     * @interface ICCLCMsg_SplitPlayerConnect
     * @property {ICMsg_CVars|null} [convars] CCLCMsg_SplitPlayerConnect convars
     */
    /**
     * Constructs a new CCLCMsg_SplitPlayerConnect.
     * @exports CCLCMsg_SplitPlayerConnect
     * @classdesc Represents a CCLCMsg_SplitPlayerConnect.
     * @implements ICCLCMsg_SplitPlayerConnect
     * @constructor
     * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
     */
    function CCLCMsg_SplitPlayerConnect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_SplitPlayerConnect convars.
     * @member {ICMsg_CVars|null|undefined} convars
     * @memberof CCLCMsg_SplitPlayerConnect
     * @instance
     */
    CCLCMsg_SplitPlayerConnect.prototype.convars = null;
    /**
     * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_SplitPlayerConnect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_SplitPlayerConnect;
})());
exports.CCLCMsg_CmdKeyValues = ($root.CCLCMsg_CmdKeyValues = (() => {
    /**
     * Properties of a CCLCMsg_CmdKeyValues.
     * @exports ICCLCMsg_CmdKeyValues
     * @interface ICCLCMsg_CmdKeyValues
     * @property {Uint8Array|null} [keyvalues] CCLCMsg_CmdKeyValues keyvalues
     */
    /**
     * Constructs a new CCLCMsg_CmdKeyValues.
     * @exports CCLCMsg_CmdKeyValues
     * @classdesc Represents a CCLCMsg_CmdKeyValues.
     * @implements ICCLCMsg_CmdKeyValues
     * @constructor
     * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
     */
    function CCLCMsg_CmdKeyValues(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_CmdKeyValues keyvalues.
     * @member {Uint8Array} keyvalues
     * @memberof CCLCMsg_CmdKeyValues
     * @instance
     */
    CCLCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    /**
     * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_CmdKeyValues
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_CmdKeyValues;
})());
exports.CSVCMsg_ServerInfo = ($root.CSVCMsg_ServerInfo = (() => {
    /**
     * Properties of a CSVCMsg_ServerInfo.
     * @exports ICSVCMsg_ServerInfo
     * @interface ICSVCMsg_ServerInfo
     * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol
     * @property {number|null} [serverCount] CSVCMsg_ServerInfo serverCount
     * @property {boolean|null} [isDedicated] CSVCMsg_ServerInfo isDedicated
     * @property {boolean|null} [isOfficialValveServer] CSVCMsg_ServerInfo isOfficialValveServer
     * @property {boolean|null} [isHltv] CSVCMsg_ServerInfo isHltv
     * @property {boolean|null} [isReplay] CSVCMsg_ServerInfo isReplay
     * @property {boolean|null} [isRedirectingToProxyRelay] CSVCMsg_ServerInfo isRedirectingToProxyRelay
     * @property {number|null} [cOs] CSVCMsg_ServerInfo cOs
     * @property {number|null} [mapCrc] CSVCMsg_ServerInfo mapCrc
     * @property {number|null} [clientCrc] CSVCMsg_ServerInfo clientCrc
     * @property {number|null} [stringTableCrc] CSVCMsg_ServerInfo stringTableCrc
     * @property {number|null} [maxClients] CSVCMsg_ServerInfo maxClients
     * @property {number|null} [maxClasses] CSVCMsg_ServerInfo maxClasses
     * @property {number|null} [playerSlot] CSVCMsg_ServerInfo playerSlot
     * @property {number|null} [tickInterval] CSVCMsg_ServerInfo tickInterval
     * @property {string|null} [gameDir] CSVCMsg_ServerInfo gameDir
     * @property {string|null} [mapName] CSVCMsg_ServerInfo mapName
     * @property {string|null} [mapGroupName] CSVCMsg_ServerInfo mapGroupName
     * @property {string|null} [skyName] CSVCMsg_ServerInfo skyName
     * @property {string|null} [hostName] CSVCMsg_ServerInfo hostName
     * @property {number|null} [publicIp] CSVCMsg_ServerInfo publicIp
     * @property {number|Long|null} [ugcMapId] CSVCMsg_ServerInfo ugcMapId
     */
    /**
     * Constructs a new CSVCMsg_ServerInfo.
     * @exports CSVCMsg_ServerInfo
     * @classdesc Represents a CSVCMsg_ServerInfo.
     * @implements ICSVCMsg_ServerInfo
     * @constructor
     * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
     */
    function CSVCMsg_ServerInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_ServerInfo protocol.
     * @member {number} protocol
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.protocol = 0;
    /**
     * CSVCMsg_ServerInfo serverCount.
     * @member {number} serverCount
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.serverCount = 0;
    /**
     * CSVCMsg_ServerInfo isDedicated.
     * @member {boolean} isDedicated
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isDedicated = false;
    /**
     * CSVCMsg_ServerInfo isOfficialValveServer.
     * @member {boolean} isOfficialValveServer
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isOfficialValveServer = false;
    /**
     * CSVCMsg_ServerInfo isHltv.
     * @member {boolean} isHltv
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isHltv = false;
    /**
     * CSVCMsg_ServerInfo isReplay.
     * @member {boolean} isReplay
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isReplay = false;
    /**
     * CSVCMsg_ServerInfo isRedirectingToProxyRelay.
     * @member {boolean} isRedirectingToProxyRelay
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isRedirectingToProxyRelay = false;
    /**
     * CSVCMsg_ServerInfo cOs.
     * @member {number} cOs
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.cOs = 0;
    /**
     * CSVCMsg_ServerInfo mapCrc.
     * @member {number} mapCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapCrc = 0;
    /**
     * CSVCMsg_ServerInfo clientCrc.
     * @member {number} clientCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.clientCrc = 0;
    /**
     * CSVCMsg_ServerInfo stringTableCrc.
     * @member {number} stringTableCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.stringTableCrc = 0;
    /**
     * CSVCMsg_ServerInfo maxClients.
     * @member {number} maxClients
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.maxClients = 0;
    /**
     * CSVCMsg_ServerInfo maxClasses.
     * @member {number} maxClasses
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.maxClasses = 0;
    /**
     * CSVCMsg_ServerInfo playerSlot.
     * @member {number} playerSlot
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.playerSlot = 0;
    /**
     * CSVCMsg_ServerInfo tickInterval.
     * @member {number} tickInterval
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.tickInterval = 0;
    /**
     * CSVCMsg_ServerInfo gameDir.
     * @member {string} gameDir
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.gameDir = "";
    /**
     * CSVCMsg_ServerInfo mapName.
     * @member {string} mapName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapName = "";
    /**
     * CSVCMsg_ServerInfo mapGroupName.
     * @member {string} mapGroupName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapGroupName = "";
    /**
     * CSVCMsg_ServerInfo skyName.
     * @member {string} skyName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.skyName = "";
    /**
     * CSVCMsg_ServerInfo hostName.
     * @member {string} hostName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.hostName = "";
    /**
     * CSVCMsg_ServerInfo publicIp.
     * @member {number} publicIp
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.publicIp = 0;
    /**
     * CSVCMsg_ServerInfo ugcMapId.
     * @member {number|Long} ugcMapId
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.ugcMapId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_ServerInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_ServerInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.serverCount = reader.int32();
                    break;
                case 3:
                    message.isDedicated = reader.bool();
                    break;
                case 4:
                    message.isOfficialValveServer = reader.bool();
                    break;
                case 5:
                    message.isHltv = reader.bool();
                    break;
                case 6:
                    message.isReplay = reader.bool();
                    break;
                case 21:
                    message.isRedirectingToProxyRelay = reader.bool();
                    break;
                case 7:
                    message.cOs = reader.int32();
                    break;
                case 8:
                    message.mapCrc = reader.fixed32();
                    break;
                case 9:
                    message.clientCrc = reader.fixed32();
                    break;
                case 10:
                    message.stringTableCrc = reader.fixed32();
                    break;
                case 11:
                    message.maxClients = reader.int32();
                    break;
                case 12:
                    message.maxClasses = reader.int32();
                    break;
                case 13:
                    message.playerSlot = reader.int32();
                    break;
                case 14:
                    message.tickInterval = reader.float();
                    break;
                case 15:
                    message.gameDir = reader.string();
                    break;
                case 16:
                    message.mapName = reader.string();
                    break;
                case 17:
                    message.mapGroupName = reader.string();
                    break;
                case 18:
                    message.skyName = reader.string();
                    break;
                case 19:
                    message.hostName = reader.string();
                    break;
                case 20:
                    message.publicIp = reader.uint32();
                    break;
                case 22:
                    message.ugcMapId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_ServerInfo;
})());
exports.CSVCMsg_ClassInfo = ($root.CSVCMsg_ClassInfo = (() => {
    /**
     * Properties of a CSVCMsg_ClassInfo.
     * @exports ICSVCMsg_ClassInfo
     * @interface ICSVCMsg_ClassInfo
     * @property {boolean|null} [createOnClient] CSVCMsg_ClassInfo createOnClient
     * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes
     */
    /**
     * Constructs a new CSVCMsg_ClassInfo.
     * @exports CSVCMsg_ClassInfo
     * @classdesc Represents a CSVCMsg_ClassInfo.
     * @implements ICSVCMsg_ClassInfo
     * @constructor
     * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
     */
    function CSVCMsg_ClassInfo(properties) {
        this.classes = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_ClassInfo createOnClient.
     * @member {boolean} createOnClient
     * @memberof CSVCMsg_ClassInfo
     * @instance
     */
    CSVCMsg_ClassInfo.prototype.createOnClient = false;
    /**
     * CSVCMsg_ClassInfo classes.
     * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes
     * @memberof CSVCMsg_ClassInfo
     * @instance
     */
    CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_ClassInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_ClassInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.createOnClient = reader.bool();
                    break;
                case 2:
                    if (!(message.classes && message.classes.length))
                        message.classes = [];
                    message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_ClassInfo.class_t = (function () {
        /**
         * Properties of a class_t.
         * @memberof CSVCMsg_ClassInfo
         * @interface Iclass_t
         * @property {number|null} [classId] class_t classId
         * @property {string|null} [dataTableName] class_t dataTableName
         * @property {string|null} [className] class_t className
         */
        /**
         * Constructs a new class_t.
         * @memberof CSVCMsg_ClassInfo
         * @classdesc Represents a class_t.
         * @implements Iclass_t
         * @constructor
         * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
         */
        function class_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * class_t classId.
         * @member {number} classId
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.classId = 0;
        /**
         * class_t dataTableName.
         * @member {string} dataTableName
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.dataTableName = "";
        /**
         * class_t className.
         * @member {string} className
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.className = "";
        /**
         * Decodes a class_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClassInfo.class_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClassInfo.class_t} class_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        class_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.classId = reader.int32();
                        break;
                    case 2:
                        message.dataTableName = reader.string();
                        break;
                    case 3:
                        message.className = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return class_t;
    })();
    return CSVCMsg_ClassInfo;
})());
exports.CSVCMsg_SendTable = ($root.CSVCMsg_SendTable = (() => {
    /**
     * Properties of a CSVCMsg_SendTable.
     * @exports ICSVCMsg_SendTable
     * @interface ICSVCMsg_SendTable
     * @property {boolean|null} [isEnd] CSVCMsg_SendTable isEnd
     * @property {string|null} [netTableName] CSVCMsg_SendTable netTableName
     * @property {boolean|null} [needsDecoder] CSVCMsg_SendTable needsDecoder
     * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props
     */
    /**
     * Constructs a new CSVCMsg_SendTable.
     * @exports CSVCMsg_SendTable
     * @classdesc Represents a CSVCMsg_SendTable.
     * @implements ICSVCMsg_SendTable
     * @constructor
     * @param {ICSVCMsg_SendTable=} [properties] Properties to set
     */
    function CSVCMsg_SendTable(properties) {
        this.props = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SendTable isEnd.
     * @member {boolean} isEnd
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.isEnd = false;
    /**
     * CSVCMsg_SendTable netTableName.
     * @member {string} netTableName
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.netTableName = "";
    /**
     * CSVCMsg_SendTable needsDecoder.
     * @member {boolean} needsDecoder
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.needsDecoder = false;
    /**
     * CSVCMsg_SendTable props.
     * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.props = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SendTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SendTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isEnd = reader.bool();
                    break;
                case 2:
                    message.netTableName = reader.string();
                    break;
                case 3:
                    message.needsDecoder = reader.bool();
                    break;
                case 4:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_SendTable.sendprop_t = (function () {
        /**
         * Properties of a sendprop_t.
         * @memberof CSVCMsg_SendTable
         * @interface Isendprop_t
         * @property {number|null} [type] sendprop_t type
         * @property {string|null} [varName] sendprop_t varName
         * @property {number|null} [flags] sendprop_t flags
         * @property {number|null} [priority] sendprop_t priority
         * @property {string|null} [dtName] sendprop_t dtName
         * @property {number|null} [numElements] sendprop_t numElements
         * @property {number|null} [lowValue] sendprop_t lowValue
         * @property {number|null} [highValue] sendprop_t highValue
         * @property {number|null} [numBits] sendprop_t numBits
         */
        /**
         * Constructs a new sendprop_t.
         * @memberof CSVCMsg_SendTable
         * @classdesc Represents a sendprop_t.
         * @implements Isendprop_t
         * @constructor
         * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
         */
        function sendprop_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * sendprop_t type.
         * @member {number} type
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.type = 0;
        /**
         * sendprop_t varName.
         * @member {string} varName
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.varName = "";
        /**
         * sendprop_t flags.
         * @member {number} flags
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.flags = 0;
        /**
         * sendprop_t priority.
         * @member {number} priority
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.priority = 0;
        /**
         * sendprop_t dtName.
         * @member {string} dtName
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.dtName = "";
        /**
         * sendprop_t numElements.
         * @member {number} numElements
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.numElements = 0;
        /**
         * sendprop_t lowValue.
         * @member {number} lowValue
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.lowValue = 0;
        /**
         * sendprop_t highValue.
         * @member {number} highValue
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.highValue = 0;
        /**
         * sendprop_t numBits.
         * @member {number} numBits
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.numBits = 0;
        /**
         * Decodes a sendprop_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        sendprop_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.varName = reader.string();
                        break;
                    case 3:
                        message.flags = reader.int32();
                        break;
                    case 4:
                        message.priority = reader.int32();
                        break;
                    case 5:
                        message.dtName = reader.string();
                        break;
                    case 6:
                        message.numElements = reader.int32();
                        break;
                    case 7:
                        message.lowValue = reader.float();
                        break;
                    case 8:
                        message.highValue = reader.float();
                        break;
                    case 9:
                        message.numBits = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return sendprop_t;
    })();
    return CSVCMsg_SendTable;
})());
exports.CSVCMsg_Print = ($root.CSVCMsg_Print = (() => {
    /**
     * Properties of a CSVCMsg_Print.
     * @exports ICSVCMsg_Print
     * @interface ICSVCMsg_Print
     * @property {string|null} [text] CSVCMsg_Print text
     */
    /**
     * Constructs a new CSVCMsg_Print.
     * @exports CSVCMsg_Print
     * @classdesc Represents a CSVCMsg_Print.
     * @implements ICSVCMsg_Print
     * @constructor
     * @param {ICSVCMsg_Print=} [properties] Properties to set
     */
    function CSVCMsg_Print(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Print text.
     * @member {string} text
     * @memberof CSVCMsg_Print
     * @instance
     */
    CSVCMsg_Print.prototype.text = "";
    /**
     * Decodes a CSVCMsg_Print message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Print
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Print} CSVCMsg_Print
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Print.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Print;
})());
exports.CSVCMsg_SetPause = ($root.CSVCMsg_SetPause = (() => {
    /**
     * Properties of a CSVCMsg_SetPause.
     * @exports ICSVCMsg_SetPause
     * @interface ICSVCMsg_SetPause
     * @property {boolean|null} [paused] CSVCMsg_SetPause paused
     */
    /**
     * Constructs a new CSVCMsg_SetPause.
     * @exports CSVCMsg_SetPause
     * @classdesc Represents a CSVCMsg_SetPause.
     * @implements ICSVCMsg_SetPause
     * @constructor
     * @param {ICSVCMsg_SetPause=} [properties] Properties to set
     */
    function CSVCMsg_SetPause(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SetPause paused.
     * @member {boolean} paused
     * @memberof CSVCMsg_SetPause
     * @instance
     */
    CSVCMsg_SetPause.prototype.paused = false;
    /**
     * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SetPause
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SetPause.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paused = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SetPause;
})());
exports.CSVCMsg_SetView = ($root.CSVCMsg_SetView = (() => {
    /**
     * Properties of a CSVCMsg_SetView.
     * @exports ICSVCMsg_SetView
     * @interface ICSVCMsg_SetView
     * @property {number|null} [entityIndex] CSVCMsg_SetView entityIndex
     */
    /**
     * Constructs a new CSVCMsg_SetView.
     * @exports CSVCMsg_SetView
     * @classdesc Represents a CSVCMsg_SetView.
     * @implements ICSVCMsg_SetView
     * @constructor
     * @param {ICSVCMsg_SetView=} [properties] Properties to set
     */
    function CSVCMsg_SetView(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SetView entityIndex.
     * @member {number} entityIndex
     * @memberof CSVCMsg_SetView
     * @instance
     */
    CSVCMsg_SetView.prototype.entityIndex = 0;
    /**
     * Decodes a CSVCMsg_SetView message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SetView
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SetView} CSVCMsg_SetView
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SetView.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entityIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SetView;
})());
exports.CSVCMsg_CreateStringTable = ($root.CSVCMsg_CreateStringTable = (() => {
    /**
     * Properties of a CSVCMsg_CreateStringTable.
     * @exports ICSVCMsg_CreateStringTable
     * @interface ICSVCMsg_CreateStringTable
     * @property {string|null} [name] CSVCMsg_CreateStringTable name
     * @property {number|null} [maxEntries] CSVCMsg_CreateStringTable maxEntries
     * @property {number|null} [numEntries] CSVCMsg_CreateStringTable numEntries
     * @property {boolean|null} [userDataFixedSize] CSVCMsg_CreateStringTable userDataFixedSize
     * @property {number|null} [userDataSize] CSVCMsg_CreateStringTable userDataSize
     * @property {number|null} [userDataSizeBits] CSVCMsg_CreateStringTable userDataSizeBits
     * @property {number|null} [flags] CSVCMsg_CreateStringTable flags
     * @property {Uint8Array|null} [stringData] CSVCMsg_CreateStringTable stringData
     */
    /**
     * Constructs a new CSVCMsg_CreateStringTable.
     * @exports CSVCMsg_CreateStringTable
     * @classdesc Represents a CSVCMsg_CreateStringTable.
     * @implements ICSVCMsg_CreateStringTable
     * @constructor
     * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
     */
    function CSVCMsg_CreateStringTable(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CreateStringTable name.
     * @member {string} name
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.name = "";
    /**
     * CSVCMsg_CreateStringTable maxEntries.
     * @member {number} maxEntries
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.maxEntries = 0;
    /**
     * CSVCMsg_CreateStringTable numEntries.
     * @member {number} numEntries
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.numEntries = 0;
    /**
     * CSVCMsg_CreateStringTable userDataFixedSize.
     * @member {boolean} userDataFixedSize
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataFixedSize = false;
    /**
     * CSVCMsg_CreateStringTable userDataSize.
     * @member {number} userDataSize
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataSize = 0;
    /**
     * CSVCMsg_CreateStringTable userDataSizeBits.
     * @member {number} userDataSizeBits
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataSizeBits = 0;
    /**
     * CSVCMsg_CreateStringTable flags.
     * @member {number} flags
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.flags = 0;
    /**
     * CSVCMsg_CreateStringTable stringData.
     * @member {Uint8Array} stringData
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.stringData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CreateStringTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CreateStringTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.maxEntries = reader.int32();
                    break;
                case 3:
                    message.numEntries = reader.int32();
                    break;
                case 4:
                    message.userDataFixedSize = reader.bool();
                    break;
                case 5:
                    message.userDataSize = reader.int32();
                    break;
                case 6:
                    message.userDataSizeBits = reader.int32();
                    break;
                case 7:
                    message.flags = reader.int32();
                    break;
                case 8:
                    message.stringData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CreateStringTable;
})());
exports.CSVCMsg_UpdateStringTable = ($root.CSVCMsg_UpdateStringTable = (() => {
    /**
     * Properties of a CSVCMsg_UpdateStringTable.
     * @exports ICSVCMsg_UpdateStringTable
     * @interface ICSVCMsg_UpdateStringTable
     * @property {number|null} [tableId] CSVCMsg_UpdateStringTable tableId
     * @property {number|null} [numChangedEntries] CSVCMsg_UpdateStringTable numChangedEntries
     * @property {Uint8Array|null} [stringData] CSVCMsg_UpdateStringTable stringData
     */
    /**
     * Constructs a new CSVCMsg_UpdateStringTable.
     * @exports CSVCMsg_UpdateStringTable
     * @classdesc Represents a CSVCMsg_UpdateStringTable.
     * @implements ICSVCMsg_UpdateStringTable
     * @constructor
     * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
     */
    function CSVCMsg_UpdateStringTable(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_UpdateStringTable tableId.
     * @member {number} tableId
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.tableId = 0;
    /**
     * CSVCMsg_UpdateStringTable numChangedEntries.
     * @member {number} numChangedEntries
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.numChangedEntries = 0;
    /**
     * CSVCMsg_UpdateStringTable stringData.
     * @member {Uint8Array} stringData
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.stringData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_UpdateStringTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tableId = reader.int32();
                    break;
                case 2:
                    message.numChangedEntries = reader.int32();
                    break;
                case 3:
                    message.stringData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_UpdateStringTable;
})());
exports.CSVCMsg_VoiceInit = ($root.CSVCMsg_VoiceInit = (() => {
    /**
     * Properties of a CSVCMsg_VoiceInit.
     * @exports ICSVCMsg_VoiceInit
     * @interface ICSVCMsg_VoiceInit
     * @property {number|null} [quality] CSVCMsg_VoiceInit quality
     * @property {string|null} [codec] CSVCMsg_VoiceInit codec
     * @property {number|null} [version] CSVCMsg_VoiceInit version
     */
    /**
     * Constructs a new CSVCMsg_VoiceInit.
     * @exports CSVCMsg_VoiceInit
     * @classdesc Represents a CSVCMsg_VoiceInit.
     * @implements ICSVCMsg_VoiceInit
     * @constructor
     * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
     */
    function CSVCMsg_VoiceInit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_VoiceInit quality.
     * @member {number} quality
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.quality = 0;
    /**
     * CSVCMsg_VoiceInit codec.
     * @member {string} codec
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.codec = "";
    /**
     * CSVCMsg_VoiceInit version.
     * @member {number} version
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.version = 0;
    /**
     * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_VoiceInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_VoiceInit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.codec = reader.string();
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_VoiceInit;
})());
exports.CSVCMsg_VoiceData = ($root.CSVCMsg_VoiceData = (() => {
    /**
     * Properties of a CSVCMsg_VoiceData.
     * @exports ICSVCMsg_VoiceData
     * @interface ICSVCMsg_VoiceData
     * @property {number|null} [client] CSVCMsg_VoiceData client
     * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity
     * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid
     * @property {number|null} [audibleMask] CSVCMsg_VoiceData audibleMask
     * @property {Uint8Array|null} [voiceData] CSVCMsg_VoiceData voiceData
     * @property {boolean|null} [caster] CSVCMsg_VoiceData caster
     * @property {VoiceDataFormat_t|null} [format] CSVCMsg_VoiceData format
     * @property {number|null} [sequenceBytes] CSVCMsg_VoiceData sequenceBytes
     * @property {number|null} [sectionNumber] CSVCMsg_VoiceData sectionNumber
     * @property {number|null} [uncompressedSampleOffset] CSVCMsg_VoiceData uncompressedSampleOffset
     */
    /**
     * Constructs a new CSVCMsg_VoiceData.
     * @exports CSVCMsg_VoiceData
     * @classdesc Represents a CSVCMsg_VoiceData.
     * @implements ICSVCMsg_VoiceData
     * @constructor
     * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
     */
    function CSVCMsg_VoiceData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_VoiceData client.
     * @member {number} client
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.client = 0;
    /**
     * CSVCMsg_VoiceData proximity.
     * @member {boolean} proximity
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.proximity = false;
    /**
     * CSVCMsg_VoiceData xuid.
     * @member {number|Long} xuid
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.xuid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CSVCMsg_VoiceData audibleMask.
     * @member {number} audibleMask
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.audibleMask = 0;
    /**
     * CSVCMsg_VoiceData voiceData.
     * @member {Uint8Array} voiceData
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.voiceData = $util.newBuffer([]);
    /**
     * CSVCMsg_VoiceData caster.
     * @member {boolean} caster
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.caster = false;
    /**
     * CSVCMsg_VoiceData format.
     * @member {VoiceDataFormat_t} format
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.format = 1;
    /**
     * CSVCMsg_VoiceData sequenceBytes.
     * @member {number} sequenceBytes
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.sequenceBytes = 0;
    /**
     * CSVCMsg_VoiceData sectionNumber.
     * @member {number} sectionNumber
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.sectionNumber = 0;
    /**
     * CSVCMsg_VoiceData uncompressedSampleOffset.
     * @member {number} uncompressedSampleOffset
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;
    /**
     * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_VoiceData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_VoiceData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.client = reader.int32();
                    break;
                case 2:
                    message.proximity = reader.bool();
                    break;
                case 3:
                    message.xuid = reader.fixed64();
                    break;
                case 4:
                    message.audibleMask = reader.int32();
                    break;
                case 5:
                    message.voiceData = reader.bytes();
                    break;
                case 6:
                    message.caster = reader.bool();
                    break;
                case 7:
                    message.format = reader.int32();
                    break;
                case 8:
                    message.sequenceBytes = reader.int32();
                    break;
                case 9:
                    message.sectionNumber = reader.uint32();
                    break;
                case 10:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_VoiceData;
})());
exports.CSVCMsg_FixAngle = ($root.CSVCMsg_FixAngle = (() => {
    /**
     * Properties of a CSVCMsg_FixAngle.
     * @exports ICSVCMsg_FixAngle
     * @interface ICSVCMsg_FixAngle
     * @property {boolean|null} [relative] CSVCMsg_FixAngle relative
     * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle
     */
    /**
     * Constructs a new CSVCMsg_FixAngle.
     * @exports CSVCMsg_FixAngle
     * @classdesc Represents a CSVCMsg_FixAngle.
     * @implements ICSVCMsg_FixAngle
     * @constructor
     * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
     */
    function CSVCMsg_FixAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_FixAngle relative.
     * @member {boolean} relative
     * @memberof CSVCMsg_FixAngle
     * @instance
     */
    CSVCMsg_FixAngle.prototype.relative = false;
    /**
     * CSVCMsg_FixAngle angle.
     * @member {ICMsgQAngle|null|undefined} angle
     * @memberof CSVCMsg_FixAngle
     * @instance
     */
    CSVCMsg_FixAngle.prototype.angle = null;
    /**
     * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_FixAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_FixAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.relative = reader.bool();
                    break;
                case 2:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_FixAngle;
})());
exports.CSVCMsg_CrosshairAngle = ($root.CSVCMsg_CrosshairAngle = (() => {
    /**
     * Properties of a CSVCMsg_CrosshairAngle.
     * @exports ICSVCMsg_CrosshairAngle
     * @interface ICSVCMsg_CrosshairAngle
     * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle
     */
    /**
     * Constructs a new CSVCMsg_CrosshairAngle.
     * @exports CSVCMsg_CrosshairAngle
     * @classdesc Represents a CSVCMsg_CrosshairAngle.
     * @implements ICSVCMsg_CrosshairAngle
     * @constructor
     * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
     */
    function CSVCMsg_CrosshairAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CrosshairAngle angle.
     * @member {ICMsgQAngle|null|undefined} angle
     * @memberof CSVCMsg_CrosshairAngle
     * @instance
     */
    CSVCMsg_CrosshairAngle.prototype.angle = null;
    /**
     * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CrosshairAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CrosshairAngle;
})());
exports.CSVCMsg_Prefetch = ($root.CSVCMsg_Prefetch = (() => {
    /**
     * Properties of a CSVCMsg_Prefetch.
     * @exports ICSVCMsg_Prefetch
     * @interface ICSVCMsg_Prefetch
     * @property {number|null} [soundIndex] CSVCMsg_Prefetch soundIndex
     */
    /**
     * Constructs a new CSVCMsg_Prefetch.
     * @exports CSVCMsg_Prefetch
     * @classdesc Represents a CSVCMsg_Prefetch.
     * @implements ICSVCMsg_Prefetch
     * @constructor
     * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
     */
    function CSVCMsg_Prefetch(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Prefetch soundIndex.
     * @member {number} soundIndex
     * @memberof CSVCMsg_Prefetch
     * @instance
     */
    CSVCMsg_Prefetch.prototype.soundIndex = 0;
    /**
     * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Prefetch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Prefetch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.soundIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Prefetch;
})());
exports.CSVCMsg_BSPDecal = ($root.CSVCMsg_BSPDecal = (() => {
    /**
     * Properties of a CSVCMsg_BSPDecal.
     * @exports ICSVCMsg_BSPDecal
     * @interface ICSVCMsg_BSPDecal
     * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos
     * @property {number|null} [decalTextureIndex] CSVCMsg_BSPDecal decalTextureIndex
     * @property {number|null} [entityIndex] CSVCMsg_BSPDecal entityIndex
     * @property {number|null} [modelIndex] CSVCMsg_BSPDecal modelIndex
     * @property {boolean|null} [lowPriority] CSVCMsg_BSPDecal lowPriority
     */
    /**
     * Constructs a new CSVCMsg_BSPDecal.
     * @exports CSVCMsg_BSPDecal
     * @classdesc Represents a CSVCMsg_BSPDecal.
     * @implements ICSVCMsg_BSPDecal
     * @constructor
     * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
     */
    function CSVCMsg_BSPDecal(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_BSPDecal pos.
     * @member {ICMsgVector|null|undefined} pos
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.pos = null;
    /**
     * CSVCMsg_BSPDecal decalTextureIndex.
     * @member {number} decalTextureIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.decalTextureIndex = 0;
    /**
     * CSVCMsg_BSPDecal entityIndex.
     * @member {number} entityIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.entityIndex = 0;
    /**
     * CSVCMsg_BSPDecal modelIndex.
     * @member {number} modelIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.modelIndex = 0;
    /**
     * CSVCMsg_BSPDecal lowPriority.
     * @member {boolean} lowPriority
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.lowPriority = false;
    /**
     * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_BSPDecal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_BSPDecal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.decalTextureIndex = reader.int32();
                    break;
                case 3:
                    message.entityIndex = reader.int32();
                    break;
                case 4:
                    message.modelIndex = reader.int32();
                    break;
                case 5:
                    message.lowPriority = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_BSPDecal;
})());
exports.CSVCMsg_SplitScreen = ($root.CSVCMsg_SplitScreen = (() => {
    /**
     * Properties of a CSVCMsg_SplitScreen.
     * @exports ICSVCMsg_SplitScreen
     * @interface ICSVCMsg_SplitScreen
     * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type
     * @property {number|null} [slot] CSVCMsg_SplitScreen slot
     * @property {number|null} [playerIndex] CSVCMsg_SplitScreen playerIndex
     */
    /**
     * Constructs a new CSVCMsg_SplitScreen.
     * @exports CSVCMsg_SplitScreen
     * @classdesc Represents a CSVCMsg_SplitScreen.
     * @implements ICSVCMsg_SplitScreen
     * @constructor
     * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
     */
    function CSVCMsg_SplitScreen(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SplitScreen type.
     * @member {ESplitScreenMessageType} type
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.type = 0;
    /**
     * CSVCMsg_SplitScreen slot.
     * @member {number} slot
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.slot = 0;
    /**
     * CSVCMsg_SplitScreen playerIndex.
     * @member {number} playerIndex
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.playerIndex = 0;
    /**
     * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SplitScreen
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SplitScreen.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.slot = reader.int32();
                    break;
                case 3:
                    message.playerIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SplitScreen;
})());
exports.CSVCMsg_GetCvarValue = ($root.CSVCMsg_GetCvarValue = (() => {
    /**
     * Properties of a CSVCMsg_GetCvarValue.
     * @exports ICSVCMsg_GetCvarValue
     * @interface ICSVCMsg_GetCvarValue
     * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie
     * @property {string|null} [cvarName] CSVCMsg_GetCvarValue cvarName
     */
    /**
     * Constructs a new CSVCMsg_GetCvarValue.
     * @exports CSVCMsg_GetCvarValue
     * @classdesc Represents a CSVCMsg_GetCvarValue.
     * @implements ICSVCMsg_GetCvarValue
     * @constructor
     * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
     */
    function CSVCMsg_GetCvarValue(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GetCvarValue cookie.
     * @member {number} cookie
     * @memberof CSVCMsg_GetCvarValue
     * @instance
     */
    CSVCMsg_GetCvarValue.prototype.cookie = 0;
    /**
     * CSVCMsg_GetCvarValue cvarName.
     * @member {string} cvarName
     * @memberof CSVCMsg_GetCvarValue
     * @instance
     */
    CSVCMsg_GetCvarValue.prototype.cvarName = "";
    /**
     * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GetCvarValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GetCvarValue.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.cvarName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_GetCvarValue;
})());
exports.CSVCMsg_Menu = ($root.CSVCMsg_Menu = (() => {
    /**
     * Properties of a CSVCMsg_Menu.
     * @exports ICSVCMsg_Menu
     * @interface ICSVCMsg_Menu
     * @property {number|null} [dialogType] CSVCMsg_Menu dialogType
     * @property {Uint8Array|null} [menuKeyValues] CSVCMsg_Menu menuKeyValues
     */
    /**
     * Constructs a new CSVCMsg_Menu.
     * @exports CSVCMsg_Menu
     * @classdesc Represents a CSVCMsg_Menu.
     * @implements ICSVCMsg_Menu
     * @constructor
     * @param {ICSVCMsg_Menu=} [properties] Properties to set
     */
    function CSVCMsg_Menu(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Menu dialogType.
     * @member {number} dialogType
     * @memberof CSVCMsg_Menu
     * @instance
     */
    CSVCMsg_Menu.prototype.dialogType = 0;
    /**
     * CSVCMsg_Menu menuKeyValues.
     * @member {Uint8Array} menuKeyValues
     * @memberof CSVCMsg_Menu
     * @instance
     */
    CSVCMsg_Menu.prototype.menuKeyValues = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_Menu message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Menu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Menu} CSVCMsg_Menu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Menu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dialogType = reader.int32();
                    break;
                case 2:
                    message.menuKeyValues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Menu;
})());
exports.CSVCMsg_UserMessage = ($root.CSVCMsg_UserMessage = (() => {
    /**
     * Properties of a CSVCMsg_UserMessage.
     * @exports ICSVCMsg_UserMessage
     * @interface ICSVCMsg_UserMessage
     * @property {number|null} [msgType] CSVCMsg_UserMessage msgType
     * @property {Uint8Array|null} [msgData] CSVCMsg_UserMessage msgData
     * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough
     */
    /**
     * Constructs a new CSVCMsg_UserMessage.
     * @exports CSVCMsg_UserMessage
     * @classdesc Represents a CSVCMsg_UserMessage.
     * @implements ICSVCMsg_UserMessage
     * @constructor
     * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
     */
    function CSVCMsg_UserMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_UserMessage msgType.
     * @member {number} msgType
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.msgType = 0;
    /**
     * CSVCMsg_UserMessage msgData.
     * @member {Uint8Array} msgData
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.msgData = $util.newBuffer([]);
    /**
     * CSVCMsg_UserMessage passthrough.
     * @member {number} passthrough
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.passthrough = 0;
    /**
     * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_UserMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_UserMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgType = reader.int32();
                    break;
                case 2:
                    message.msgData = reader.bytes();
                    break;
                case 3:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_UserMessage;
})());
exports.CSVCMsg_PaintmapData = ($root.CSVCMsg_PaintmapData = (() => {
    /**
     * Properties of a CSVCMsg_PaintmapData.
     * @exports ICSVCMsg_PaintmapData
     * @interface ICSVCMsg_PaintmapData
     * @property {Uint8Array|null} [paintmap] CSVCMsg_PaintmapData paintmap
     */
    /**
     * Constructs a new CSVCMsg_PaintmapData.
     * @exports CSVCMsg_PaintmapData
     * @classdesc Represents a CSVCMsg_PaintmapData.
     * @implements ICSVCMsg_PaintmapData
     * @constructor
     * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set
     */
    function CSVCMsg_PaintmapData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_PaintmapData paintmap.
     * @member {Uint8Array} paintmap
     * @memberof CSVCMsg_PaintmapData
     * @instance
     */
    CSVCMsg_PaintmapData.prototype.paintmap = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_PaintmapData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_PaintmapData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PaintmapData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paintmap = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_PaintmapData;
})());
exports.CSVCMsg_GameEvent = ($root.CSVCMsg_GameEvent = (() => {
    /**
     * Properties of a CSVCMsg_GameEvent.
     * @exports ICSVCMsg_GameEvent
     * @interface ICSVCMsg_GameEvent
     * @property {string|null} [eventName] CSVCMsg_GameEvent eventName
     * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
     * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
     * @property {number|null} [passthrough] CSVCMsg_GameEvent passthrough
     */
    /**
     * Constructs a new CSVCMsg_GameEvent.
     * @exports CSVCMsg_GameEvent
     * @classdesc Represents a CSVCMsg_GameEvent.
     * @implements ICSVCMsg_GameEvent
     * @constructor
     * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
     */
    function CSVCMsg_GameEvent(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GameEvent eventName.
     * @member {string} eventName
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.eventName = "";
    /**
     * CSVCMsg_GameEvent eventid.
     * @member {number} eventid
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.eventid = 0;
    /**
     * CSVCMsg_GameEvent keys.
     * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    /**
     * CSVCMsg_GameEvent passthrough.
     * @member {number} passthrough
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.passthrough = 0;
    /**
     * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GameEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GameEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventName = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_GameEvent.key_t = (function () {
        /**
         * Properties of a key_t.
         * @memberof CSVCMsg_GameEvent
         * @interface Ikey_t
         * @property {number|null} [type] key_t type
         * @property {string|null} [valString] key_t valString
         * @property {number|null} [valFloat] key_t valFloat
         * @property {number|null} [valLong] key_t valLong
         * @property {number|null} [valShort] key_t valShort
         * @property {number|null} [valByte] key_t valByte
         * @property {boolean|null} [valBool] key_t valBool
         * @property {number|Long|null} [valUint64] key_t valUint64
         * @property {Uint8Array|null} [valWstring] key_t valWstring
         */
        /**
         * Constructs a new key_t.
         * @memberof CSVCMsg_GameEvent
         * @classdesc Represents a key_t.
         * @implements Ikey_t
         * @constructor
         * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
         */
        function key_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * key_t type.
         * @member {number} type
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.type = 0;
        /**
         * key_t valString.
         * @member {string} valString
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valString = "";
        /**
         * key_t valFloat.
         * @member {number} valFloat
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valFloat = 0;
        /**
         * key_t valLong.
         * @member {number} valLong
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valLong = 0;
        /**
         * key_t valShort.
         * @member {number} valShort
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valShort = 0;
        /**
         * key_t valByte.
         * @member {number} valByte
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valByte = 0;
        /**
         * key_t valBool.
         * @member {boolean} valBool
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valBool = false;
        /**
         * key_t valUint64.
         * @member {number|Long} valUint64
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valUint64 = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;
        /**
         * key_t valWstring.
         * @member {Uint8Array} valWstring
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valWstring = $util.newBuffer([]);
        /**
         * Decodes a key_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent.key_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent.key_t} key_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        key_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.valString = reader.string();
                        break;
                    case 3:
                        message.valFloat = reader.float();
                        break;
                    case 4:
                        message.valLong = reader.int32();
                        break;
                    case 5:
                        message.valShort = reader.int32();
                        break;
                    case 6:
                        message.valByte = reader.int32();
                        break;
                    case 7:
                        message.valBool = reader.bool();
                        break;
                    case 8:
                        message.valUint64 = reader.uint64();
                        break;
                    case 9:
                        message.valWstring = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return key_t;
    })();
    return CSVCMsg_GameEvent;
})());
exports.CSVCMsg_GameEventList = ($root.CSVCMsg_GameEventList = (() => {
    /**
     * Properties of a CSVCMsg_GameEventList.
     * @exports ICSVCMsg_GameEventList
     * @interface ICSVCMsg_GameEventList
     * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors
     */
    /**
     * Constructs a new CSVCMsg_GameEventList.
     * @exports CSVCMsg_GameEventList
     * @classdesc Represents a CSVCMsg_GameEventList.
     * @implements ICSVCMsg_GameEventList
     * @constructor
     * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
     */
    function CSVCMsg_GameEventList(properties) {
        this.descriptors = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GameEventList descriptors.
     * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors
     * @memberof CSVCMsg_GameEventList
     * @instance
     */
    CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GameEventList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GameEventList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.descriptors && message.descriptors.length))
                        message.descriptors = [];
                    message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_GameEventList.key_t = (function () {
        /**
         * Properties of a key_t.
         * @memberof CSVCMsg_GameEventList
         * @interface Ikey_t
         * @property {number|null} [type] key_t type
         * @property {string|null} [name] key_t name
         */
        /**
         * Constructs a new key_t.
         * @memberof CSVCMsg_GameEventList
         * @classdesc Represents a key_t.
         * @implements Ikey_t
         * @constructor
         * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
         */
        function key_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * key_t type.
         * @member {number} type
         * @memberof CSVCMsg_GameEventList.key_t
         * @instance
         */
        key_t.prototype.type = 0;
        /**
         * key_t name.
         * @member {string} name
         * @memberof CSVCMsg_GameEventList.key_t
         * @instance
         */
        key_t.prototype.name = "";
        /**
         * Decodes a key_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList.key_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList.key_t} key_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        key_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return key_t;
    })();
    CSVCMsg_GameEventList.descriptor_t = (function () {
        /**
         * Properties of a descriptor_t.
         * @memberof CSVCMsg_GameEventList
         * @interface Idescriptor_t
         * @property {number|null} [eventid] descriptor_t eventid
         * @property {string|null} [name] descriptor_t name
         * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys
         */
        /**
         * Constructs a new descriptor_t.
         * @memberof CSVCMsg_GameEventList
         * @classdesc Represents a descriptor_t.
         * @implements Idescriptor_t
         * @constructor
         * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
         */
        function descriptor_t(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * descriptor_t eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.eventid = 0;
        /**
         * descriptor_t name.
         * @member {string} name
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.name = "";
        /**
         * descriptor_t keys.
         * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.keys = $util.emptyArray;
        /**
         * Decodes a descriptor_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        descriptor_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.eventid = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return descriptor_t;
    })();
    return CSVCMsg_GameEventList;
})());
exports.CSVCMsg_TempEntities = ($root.CSVCMsg_TempEntities = (() => {
    /**
     * Properties of a CSVCMsg_TempEntities.
     * @exports ICSVCMsg_TempEntities
     * @interface ICSVCMsg_TempEntities
     * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable
     * @property {number|null} [numEntries] CSVCMsg_TempEntities numEntries
     * @property {Uint8Array|null} [entityData] CSVCMsg_TempEntities entityData
     */
    /**
     * Constructs a new CSVCMsg_TempEntities.
     * @exports CSVCMsg_TempEntities
     * @classdesc Represents a CSVCMsg_TempEntities.
     * @implements ICSVCMsg_TempEntities
     * @constructor
     * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
     */
    function CSVCMsg_TempEntities(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_TempEntities reliable.
     * @member {boolean} reliable
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.reliable = false;
    /**
     * CSVCMsg_TempEntities numEntries.
     * @member {number} numEntries
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.numEntries = 0;
    /**
     * CSVCMsg_TempEntities entityData.
     * @member {Uint8Array} entityData
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.entityData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_TempEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_TempEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reliable = reader.bool();
                    break;
                case 2:
                    message.numEntries = reader.int32();
                    break;
                case 3:
                    message.entityData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_TempEntities;
})());
exports.CSVCMsg_PacketEntities = ($root.CSVCMsg_PacketEntities = (() => {
    /**
     * Properties of a CSVCMsg_PacketEntities.
     * @exports ICSVCMsg_PacketEntities
     * @interface ICSVCMsg_PacketEntities
     * @property {number|null} [maxEntries] CSVCMsg_PacketEntities maxEntries
     * @property {number|null} [updatedEntries] CSVCMsg_PacketEntities updatedEntries
     * @property {boolean|null} [isDelta] CSVCMsg_PacketEntities isDelta
     * @property {boolean|null} [updateBaseline] CSVCMsg_PacketEntities updateBaseline
     * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline
     * @property {number|null} [deltaFrom] CSVCMsg_PacketEntities deltaFrom
     * @property {Uint8Array|null} [entityData] CSVCMsg_PacketEntities entityData
     */
    /**
     * Constructs a new CSVCMsg_PacketEntities.
     * @exports CSVCMsg_PacketEntities
     * @classdesc Represents a CSVCMsg_PacketEntities.
     * @implements ICSVCMsg_PacketEntities
     * @constructor
     * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
     */
    function CSVCMsg_PacketEntities(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_PacketEntities maxEntries.
     * @member {number} maxEntries
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.maxEntries = 0;
    /**
     * CSVCMsg_PacketEntities updatedEntries.
     * @member {number} updatedEntries
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.updatedEntries = 0;
    /**
     * CSVCMsg_PacketEntities isDelta.
     * @member {boolean} isDelta
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.isDelta = false;
    /**
     * CSVCMsg_PacketEntities updateBaseline.
     * @member {boolean} updateBaseline
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.updateBaseline = false;
    /**
     * CSVCMsg_PacketEntities baseline.
     * @member {number} baseline
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.baseline = 0;
    /**
     * CSVCMsg_PacketEntities deltaFrom.
     * @member {number} deltaFrom
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.deltaFrom = 0;
    /**
     * CSVCMsg_PacketEntities entityData.
     * @member {Uint8Array} entityData
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.entityData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_PacketEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_PacketEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maxEntries = reader.int32();
                    break;
                case 2:
                    message.updatedEntries = reader.int32();
                    break;
                case 3:
                    message.isDelta = reader.bool();
                    break;
                case 4:
                    message.updateBaseline = reader.bool();
                    break;
                case 5:
                    message.baseline = reader.int32();
                    break;
                case 6:
                    message.deltaFrom = reader.int32();
                    break;
                case 7:
                    message.entityData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_PacketEntities;
})());
exports.CSVCMsg_Sounds = ($root.CSVCMsg_Sounds = (() => {
    /**
     * Properties of a CSVCMsg_Sounds.
     * @exports ICSVCMsg_Sounds
     * @interface ICSVCMsg_Sounds
     * @property {boolean|null} [reliableSound] CSVCMsg_Sounds reliableSound
     * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds
     */
    /**
     * Constructs a new CSVCMsg_Sounds.
     * @exports CSVCMsg_Sounds
     * @classdesc Represents a CSVCMsg_Sounds.
     * @implements ICSVCMsg_Sounds
     * @constructor
     * @param {ICSVCMsg_Sounds=} [properties] Properties to set
     */
    function CSVCMsg_Sounds(properties) {
        this.sounds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Sounds reliableSound.
     * @member {boolean} reliableSound
     * @memberof CSVCMsg_Sounds
     * @instance
     */
    CSVCMsg_Sounds.prototype.reliableSound = false;
    /**
     * CSVCMsg_Sounds sounds.
     * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds
     * @memberof CSVCMsg_Sounds
     * @instance
     */
    CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Sounds
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Sounds.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reliableSound = reader.bool();
                    break;
                case 2:
                    if (!(message.sounds && message.sounds.length))
                        message.sounds = [];
                    message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_Sounds.sounddata_t = (function () {
        /**
         * Properties of a sounddata_t.
         * @memberof CSVCMsg_Sounds
         * @interface Isounddata_t
         * @property {number|null} [originX] sounddata_t originX
         * @property {number|null} [originY] sounddata_t originY
         * @property {number|null} [originZ] sounddata_t originZ
         * @property {number|null} [volume] sounddata_t volume
         * @property {number|null} [delayValue] sounddata_t delayValue
         * @property {number|null} [sequenceNumber] sounddata_t sequenceNumber
         * @property {number|null} [entityIndex] sounddata_t entityIndex
         * @property {number|null} [channel] sounddata_t channel
         * @property {number|null} [pitch] sounddata_t pitch
         * @property {number|null} [flags] sounddata_t flags
         * @property {number|null} [soundNum] sounddata_t soundNum
         * @property {number|null} [soundNumHandle] sounddata_t soundNumHandle
         * @property {number|null} [speakerEntity] sounddata_t speakerEntity
         * @property {number|null} [randomSeed] sounddata_t randomSeed
         * @property {number|null} [soundLevel] sounddata_t soundLevel
         * @property {boolean|null} [isSentence] sounddata_t isSentence
         * @property {boolean|null} [isAmbient] sounddata_t isAmbient
         */
        /**
         * Constructs a new sounddata_t.
         * @memberof CSVCMsg_Sounds
         * @classdesc Represents a sounddata_t.
         * @implements Isounddata_t
         * @constructor
         * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
         */
        function sounddata_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * sounddata_t originX.
         * @member {number} originX
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originX = 0;
        /**
         * sounddata_t originY.
         * @member {number} originY
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originY = 0;
        /**
         * sounddata_t originZ.
         * @member {number} originZ
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originZ = 0;
        /**
         * sounddata_t volume.
         * @member {number} volume
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.volume = 0;
        /**
         * sounddata_t delayValue.
         * @member {number} delayValue
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.delayValue = 0;
        /**
         * sounddata_t sequenceNumber.
         * @member {number} sequenceNumber
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.sequenceNumber = 0;
        /**
         * sounddata_t entityIndex.
         * @member {number} entityIndex
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.entityIndex = 0;
        /**
         * sounddata_t channel.
         * @member {number} channel
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.channel = 0;
        /**
         * sounddata_t pitch.
         * @member {number} pitch
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.pitch = 0;
        /**
         * sounddata_t flags.
         * @member {number} flags
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.flags = 0;
        /**
         * sounddata_t soundNum.
         * @member {number} soundNum
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundNum = 0;
        /**
         * sounddata_t soundNumHandle.
         * @member {number} soundNumHandle
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundNumHandle = 0;
        /**
         * sounddata_t speakerEntity.
         * @member {number} speakerEntity
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.speakerEntity = 0;
        /**
         * sounddata_t randomSeed.
         * @member {number} randomSeed
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.randomSeed = 0;
        /**
         * sounddata_t soundLevel.
         * @member {number} soundLevel
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundLevel = 0;
        /**
         * sounddata_t isSentence.
         * @member {boolean} isSentence
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.isSentence = false;
        /**
         * sounddata_t isAmbient.
         * @member {boolean} isAmbient
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.isAmbient = false;
        /**
         * Decodes a sounddata_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        sounddata_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.originX = reader.sint32();
                        break;
                    case 2:
                        message.originY = reader.sint32();
                        break;
                    case 3:
                        message.originZ = reader.sint32();
                        break;
                    case 4:
                        message.volume = reader.uint32();
                        break;
                    case 5:
                        message.delayValue = reader.float();
                        break;
                    case 6:
                        message.sequenceNumber = reader.int32();
                        break;
                    case 7:
                        message.entityIndex = reader.int32();
                        break;
                    case 8:
                        message.channel = reader.int32();
                        break;
                    case 9:
                        message.pitch = reader.int32();
                        break;
                    case 10:
                        message.flags = reader.int32();
                        break;
                    case 11:
                        message.soundNum = reader.uint32();
                        break;
                    case 12:
                        message.soundNumHandle = reader.fixed32();
                        break;
                    case 13:
                        message.speakerEntity = reader.int32();
                        break;
                    case 14:
                        message.randomSeed = reader.int32();
                        break;
                    case 15:
                        message.soundLevel = reader.int32();
                        break;
                    case 16:
                        message.isSentence = reader.bool();
                        break;
                    case 17:
                        message.isAmbient = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return sounddata_t;
    })();
    return CSVCMsg_Sounds;
})());
exports.CSVCMsg_EntityMsg = ($root.CSVCMsg_EntityMsg = (() => {
    /**
     * Properties of a CSVCMsg_EntityMsg.
     * @exports ICSVCMsg_EntityMsg
     * @interface ICSVCMsg_EntityMsg
     * @property {number|null} [entIndex] CSVCMsg_EntityMsg entIndex
     * @property {number|null} [classId] CSVCMsg_EntityMsg classId
     * @property {Uint8Array|null} [entData] CSVCMsg_EntityMsg entData
     */
    /**
     * Constructs a new CSVCMsg_EntityMsg.
     * @exports CSVCMsg_EntityMsg
     * @classdesc Represents a CSVCMsg_EntityMsg.
     * @implements ICSVCMsg_EntityMsg
     * @constructor
     * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set
     */
    function CSVCMsg_EntityMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_EntityMsg entIndex.
     * @member {number} entIndex
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.entIndex = 0;
    /**
     * CSVCMsg_EntityMsg classId.
     * @member {number} classId
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.classId = 0;
    /**
     * CSVCMsg_EntityMsg entData.
     * @member {Uint8Array} entData
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.entData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_EntityMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_EntityMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EntityMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIndex = reader.int32();
                    break;
                case 2:
                    message.classId = reader.int32();
                    break;
                case 3:
                    message.entData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_EntityMsg;
})());
exports.CSVCMsg_CmdKeyValues = ($root.CSVCMsg_CmdKeyValues = (() => {
    /**
     * Properties of a CSVCMsg_CmdKeyValues.
     * @exports ICSVCMsg_CmdKeyValues
     * @interface ICSVCMsg_CmdKeyValues
     * @property {Uint8Array|null} [keyvalues] CSVCMsg_CmdKeyValues keyvalues
     */
    /**
     * Constructs a new CSVCMsg_CmdKeyValues.
     * @exports CSVCMsg_CmdKeyValues
     * @classdesc Represents a CSVCMsg_CmdKeyValues.
     * @implements ICSVCMsg_CmdKeyValues
     * @constructor
     * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
     */
    function CSVCMsg_CmdKeyValues(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CmdKeyValues keyvalues.
     * @member {Uint8Array} keyvalues
     * @memberof CSVCMsg_CmdKeyValues
     * @instance
     */
    CSVCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CmdKeyValues
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CmdKeyValues;
})());
exports.CSVCMsg_EncryptedData = ($root.CSVCMsg_EncryptedData = (() => {
    /**
     * Properties of a CSVCMsg_EncryptedData.
     * @exports ICSVCMsg_EncryptedData
     * @interface ICSVCMsg_EncryptedData
     * @property {Uint8Array|null} [encrypted] CSVCMsg_EncryptedData encrypted
     * @property {number|null} [keyType] CSVCMsg_EncryptedData keyType
     */
    /**
     * Constructs a new CSVCMsg_EncryptedData.
     * @exports CSVCMsg_EncryptedData
     * @classdesc Represents a CSVCMsg_EncryptedData.
     * @implements ICSVCMsg_EncryptedData
     * @constructor
     * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set
     */
    function CSVCMsg_EncryptedData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_EncryptedData encrypted.
     * @member {Uint8Array} encrypted
     * @memberof CSVCMsg_EncryptedData
     * @instance
     */
    CSVCMsg_EncryptedData.prototype.encrypted = $util.newBuffer([]);
    /**
     * CSVCMsg_EncryptedData keyType.
     * @member {number} keyType
     * @memberof CSVCMsg_EncryptedData
     * @instance
     */
    CSVCMsg_EncryptedData.prototype.keyType = 0;
    /**
     * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_EncryptedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_EncryptedData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EncryptedData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encrypted = reader.bytes();
                    break;
                case 2:
                    message.keyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_EncryptedData;
})());
exports.CSVCMsg_HltvReplay = ($root.CSVCMsg_HltvReplay = (() => {
    /**
     * Properties of a CSVCMsg_HltvReplay.
     * @exports ICSVCMsg_HltvReplay
     * @interface ICSVCMsg_HltvReplay
     * @property {number|null} [delay] CSVCMsg_HltvReplay delay
     * @property {number|null} [primaryTarget] CSVCMsg_HltvReplay primaryTarget
     * @property {number|null} [replayStopAt] CSVCMsg_HltvReplay replayStopAt
     * @property {number|null} [replayStartAt] CSVCMsg_HltvReplay replayStartAt
     * @property {number|null} [replaySlowdownBegin] CSVCMsg_HltvReplay replaySlowdownBegin
     * @property {number|null} [replaySlowdownEnd] CSVCMsg_HltvReplay replaySlowdownEnd
     * @property {number|null} [replaySlowdownRate] CSVCMsg_HltvReplay replaySlowdownRate
     */
    /**
     * Constructs a new CSVCMsg_HltvReplay.
     * @exports CSVCMsg_HltvReplay
     * @classdesc Represents a CSVCMsg_HltvReplay.
     * @implements ICSVCMsg_HltvReplay
     * @constructor
     * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
     */
    function CSVCMsg_HltvReplay(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_HltvReplay delay.
     * @member {number} delay
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.delay = 0;
    /**
     * CSVCMsg_HltvReplay primaryTarget.
     * @member {number} primaryTarget
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.primaryTarget = 0;
    /**
     * CSVCMsg_HltvReplay replayStopAt.
     * @member {number} replayStopAt
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replayStopAt = 0;
    /**
     * CSVCMsg_HltvReplay replayStartAt.
     * @member {number} replayStartAt
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replayStartAt = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownBegin.
     * @member {number} replaySlowdownBegin
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownBegin = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownEnd.
     * @member {number} replaySlowdownEnd
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownEnd = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownRate.
     * @member {number} replaySlowdownRate
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownRate = 0;
    /**
     * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_HltvReplay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_HltvReplay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvReplay();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delay = reader.int32();
                    break;
                case 2:
                    message.primaryTarget = reader.int32();
                    break;
                case 3:
                    message.replayStopAt = reader.int32();
                    break;
                case 4:
                    message.replayStartAt = reader.int32();
                    break;
                case 5:
                    message.replaySlowdownBegin = reader.int32();
                    break;
                case 6:
                    message.replaySlowdownEnd = reader.int32();
                    break;
                case 7:
                    message.replaySlowdownRate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_HltvReplay;
})());
exports.CCLCMsg_HltvReplay = ($root.CCLCMsg_HltvReplay = (() => {
    /**
     * Properties of a CCLCMsg_HltvReplay.
     * @exports ICCLCMsg_HltvReplay
     * @interface ICCLCMsg_HltvReplay
     * @property {number|null} [request] CCLCMsg_HltvReplay request
     * @property {number|null} [slowdownLength] CCLCMsg_HltvReplay slowdownLength
     * @property {number|null} [slowdownRate] CCLCMsg_HltvReplay slowdownRate
     * @property {number|null} [primaryTargetEntIndex] CCLCMsg_HltvReplay primaryTargetEntIndex
     * @property {number|null} [eventTime] CCLCMsg_HltvReplay eventTime
     */
    /**
     * Constructs a new CCLCMsg_HltvReplay.
     * @exports CCLCMsg_HltvReplay
     * @classdesc Represents a CCLCMsg_HltvReplay.
     * @implements ICCLCMsg_HltvReplay
     * @constructor
     * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
     */
    function CCLCMsg_HltvReplay(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_HltvReplay request.
     * @member {number} request
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.request = 0;
    /**
     * CCLCMsg_HltvReplay slowdownLength.
     * @member {number} slowdownLength
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.slowdownLength = 0;
    /**
     * CCLCMsg_HltvReplay slowdownRate.
     * @member {number} slowdownRate
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.slowdownRate = 0;
    /**
     * CCLCMsg_HltvReplay primaryTargetEntIndex.
     * @member {number} primaryTargetEntIndex
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.primaryTargetEntIndex = 0;
    /**
     * CCLCMsg_HltvReplay eventTime.
     * @member {number} eventTime
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.eventTime = 0;
    /**
     * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_HltvReplay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_HltvReplay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvReplay();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.request = reader.int32();
                    break;
                case 2:
                    message.slowdownLength = reader.float();
                    break;
                case 3:
                    message.slowdownRate = reader.float();
                    break;
                case 4:
                    message.primaryTargetEntIndex = reader.int32();
                    break;
                case 5:
                    message.eventTime = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_HltvReplay;
})());
/**
 * ECsgoGCMsg enum.
 * @exports ECsgoGCMsg
 * @enum {string}
 * @property {number} k_EMsgGCCStrike15_v2_Base=9100 k_EMsgGCCStrike15_v2_Base value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStart=9101 k_EMsgGCCStrike15_v2_MatchmakingStart value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStop=9102 k_EMsgGCCStrike15_v2_MatchmakingStop value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing=9103 k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=9104 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=9105 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse=9106 k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=9107 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats=9108 k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello=9109 k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello=9110 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd=9111 k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=9112 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick=9113 k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=9114 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats=9115 k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=9116 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=9117 k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty=9118 k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty value
 * @property {number} k_EMsgGCCStrike15_v2_ClientReportPlayer=9119 k_EMsgGCCStrike15_v2_ClientReportPlayer value
 * @property {number} k_EMsgGCCStrike15_v2_ClientReportServer=9120 k_EMsgGCCStrike15_v2_ClientReportServer value
 * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayer=9121 k_EMsgGCCStrike15_v2_ClientCommendPlayer value
 * @property {number} k_EMsgGCCStrike15_v2_ClientReportResponse=9122 k_EMsgGCCStrike15_v2_ClientReportResponse value
 * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery=9123 k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery value
 * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse=9124 k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse value
 * @property {number} k_EMsgGCCStrike15_v2_WatchInfoUsers=9126 k_EMsgGCCStrike15_v2_WatchInfoUsers value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile=9127 k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile value
 * @property {number} k_EMsgGCCStrike15_v2_PlayersProfile=9128 k_EMsgGCCStrike15_v2_PlayersProfile value
 * @property {number} k_EMsgGCCStrike15_v2_SetMyMedalsInfo=9129 k_EMsgGCCStrike15_v2_SetMyMedalsInfo value
 * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=9131 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=9132 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment value
 * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=9133 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTextMsg=9134 k_EMsgGCCStrike15_v2_GC2ClientTextMsg value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCTextMsg=9135 k_EMsgGCCStrike15_v2_Client2GCTextMsg value
 * @property {number} k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops=9136 k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops value
 * @property {number} k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification=9137 k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2=9138 k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 value
 * @property {number} k_EMsgGCCStrike15_v2_MatchList=9139 k_EMsgGCCStrike15_v2_MatchList value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=9140 k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames=9141 k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate=9142 k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo=9144 k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo value
 * @property {number} k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=9145 k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames=9146 k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo=9147 k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo value
 * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest=9148 k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest value
 * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse=9149 k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse value
 * @property {number} k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo=9150 k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo value
 * @property {number} k_EMsgGCToGCReloadVersions=9151 k_EMsgGCToGCReloadVersions value
 * @property {number} k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote=9152 k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote value
 * @property {number} k_EMsgGCCStrike15_v2_Server2GCClientValidate=9153 k_EMsgGCCStrike15_v2_Server2GCClientValidate value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=9154 k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser value
 * @property {number} k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=9155 k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=9156 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=9157 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse value
 * @property {number} k_EMsgGCCStrike15_v2_AccountPrivacySettings=9158 k_EMsgGCCStrike15_v2_AccountPrivacySettings value
 * @property {number} k_EMsgGCCStrike15_v2_SetMyActivityInfo=9159 k_EMsgGCCStrike15_v2_SetMyActivityInfo value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions=9160 k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions=9161 k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions value
 * @property {number} k_EMsgGCCStrike15_v2_DraftSummary=9162 k_EMsgGCCStrike15_v2_DraftSummary value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData=9163 k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinServerData=9164 k_EMsgGCCStrike15_v2_ClientRequestJoinServerData value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestNewMission=9165 k_EMsgGCCStrike15_v2_ClientRequestNewMission value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded=9166 k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo=9167 k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo value
 * @property {number} k_EMsgGC_GlobalGame_Subscribe=9168 k_EMsgGC_GlobalGame_Subscribe value
 * @property {number} k_EMsgGC_GlobalGame_Unsubscribe=9169 k_EMsgGC_GlobalGame_Unsubscribe value
 * @property {number} k_EMsgGC_GlobalGame_Play=9170 k_EMsgGC_GlobalGame_Play value
 * @property {number} k_EMsgGCCStrike15_v2_AcknowledgePenalty=9171 k_EMsgGCCStrike15_v2_AcknowledgePenalty value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=9172 k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ClientGlobalStats=9173 k_EMsgGCCStrike15_v2_GC2ClientGlobalStats value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCStreamUnlock=9174 k_EMsgGCCStrike15_v2_Client2GCStreamUnlock value
 * @property {number} k_EMsgGCCStrike15_v2_FantasyRequestClientData=9175 k_EMsgGCCStrike15_v2_FantasyRequestClientData value
 * @property {number} k_EMsgGCCStrike15_v2_FantasyUpdateClientData=9176 k_EMsgGCCStrike15_v2_FantasyUpdateClientData value
 */
$root.ECsgoGCMsg = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[9100] = "k_EMsgGCCStrike15_v2_Base")] = 9100;
    values[(valuesById[9101] = "k_EMsgGCCStrike15_v2_MatchmakingStart")] = 9101;
    values[(valuesById[9102] = "k_EMsgGCCStrike15_v2_MatchmakingStop")] = 9102;
    values[(valuesById[9103] = "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing")] = 9103;
    values[(valuesById[9104] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate")] = 9104;
    values[(valuesById[9105] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve")] = 9105;
    values[(valuesById[9106] =
        "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse")] = 9106;
    values[(valuesById[9107] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve")] = 9107;
    values[(valuesById[9108] = "k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats")] = 9108;
    values[(valuesById[9109] = "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello")] = 9109;
    values[(valuesById[9110] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello")] = 9110;
    values[(valuesById[9111] = "k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd")] = 9111;
    values[(valuesById[9112] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon")] = 9112;
    values[(valuesById[9113] = "k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick")] = 9113;
    values[(valuesById[9114] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm")] = 9114;
    values[(valuesById[9115] = "k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats")] = 9115;
    values[(valuesById[9116] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate")] = 9116;
    values[(valuesById[9117] = "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate")] = 9117;
    values[(valuesById[9118] = "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty")] = 9118;
    values[(valuesById[9119] = "k_EMsgGCCStrike15_v2_ClientReportPlayer")] = 9119;
    values[(valuesById[9120] = "k_EMsgGCCStrike15_v2_ClientReportServer")] = 9120;
    values[(valuesById[9121] = "k_EMsgGCCStrike15_v2_ClientCommendPlayer")] = 9121;
    values[(valuesById[9122] = "k_EMsgGCCStrike15_v2_ClientReportResponse")] = 9122;
    values[(valuesById[9123] = "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery")] = 9123;
    values[(valuesById[9124] = "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse")] = 9124;
    values[(valuesById[9126] = "k_EMsgGCCStrike15_v2_WatchInfoUsers")] = 9126;
    values[(valuesById[9127] = "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile")] = 9127;
    values[(valuesById[9128] = "k_EMsgGCCStrike15_v2_PlayersProfile")] = 9128;
    values[(valuesById[9129] = "k_EMsgGCCStrike15_v2_SetMyMedalsInfo")] = 9129;
    values[(valuesById[9131] = "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate")] = 9131;
    values[(valuesById[9132] = "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment")] = 9132;
    values[(valuesById[9133] = "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus")] = 9133;
    values[(valuesById[9134] = "k_EMsgGCCStrike15_v2_GC2ClientTextMsg")] = 9134;
    values[(valuesById[9135] = "k_EMsgGCCStrike15_v2_Client2GCTextMsg")] = 9135;
    values[(valuesById[9136] = "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops")] = 9136;
    values[(valuesById[9137] = "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification")] = 9137;
    values[(valuesById[9138] = "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2")] = 9138;
    values[(valuesById[9139] = "k_EMsgGCCStrike15_v2_MatchList")] = 9139;
    values[(valuesById[9140] = "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames")] = 9140;
    values[(valuesById[9141] = "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames")] = 9141;
    values[(valuesById[9142] = "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate")] = 9142;
    values[(valuesById[9144] = "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo")] = 9144;
    values[(valuesById[9145] =
        "k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification")] = 9145;
    values[(valuesById[9146] = "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames")] = 9146;
    values[(valuesById[9147] = "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo")] = 9147;
    values[(valuesById[9148] = "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest")] = 9148;
    values[(valuesById[9149] = "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse")] = 9149;
    values[(valuesById[9150] = "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo")] = 9150;
    values[(valuesById[9151] = "k_EMsgGCToGCReloadVersions")] = 9151;
    values[(valuesById[9152] = "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote")] = 9152;
    values[(valuesById[9153] = "k_EMsgGCCStrike15_v2_Server2GCClientValidate")] = 9153;
    values[(valuesById[9154] = "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser")] = 9154;
    values[(valuesById[9155] =
        "k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure")] = 9155;
    values[(valuesById[9156] =
        "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest")] = 9156;
    values[(valuesById[9157] =
        "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse")] = 9157;
    values[(valuesById[9158] = "k_EMsgGCCStrike15_v2_AccountPrivacySettings")] = 9158;
    values[(valuesById[9159] = "k_EMsgGCCStrike15_v2_SetMyActivityInfo")] = 9159;
    values[(valuesById[9160] =
        "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions")] = 9160;
    values[(valuesById[9161] =
        "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions")] = 9161;
    values[(valuesById[9162] = "k_EMsgGCCStrike15_v2_DraftSummary")] = 9162;
    values[(valuesById[9163] = "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData")] = 9163;
    values[(valuesById[9164] = "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData")] = 9164;
    values[(valuesById[9165] = "k_EMsgGCCStrike15_v2_ClientRequestNewMission")] = 9165;
    values[(valuesById[9166] = "k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded")] = 9166;
    values[(valuesById[9167] = "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo")] = 9167;
    values[(valuesById[9168] = "k_EMsgGC_GlobalGame_Subscribe")] = 9168;
    values[(valuesById[9169] = "k_EMsgGC_GlobalGame_Unsubscribe")] = 9169;
    values[(valuesById[9170] = "k_EMsgGC_GlobalGame_Play")] = 9170;
    values[(valuesById[9171] = "k_EMsgGCCStrike15_v2_AcknowledgePenalty")] = 9171;
    values[(valuesById[9172] = "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin")] = 9172;
    values[(valuesById[9173] = "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats")] = 9173;
    values[(valuesById[9174] = "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock")] = 9174;
    values[(valuesById[9175] = "k_EMsgGCCStrike15_v2_FantasyRequestClientData")] = 9175;
    values[(valuesById[9176] = "k_EMsgGCCStrike15_v2_FantasyUpdateClientData")] = 9176;
    return values;
})();
exports.GameServerPing = ($root.GameServerPing = (() => {
    /**
     * Properties of a GameServerPing.
     * @exports IGameServerPing
     * @interface IGameServerPing
     * @property {number|Long|null} [gameserverId] GameServerPing gameserverId
     * @property {number|null} [ping] GameServerPing ping
     * @property {number|null} [ip] GameServerPing ip
     * @property {number|null} [port] GameServerPing port
     * @property {number|null} [instances] GameServerPing instances
     */
    /**
     * Constructs a new GameServerPing.
     * @exports GameServerPing
     * @classdesc Represents a GameServerPing.
     * @implements IGameServerPing
     * @constructor
     * @param {IGameServerPing=} [properties] Properties to set
     */
    function GameServerPing(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * GameServerPing gameserverId.
     * @member {number|Long} gameserverId
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.gameserverId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * GameServerPing ping.
     * @member {number} ping
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.ping = 0;
    /**
     * GameServerPing ip.
     * @member {number} ip
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.ip = 0;
    /**
     * GameServerPing port.
     * @member {number} port
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.port = 0;
    /**
     * GameServerPing instances.
     * @member {number} instances
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.instances = 0;
    /**
     * Decodes a GameServerPing message from the specified reader or buffer.
     * @function decode
     * @memberof GameServerPing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GameServerPing} GameServerPing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GameServerPing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GameServerPing();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gameserverId = reader.uint64();
                    break;
                case 2:
                    message.ping = reader.int32();
                    break;
                case 3:
                    message.ip = reader.uint32();
                    break;
                case 4:
                    message.port = reader.uint32();
                    break;
                case 5:
                    message.instances = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return GameServerPing;
})());
exports.DetailedSearchStatistic = ($root.DetailedSearchStatistic = (() => {
    /**
     * Properties of a DetailedSearchStatistic.
     * @exports IDetailedSearchStatistic
     * @interface IDetailedSearchStatistic
     * @property {number|null} [gameType] DetailedSearchStatistic gameType
     * @property {number|null} [searchTimeAvg] DetailedSearchStatistic searchTimeAvg
     * @property {number|null} [playersSearching] DetailedSearchStatistic playersSearching
     */
    /**
     * Constructs a new DetailedSearchStatistic.
     * @exports DetailedSearchStatistic
     * @classdesc Represents a DetailedSearchStatistic.
     * @implements IDetailedSearchStatistic
     * @constructor
     * @param {IDetailedSearchStatistic=} [properties] Properties to set
     */
    function DetailedSearchStatistic(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * DetailedSearchStatistic gameType.
     * @member {number} gameType
     * @memberof DetailedSearchStatistic
     * @instance
     */
    DetailedSearchStatistic.prototype.gameType = 0;
    /**
     * DetailedSearchStatistic searchTimeAvg.
     * @member {number} searchTimeAvg
     * @memberof DetailedSearchStatistic
     * @instance
     */
    DetailedSearchStatistic.prototype.searchTimeAvg = 0;
    /**
     * DetailedSearchStatistic playersSearching.
     * @member {number} playersSearching
     * @memberof DetailedSearchStatistic
     * @instance
     */
    DetailedSearchStatistic.prototype.playersSearching = 0;
    /**
     * Decodes a DetailedSearchStatistic message from the specified reader or buffer.
     * @function decode
     * @memberof DetailedSearchStatistic
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DetailedSearchStatistic} DetailedSearchStatistic
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DetailedSearchStatistic.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DetailedSearchStatistic();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                case 2:
                    message.searchTimeAvg = reader.uint32();
                    break;
                case 4:
                    message.playersSearching = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return DetailedSearchStatistic;
})());
exports.TournamentPlayer = ($root.TournamentPlayer = (() => {
    /**
     * Properties of a TournamentPlayer.
     * @exports ITournamentPlayer
     * @interface ITournamentPlayer
     * @property {number|null} [accountId] TournamentPlayer accountId
     * @property {string|null} [playerNick] TournamentPlayer playerNick
     * @property {string|null} [playerName] TournamentPlayer playerName
     * @property {number|null} [playerDob] TournamentPlayer playerDob
     * @property {string|null} [playerFlag] TournamentPlayer playerFlag
     * @property {string|null} [playerLocation] TournamentPlayer playerLocation
     * @property {string|null} [playerDesc] TournamentPlayer playerDesc
     */
    /**
     * Constructs a new TournamentPlayer.
     * @exports TournamentPlayer
     * @classdesc Represents a TournamentPlayer.
     * @implements ITournamentPlayer
     * @constructor
     * @param {ITournamentPlayer=} [properties] Properties to set
     */
    function TournamentPlayer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentPlayer accountId.
     * @member {number} accountId
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.accountId = 0;
    /**
     * TournamentPlayer playerNick.
     * @member {string} playerNick
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerNick = "";
    /**
     * TournamentPlayer playerName.
     * @member {string} playerName
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerName = "";
    /**
     * TournamentPlayer playerDob.
     * @member {number} playerDob
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerDob = 0;
    /**
     * TournamentPlayer playerFlag.
     * @member {string} playerFlag
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerFlag = "";
    /**
     * TournamentPlayer playerLocation.
     * @member {string} playerLocation
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerLocation = "";
    /**
     * TournamentPlayer playerDesc.
     * @member {string} playerDesc
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerDesc = "";
    /**
     * Decodes a TournamentPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentPlayer} TournamentPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentPlayer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.playerNick = reader.string();
                    break;
                case 3:
                    message.playerName = reader.string();
                    break;
                case 4:
                    message.playerDob = reader.uint32();
                    break;
                case 5:
                    message.playerFlag = reader.string();
                    break;
                case 6:
                    message.playerLocation = reader.string();
                    break;
                case 7:
                    message.playerDesc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentPlayer;
})());
exports.TournamentTeam = ($root.TournamentTeam = (() => {
    /**
     * Properties of a TournamentTeam.
     * @exports ITournamentTeam
     * @interface ITournamentTeam
     * @property {number|null} [teamId] TournamentTeam teamId
     * @property {string|null} [teamTag] TournamentTeam teamTag
     * @property {string|null} [teamFlag] TournamentTeam teamFlag
     * @property {string|null} [teamName] TournamentTeam teamName
     * @property {Array.<ITournamentPlayer>|null} [players] TournamentTeam players
     */
    /**
     * Constructs a new TournamentTeam.
     * @exports TournamentTeam
     * @classdesc Represents a TournamentTeam.
     * @implements ITournamentTeam
     * @constructor
     * @param {ITournamentTeam=} [properties] Properties to set
     */
    function TournamentTeam(properties) {
        this.players = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentTeam teamId.
     * @member {number} teamId
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamId = 0;
    /**
     * TournamentTeam teamTag.
     * @member {string} teamTag
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamTag = "";
    /**
     * TournamentTeam teamFlag.
     * @member {string} teamFlag
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamFlag = "";
    /**
     * TournamentTeam teamName.
     * @member {string} teamName
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamName = "";
    /**
     * TournamentTeam players.
     * @member {Array.<ITournamentPlayer>} players
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.players = $util.emptyArray;
    /**
     * Decodes a TournamentTeam message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentTeam} TournamentTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentTeam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentTeam();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.teamId = reader.int32();
                    break;
                case 2:
                    message.teamTag = reader.string();
                    break;
                case 3:
                    message.teamFlag = reader.string();
                    break;
                case 4:
                    message.teamName = reader.string();
                    break;
                case 5:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.TournamentPlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentTeam;
})());
exports.TournamentEvent = ($root.TournamentEvent = (() => {
    /**
     * Properties of a TournamentEvent.
     * @exports ITournamentEvent
     * @interface ITournamentEvent
     * @property {number|null} [eventId] TournamentEvent eventId
     * @property {string|null} [eventTag] TournamentEvent eventTag
     * @property {string|null} [eventName] TournamentEvent eventName
     * @property {number|null} [eventTimeStart] TournamentEvent eventTimeStart
     * @property {number|null} [eventTimeEnd] TournamentEvent eventTimeEnd
     * @property {number|null} [eventPublic] TournamentEvent eventPublic
     * @property {number|null} [eventStageId] TournamentEvent eventStageId
     * @property {string|null} [eventStageName] TournamentEvent eventStageName
     * @property {number|null} [activeSectionId] TournamentEvent activeSectionId
     */
    /**
     * Constructs a new TournamentEvent.
     * @exports TournamentEvent
     * @classdesc Represents a TournamentEvent.
     * @implements ITournamentEvent
     * @constructor
     * @param {ITournamentEvent=} [properties] Properties to set
     */
    function TournamentEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentEvent eventId.
     * @member {number} eventId
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventId = 0;
    /**
     * TournamentEvent eventTag.
     * @member {string} eventTag
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventTag = "";
    /**
     * TournamentEvent eventName.
     * @member {string} eventName
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventName = "";
    /**
     * TournamentEvent eventTimeStart.
     * @member {number} eventTimeStart
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventTimeStart = 0;
    /**
     * TournamentEvent eventTimeEnd.
     * @member {number} eventTimeEnd
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventTimeEnd = 0;
    /**
     * TournamentEvent eventPublic.
     * @member {number} eventPublic
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventPublic = 0;
    /**
     * TournamentEvent eventStageId.
     * @member {number} eventStageId
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventStageId = 0;
    /**
     * TournamentEvent eventStageName.
     * @member {string} eventStageName
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventStageName = "";
    /**
     * TournamentEvent activeSectionId.
     * @member {number} activeSectionId
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.activeSectionId = 0;
    /**
     * Decodes a TournamentEvent message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentEvent} TournamentEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                case 2:
                    message.eventTag = reader.string();
                    break;
                case 3:
                    message.eventName = reader.string();
                    break;
                case 4:
                    message.eventTimeStart = reader.uint32();
                    break;
                case 5:
                    message.eventTimeEnd = reader.uint32();
                    break;
                case 6:
                    message.eventPublic = reader.int32();
                    break;
                case 7:
                    message.eventStageId = reader.int32();
                    break;
                case 8:
                    message.eventStageName = reader.string();
                    break;
                case 9:
                    message.activeSectionId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentEvent;
})());
exports.GlobalStatistics = ($root.GlobalStatistics = (() => {
    /**
     * Properties of a GlobalStatistics.
     * @exports IGlobalStatistics
     * @interface IGlobalStatistics
     * @property {number|null} [playersOnline] GlobalStatistics playersOnline
     * @property {number|null} [serversOnline] GlobalStatistics serversOnline
     * @property {number|null} [playersSearching] GlobalStatistics playersSearching
     * @property {number|null} [serversAvailable] GlobalStatistics serversAvailable
     * @property {number|null} [ongoingMatches] GlobalStatistics ongoingMatches
     * @property {number|null} [searchTimeAvg] GlobalStatistics searchTimeAvg
     * @property {Array.<IDetailedSearchStatistic>|null} [searchStatistics] GlobalStatistics searchStatistics
     * @property {string|null} [mainPostUrl] GlobalStatistics mainPostUrl
     * @property {number|null} [requiredAppidVersion] GlobalStatistics requiredAppidVersion
     * @property {number|null} [pricesheetVersion] GlobalStatistics pricesheetVersion
     * @property {number|null} [twitchStreamsVersion] GlobalStatistics twitchStreamsVersion
     * @property {number|null} [activeTournamentEventid] GlobalStatistics activeTournamentEventid
     * @property {number|null} [activeSurveyId] GlobalStatistics activeSurveyId
     */
    /**
     * Constructs a new GlobalStatistics.
     * @exports GlobalStatistics
     * @classdesc Represents a GlobalStatistics.
     * @implements IGlobalStatistics
     * @constructor
     * @param {IGlobalStatistics=} [properties] Properties to set
     */
    function GlobalStatistics(properties) {
        this.searchStatistics = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * GlobalStatistics playersOnline.
     * @member {number} playersOnline
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.playersOnline = 0;
    /**
     * GlobalStatistics serversOnline.
     * @member {number} serversOnline
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.serversOnline = 0;
    /**
     * GlobalStatistics playersSearching.
     * @member {number} playersSearching
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.playersSearching = 0;
    /**
     * GlobalStatistics serversAvailable.
     * @member {number} serversAvailable
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.serversAvailable = 0;
    /**
     * GlobalStatistics ongoingMatches.
     * @member {number} ongoingMatches
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.ongoingMatches = 0;
    /**
     * GlobalStatistics searchTimeAvg.
     * @member {number} searchTimeAvg
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.searchTimeAvg = 0;
    /**
     * GlobalStatistics searchStatistics.
     * @member {Array.<IDetailedSearchStatistic>} searchStatistics
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.searchStatistics = $util.emptyArray;
    /**
     * GlobalStatistics mainPostUrl.
     * @member {string} mainPostUrl
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.mainPostUrl = "";
    /**
     * GlobalStatistics requiredAppidVersion.
     * @member {number} requiredAppidVersion
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.requiredAppidVersion = 0;
    /**
     * GlobalStatistics pricesheetVersion.
     * @member {number} pricesheetVersion
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.pricesheetVersion = 0;
    /**
     * GlobalStatistics twitchStreamsVersion.
     * @member {number} twitchStreamsVersion
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.twitchStreamsVersion = 0;
    /**
     * GlobalStatistics activeTournamentEventid.
     * @member {number} activeTournamentEventid
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.activeTournamentEventid = 0;
    /**
     * GlobalStatistics activeSurveyId.
     * @member {number} activeSurveyId
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.activeSurveyId = 0;
    /**
     * Decodes a GlobalStatistics message from the specified reader or buffer.
     * @function decode
     * @memberof GlobalStatistics
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GlobalStatistics} GlobalStatistics
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GlobalStatistics.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GlobalStatistics();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playersOnline = reader.uint32();
                    break;
                case 2:
                    message.serversOnline = reader.uint32();
                    break;
                case 3:
                    message.playersSearching = reader.uint32();
                    break;
                case 4:
                    message.serversAvailable = reader.uint32();
                    break;
                case 5:
                    message.ongoingMatches = reader.uint32();
                    break;
                case 6:
                    message.searchTimeAvg = reader.uint32();
                    break;
                case 7:
                    if (!(message.searchStatistics && message.searchStatistics.length))
                        message.searchStatistics = [];
                    message.searchStatistics.push($root.DetailedSearchStatistic.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.mainPostUrl = reader.string();
                    break;
                case 9:
                    message.requiredAppidVersion = reader.uint32();
                    break;
                case 10:
                    message.pricesheetVersion = reader.uint32();
                    break;
                case 11:
                    message.twitchStreamsVersion = reader.uint32();
                    break;
                case 12:
                    message.activeTournamentEventid = reader.uint32();
                    break;
                case 13:
                    message.activeSurveyId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return GlobalStatistics;
})());
exports.OperationalStatisticDescription = ($root.OperationalStatisticDescription = (() => {
    /**
     * Properties of an OperationalStatisticDescription.
     * @exports IOperationalStatisticDescription
     * @interface IOperationalStatisticDescription
     * @property {string|null} [name] OperationalStatisticDescription name
     * @property {number|null} [idkey] OperationalStatisticDescription idkey
     */
    /**
     * Constructs a new OperationalStatisticDescription.
     * @exports OperationalStatisticDescription
     * @classdesc Represents an OperationalStatisticDescription.
     * @implements IOperationalStatisticDescription
     * @constructor
     * @param {IOperationalStatisticDescription=} [properties] Properties to set
     */
    function OperationalStatisticDescription(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * OperationalStatisticDescription name.
     * @member {string} name
     * @memberof OperationalStatisticDescription
     * @instance
     */
    OperationalStatisticDescription.prototype.name = "";
    /**
     * OperationalStatisticDescription idkey.
     * @member {number} idkey
     * @memberof OperationalStatisticDescription
     * @instance
     */
    OperationalStatisticDescription.prototype.idkey = 0;
    /**
     * Decodes an OperationalStatisticDescription message from the specified reader or buffer.
     * @function decode
     * @memberof OperationalStatisticDescription
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OperationalStatisticDescription} OperationalStatisticDescription
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OperationalStatisticDescription.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticDescription();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.idkey = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return OperationalStatisticDescription;
})());
exports.OperationalStatisticElement = ($root.OperationalStatisticElement = (() => {
    /**
     * Properties of an OperationalStatisticElement.
     * @exports IOperationalStatisticElement
     * @interface IOperationalStatisticElement
     * @property {number|null} [idkey] OperationalStatisticElement idkey
     * @property {Array.<number>|null} [values] OperationalStatisticElement values
     */
    /**
     * Constructs a new OperationalStatisticElement.
     * @exports OperationalStatisticElement
     * @classdesc Represents an OperationalStatisticElement.
     * @implements IOperationalStatisticElement
     * @constructor
     * @param {IOperationalStatisticElement=} [properties] Properties to set
     */
    function OperationalStatisticElement(properties) {
        this.values = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * OperationalStatisticElement idkey.
     * @member {number} idkey
     * @memberof OperationalStatisticElement
     * @instance
     */
    OperationalStatisticElement.prototype.idkey = 0;
    /**
     * OperationalStatisticElement values.
     * @member {Array.<number>} values
     * @memberof OperationalStatisticElement
     * @instance
     */
    OperationalStatisticElement.prototype.values = $util.emptyArray;
    /**
     * Decodes an OperationalStatisticElement message from the specified reader or buffer.
     * @function decode
     * @memberof OperationalStatisticElement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OperationalStatisticElement} OperationalStatisticElement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OperationalStatisticElement.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticElement();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.idkey = reader.uint32();
                    break;
                case 2:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.values.push(reader.int32());
                    }
                    else
                        message.values.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return OperationalStatisticElement;
})());
exports.OperationalStatisticsPacket = ($root.OperationalStatisticsPacket = (() => {
    /**
     * Properties of an OperationalStatisticsPacket.
     * @exports IOperationalStatisticsPacket
     * @interface IOperationalStatisticsPacket
     * @property {number|null} [packetid] OperationalStatisticsPacket packetid
     * @property {number|null} [mstimestamp] OperationalStatisticsPacket mstimestamp
     * @property {Array.<IOperationalStatisticElement>|null} [values] OperationalStatisticsPacket values
     */
    /**
     * Constructs a new OperationalStatisticsPacket.
     * @exports OperationalStatisticsPacket
     * @classdesc Represents an OperationalStatisticsPacket.
     * @implements IOperationalStatisticsPacket
     * @constructor
     * @param {IOperationalStatisticsPacket=} [properties] Properties to set
     */
    function OperationalStatisticsPacket(properties) {
        this.values = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * OperationalStatisticsPacket packetid.
     * @member {number} packetid
     * @memberof OperationalStatisticsPacket
     * @instance
     */
    OperationalStatisticsPacket.prototype.packetid = 0;
    /**
     * OperationalStatisticsPacket mstimestamp.
     * @member {number} mstimestamp
     * @memberof OperationalStatisticsPacket
     * @instance
     */
    OperationalStatisticsPacket.prototype.mstimestamp = 0;
    /**
     * OperationalStatisticsPacket values.
     * @member {Array.<IOperationalStatisticElement>} values
     * @memberof OperationalStatisticsPacket
     * @instance
     */
    OperationalStatisticsPacket.prototype.values = $util.emptyArray;
    /**
     * Decodes an OperationalStatisticsPacket message from the specified reader or buffer.
     * @function decode
     * @memberof OperationalStatisticsPacket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OperationalStatisticsPacket} OperationalStatisticsPacket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OperationalStatisticsPacket.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticsPacket();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.packetid = reader.int32();
                    break;
                case 2:
                    message.mstimestamp = reader.int32();
                    break;
                case 3:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    message.values.push($root.OperationalStatisticElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return OperationalStatisticsPacket;
})());
exports.PlayerRankingInfo = ($root.PlayerRankingInfo = (() => {
    /**
     * Properties of a PlayerRankingInfo.
     * @exports IPlayerRankingInfo
     * @interface IPlayerRankingInfo
     * @property {number|null} [accountId] PlayerRankingInfo accountId
     * @property {number|null} [rankId] PlayerRankingInfo rankId
     * @property {number|null} [wins] PlayerRankingInfo wins
     * @property {number|null} [rankChange] PlayerRankingInfo rankChange
     */
    /**
     * Constructs a new PlayerRankingInfo.
     * @exports PlayerRankingInfo
     * @classdesc Represents a PlayerRankingInfo.
     * @implements IPlayerRankingInfo
     * @constructor
     * @param {IPlayerRankingInfo=} [properties] Properties to set
     */
    function PlayerRankingInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerRankingInfo accountId.
     * @member {number} accountId
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.accountId = 0;
    /**
     * PlayerRankingInfo rankId.
     * @member {number} rankId
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.rankId = 0;
    /**
     * PlayerRankingInfo wins.
     * @member {number} wins
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.wins = 0;
    /**
     * PlayerRankingInfo rankChange.
     * @member {number} rankChange
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.rankChange = 0;
    /**
     * Decodes a PlayerRankingInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerRankingInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerRankingInfo} PlayerRankingInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerRankingInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerRankingInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.rankId = reader.uint32();
                    break;
                case 3:
                    message.wins = reader.uint32();
                    break;
                case 4:
                    message.rankChange = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return PlayerRankingInfo;
})());
exports.PlayerCommendationInfo = ($root.PlayerCommendationInfo = (() => {
    /**
     * Properties of a PlayerCommendationInfo.
     * @exports IPlayerCommendationInfo
     * @interface IPlayerCommendationInfo
     * @property {number|null} [cmdFriendly] PlayerCommendationInfo cmdFriendly
     * @property {number|null} [cmdTeaching] PlayerCommendationInfo cmdTeaching
     * @property {number|null} [cmdLeader] PlayerCommendationInfo cmdLeader
     */
    /**
     * Constructs a new PlayerCommendationInfo.
     * @exports PlayerCommendationInfo
     * @classdesc Represents a PlayerCommendationInfo.
     * @implements IPlayerCommendationInfo
     * @constructor
     * @param {IPlayerCommendationInfo=} [properties] Properties to set
     */
    function PlayerCommendationInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerCommendationInfo cmdFriendly.
     * @member {number} cmdFriendly
     * @memberof PlayerCommendationInfo
     * @instance
     */
    PlayerCommendationInfo.prototype.cmdFriendly = 0;
    /**
     * PlayerCommendationInfo cmdTeaching.
     * @member {number} cmdTeaching
     * @memberof PlayerCommendationInfo
     * @instance
     */
    PlayerCommendationInfo.prototype.cmdTeaching = 0;
    /**
     * PlayerCommendationInfo cmdLeader.
     * @member {number} cmdLeader
     * @memberof PlayerCommendationInfo
     * @instance
     */
    PlayerCommendationInfo.prototype.cmdLeader = 0;
    /**
     * Decodes a PlayerCommendationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerCommendationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerCommendationInfo} PlayerCommendationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerCommendationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerCommendationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cmdFriendly = reader.uint32();
                    break;
                case 2:
                    message.cmdTeaching = reader.uint32();
                    break;
                case 4:
                    message.cmdLeader = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return PlayerCommendationInfo;
})());
exports.PlayerMedalsInfo = ($root.PlayerMedalsInfo = (() => {
    /**
     * Properties of a PlayerMedalsInfo.
     * @exports IPlayerMedalsInfo
     * @interface IPlayerMedalsInfo
     * @property {number|null} [medalTeam] PlayerMedalsInfo medalTeam
     * @property {number|null} [medalCombat] PlayerMedalsInfo medalCombat
     * @property {number|null} [medalWeapon] PlayerMedalsInfo medalWeapon
     * @property {number|null} [medalGlobal] PlayerMedalsInfo medalGlobal
     * @property {number|null} [medalArms] PlayerMedalsInfo medalArms
     * @property {Array.<number>|null} [displayItemsDefidx] PlayerMedalsInfo displayItemsDefidx
     * @property {number|null} [featuredDisplayItemDefidx] PlayerMedalsInfo featuredDisplayItemDefidx
     */
    /**
     * Constructs a new PlayerMedalsInfo.
     * @exports PlayerMedalsInfo
     * @classdesc Represents a PlayerMedalsInfo.
     * @implements IPlayerMedalsInfo
     * @constructor
     * @param {IPlayerMedalsInfo=} [properties] Properties to set
     */
    function PlayerMedalsInfo(properties) {
        this.displayItemsDefidx = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerMedalsInfo medalTeam.
     * @member {number} medalTeam
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalTeam = 0;
    /**
     * PlayerMedalsInfo medalCombat.
     * @member {number} medalCombat
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalCombat = 0;
    /**
     * PlayerMedalsInfo medalWeapon.
     * @member {number} medalWeapon
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalWeapon = 0;
    /**
     * PlayerMedalsInfo medalGlobal.
     * @member {number} medalGlobal
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalGlobal = 0;
    /**
     * PlayerMedalsInfo medalArms.
     * @member {number} medalArms
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalArms = 0;
    /**
     * PlayerMedalsInfo displayItemsDefidx.
     * @member {Array.<number>} displayItemsDefidx
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.displayItemsDefidx = $util.emptyArray;
    /**
     * PlayerMedalsInfo featuredDisplayItemDefidx.
     * @member {number} featuredDisplayItemDefidx
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.featuredDisplayItemDefidx = 0;
    /**
     * Decodes a PlayerMedalsInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerMedalsInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerMedalsInfo} PlayerMedalsInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerMedalsInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerMedalsInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.medalTeam = reader.uint32();
                    break;
                case 2:
                    message.medalCombat = reader.uint32();
                    break;
                case 3:
                    message.medalWeapon = reader.uint32();
                    break;
                case 4:
                    message.medalGlobal = reader.uint32();
                    break;
                case 5:
                    message.medalArms = reader.uint32();
                    break;
                case 7:
                    if (!(message.displayItemsDefidx && message.displayItemsDefidx.length))
                        message.displayItemsDefidx = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.displayItemsDefidx.push(reader.uint32());
                    }
                    else
                        message.displayItemsDefidx.push(reader.uint32());
                    break;
                case 8:
                    message.featuredDisplayItemDefidx = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return PlayerMedalsInfo;
})());
exports.AccountActivity = ($root.AccountActivity = (() => {
    /**
     * Properties of an AccountActivity.
     * @exports IAccountActivity
     * @interface IAccountActivity
     * @property {number|null} [activity] AccountActivity activity
     * @property {number|null} [mode] AccountActivity mode
     * @property {number|null} [map] AccountActivity map
     */
    /**
     * Constructs a new AccountActivity.
     * @exports AccountActivity
     * @classdesc Represents an AccountActivity.
     * @implements IAccountActivity
     * @constructor
     * @param {IAccountActivity=} [properties] Properties to set
     */
    function AccountActivity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * AccountActivity activity.
     * @member {number} activity
     * @memberof AccountActivity
     * @instance
     */
    AccountActivity.prototype.activity = 0;
    /**
     * AccountActivity mode.
     * @member {number} mode
     * @memberof AccountActivity
     * @instance
     */
    AccountActivity.prototype.mode = 0;
    /**
     * AccountActivity map.
     * @member {number} map
     * @memberof AccountActivity
     * @instance
     */
    AccountActivity.prototype.map = 0;
    /**
     * Decodes an AccountActivity message from the specified reader or buffer.
     * @function decode
     * @memberof AccountActivity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AccountActivity} AccountActivity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AccountActivity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountActivity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.activity = reader.uint32();
                    break;
                case 2:
                    message.mode = reader.uint32();
                    break;
                case 3:
                    message.map = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return AccountActivity;
})());
exports.TournamentMatchSetup = ($root.TournamentMatchSetup = (() => {
    /**
     * Properties of a TournamentMatchSetup.
     * @exports ITournamentMatchSetup
     * @interface ITournamentMatchSetup
     * @property {number|null} [eventId] TournamentMatchSetup eventId
     * @property {number|null} [teamIdCt] TournamentMatchSetup teamIdCt
     * @property {number|null} [teamIdT] TournamentMatchSetup teamIdT
     * @property {number|null} [eventStageId] TournamentMatchSetup eventStageId
     */
    /**
     * Constructs a new TournamentMatchSetup.
     * @exports TournamentMatchSetup
     * @classdesc Represents a TournamentMatchSetup.
     * @implements ITournamentMatchSetup
     * @constructor
     * @param {ITournamentMatchSetup=} [properties] Properties to set
     */
    function TournamentMatchSetup(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentMatchSetup eventId.
     * @member {number} eventId
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.eventId = 0;
    /**
     * TournamentMatchSetup teamIdCt.
     * @member {number} teamIdCt
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.teamIdCt = 0;
    /**
     * TournamentMatchSetup teamIdT.
     * @member {number} teamIdT
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.teamIdT = 0;
    /**
     * TournamentMatchSetup eventStageId.
     * @member {number} eventStageId
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.eventStageId = 0;
    /**
     * Decodes a TournamentMatchSetup message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentMatchSetup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentMatchSetup} TournamentMatchSetup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentMatchSetup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentMatchSetup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                case 2:
                    message.teamIdCt = reader.int32();
                    break;
                case 3:
                    message.teamIdT = reader.int32();
                    break;
                case 4:
                    message.eventStageId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentMatchSetup;
})());
exports.ServerHltvInfo = ($root.ServerHltvInfo = (() => {
    /**
     * Properties of a ServerHltvInfo.
     * @exports IServerHltvInfo
     * @interface IServerHltvInfo
     * @property {number|null} [tvUdpPort] ServerHltvInfo tvUdpPort
     * @property {number|Long|null} [tvWatchKey] ServerHltvInfo tvWatchKey
     * @property {number|null} [tvSlots] ServerHltvInfo tvSlots
     * @property {number|null} [tvClients] ServerHltvInfo tvClients
     * @property {number|null} [tvProxies] ServerHltvInfo tvProxies
     * @property {number|null} [tvTime] ServerHltvInfo tvTime
     * @property {number|null} [gameType] ServerHltvInfo gameType
     * @property {string|null} [gameMapgroup] ServerHltvInfo gameMapgroup
     * @property {string|null} [gameMap] ServerHltvInfo gameMap
     * @property {number|Long|null} [tvMasterSteamid] ServerHltvInfo tvMasterSteamid
     * @property {number|null} [tvLocalSlots] ServerHltvInfo tvLocalSlots
     * @property {number|null} [tvLocalClients] ServerHltvInfo tvLocalClients
     * @property {number|null} [tvLocalProxies] ServerHltvInfo tvLocalProxies
     * @property {number|null} [tvRelaySlots] ServerHltvInfo tvRelaySlots
     * @property {number|null} [tvRelayClients] ServerHltvInfo tvRelayClients
     * @property {number|null} [tvRelayProxies] ServerHltvInfo tvRelayProxies
     * @property {number|null} [tvRelayAddress] ServerHltvInfo tvRelayAddress
     * @property {number|null} [tvRelayPort] ServerHltvInfo tvRelayPort
     * @property {number|Long|null} [tvRelaySteamid] ServerHltvInfo tvRelaySteamid
     */
    /**
     * Constructs a new ServerHltvInfo.
     * @exports ServerHltvInfo
     * @classdesc Represents a ServerHltvInfo.
     * @implements IServerHltvInfo
     * @constructor
     * @param {IServerHltvInfo=} [properties] Properties to set
     */
    function ServerHltvInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * ServerHltvInfo tvUdpPort.
     * @member {number} tvUdpPort
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvUdpPort = 0;
    /**
     * ServerHltvInfo tvWatchKey.
     * @member {number|Long} tvWatchKey
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvWatchKey = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * ServerHltvInfo tvSlots.
     * @member {number} tvSlots
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvSlots = 0;
    /**
     * ServerHltvInfo tvClients.
     * @member {number} tvClients
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvClients = 0;
    /**
     * ServerHltvInfo tvProxies.
     * @member {number} tvProxies
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvProxies = 0;
    /**
     * ServerHltvInfo tvTime.
     * @member {number} tvTime
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvTime = 0;
    /**
     * ServerHltvInfo gameType.
     * @member {number} gameType
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.gameType = 0;
    /**
     * ServerHltvInfo gameMapgroup.
     * @member {string} gameMapgroup
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.gameMapgroup = "";
    /**
     * ServerHltvInfo gameMap.
     * @member {string} gameMap
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.gameMap = "";
    /**
     * ServerHltvInfo tvMasterSteamid.
     * @member {number|Long} tvMasterSteamid
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvMasterSteamid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * ServerHltvInfo tvLocalSlots.
     * @member {number} tvLocalSlots
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvLocalSlots = 0;
    /**
     * ServerHltvInfo tvLocalClients.
     * @member {number} tvLocalClients
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvLocalClients = 0;
    /**
     * ServerHltvInfo tvLocalProxies.
     * @member {number} tvLocalProxies
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvLocalProxies = 0;
    /**
     * ServerHltvInfo tvRelaySlots.
     * @member {number} tvRelaySlots
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelaySlots = 0;
    /**
     * ServerHltvInfo tvRelayClients.
     * @member {number} tvRelayClients
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayClients = 0;
    /**
     * ServerHltvInfo tvRelayProxies.
     * @member {number} tvRelayProxies
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayProxies = 0;
    /**
     * ServerHltvInfo tvRelayAddress.
     * @member {number} tvRelayAddress
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayAddress = 0;
    /**
     * ServerHltvInfo tvRelayPort.
     * @member {number} tvRelayPort
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayPort = 0;
    /**
     * ServerHltvInfo tvRelaySteamid.
     * @member {number|Long} tvRelaySteamid
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelaySteamid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a ServerHltvInfo message from the specified reader or buffer.
     * @function decode
     * @memberof ServerHltvInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerHltvInfo} ServerHltvInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerHltvInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerHltvInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tvUdpPort = reader.uint32();
                    break;
                case 2:
                    message.tvWatchKey = reader.uint64();
                    break;
                case 3:
                    message.tvSlots = reader.uint32();
                    break;
                case 4:
                    message.tvClients = reader.uint32();
                    break;
                case 5:
                    message.tvProxies = reader.uint32();
                    break;
                case 6:
                    message.tvTime = reader.uint32();
                    break;
                case 8:
                    message.gameType = reader.uint32();
                    break;
                case 9:
                    message.gameMapgroup = reader.string();
                    break;
                case 10:
                    message.gameMap = reader.string();
                    break;
                case 11:
                    message.tvMasterSteamid = reader.uint64();
                    break;
                case 12:
                    message.tvLocalSlots = reader.uint32();
                    break;
                case 13:
                    message.tvLocalClients = reader.uint32();
                    break;
                case 14:
                    message.tvLocalProxies = reader.uint32();
                    break;
                case 15:
                    message.tvRelaySlots = reader.uint32();
                    break;
                case 16:
                    message.tvRelayClients = reader.uint32();
                    break;
                case 17:
                    message.tvRelayProxies = reader.uint32();
                    break;
                case 18:
                    message.tvRelayAddress = reader.uint32();
                    break;
                case 19:
                    message.tvRelayPort = reader.uint32();
                    break;
                case 20:
                    message.tvRelaySteamid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return ServerHltvInfo;
})());
exports.IpAddressMask = ($root.IpAddressMask = (() => {
    /**
     * Properties of an IpAddressMask.
     * @exports IIpAddressMask
     * @interface IIpAddressMask
     * @property {number|null} [a] IpAddressMask a
     * @property {number|null} [b] IpAddressMask b
     * @property {number|null} [c] IpAddressMask c
     * @property {number|null} [d] IpAddressMask d
     * @property {number|null} [bits] IpAddressMask bits
     * @property {number|null} [token] IpAddressMask token
     */
    /**
     * Constructs a new IpAddressMask.
     * @exports IpAddressMask
     * @classdesc Represents an IpAddressMask.
     * @implements IIpAddressMask
     * @constructor
     * @param {IIpAddressMask=} [properties] Properties to set
     */
    function IpAddressMask(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * IpAddressMask a.
     * @member {number} a
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.a = 0;
    /**
     * IpAddressMask b.
     * @member {number} b
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.b = 0;
    /**
     * IpAddressMask c.
     * @member {number} c
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.c = 0;
    /**
     * IpAddressMask d.
     * @member {number} d
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.d = 0;
    /**
     * IpAddressMask bits.
     * @member {number} bits
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.bits = 0;
    /**
     * IpAddressMask token.
     * @member {number} token
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.token = 0;
    /**
     * Decodes an IpAddressMask message from the specified reader or buffer.
     * @function decode
     * @memberof IpAddressMask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IpAddressMask} IpAddressMask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpAddressMask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.IpAddressMask();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.a = reader.uint32();
                    break;
                case 2:
                    message.b = reader.uint32();
                    break;
                case 3:
                    message.c = reader.uint32();
                    break;
                case 4:
                    message.d = reader.uint32();
                    break;
                case 5:
                    message.bits = reader.uint32();
                    break;
                case 6:
                    message.token = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return IpAddressMask;
})());
exports.XpProgressData = ($root.XpProgressData = (() => {
    /**
     * Properties of a XpProgressData.
     * @exports IXpProgressData
     * @interface IXpProgressData
     * @property {number|null} [xpPoints] XpProgressData xpPoints
     * @property {number|null} [xpCategory] XpProgressData xpCategory
     */
    /**
     * Constructs a new XpProgressData.
     * @exports XpProgressData
     * @classdesc Represents a XpProgressData.
     * @implements IXpProgressData
     * @constructor
     * @param {IXpProgressData=} [properties] Properties to set
     */
    function XpProgressData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * XpProgressData xpPoints.
     * @member {number} xpPoints
     * @memberof XpProgressData
     * @instance
     */
    XpProgressData.prototype.xpPoints = 0;
    /**
     * XpProgressData xpCategory.
     * @member {number} xpCategory
     * @memberof XpProgressData
     * @instance
     */
    XpProgressData.prototype.xpCategory = 0;
    /**
     * Decodes a XpProgressData message from the specified reader or buffer.
     * @function decode
     * @memberof XpProgressData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {XpProgressData} XpProgressData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    XpProgressData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.XpProgressData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.xpPoints = reader.uint32();
                    break;
                case 2:
                    message.xpCategory = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return XpProgressData;
})());
exports.MatchEndItemUpdates = ($root.MatchEndItemUpdates = (() => {
    /**
     * Properties of a MatchEndItemUpdates.
     * @exports IMatchEndItemUpdates
     * @interface IMatchEndItemUpdates
     * @property {number|Long|null} [itemId] MatchEndItemUpdates itemId
     * @property {number|null} [itemAttrDefidx] MatchEndItemUpdates itemAttrDefidx
     * @property {number|null} [itemAttrDeltaValue] MatchEndItemUpdates itemAttrDeltaValue
     */
    /**
     * Constructs a new MatchEndItemUpdates.
     * @exports MatchEndItemUpdates
     * @classdesc Represents a MatchEndItemUpdates.
     * @implements IMatchEndItemUpdates
     * @constructor
     * @param {IMatchEndItemUpdates=} [properties] Properties to set
     */
    function MatchEndItemUpdates(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * MatchEndItemUpdates itemId.
     * @member {number|Long} itemId
     * @memberof MatchEndItemUpdates
     * @instance
     */
    MatchEndItemUpdates.prototype.itemId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * MatchEndItemUpdates itemAttrDefidx.
     * @member {number} itemAttrDefidx
     * @memberof MatchEndItemUpdates
     * @instance
     */
    MatchEndItemUpdates.prototype.itemAttrDefidx = 0;
    /**
     * MatchEndItemUpdates itemAttrDeltaValue.
     * @member {number} itemAttrDeltaValue
     * @memberof MatchEndItemUpdates
     * @instance
     */
    MatchEndItemUpdates.prototype.itemAttrDeltaValue = 0;
    /**
     * Decodes a MatchEndItemUpdates message from the specified reader or buffer.
     * @function decode
     * @memberof MatchEndItemUpdates
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MatchEndItemUpdates} MatchEndItemUpdates
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MatchEndItemUpdates.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MatchEndItemUpdates();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.uint64();
                    break;
                case 2:
                    message.itemAttrDefidx = reader.uint32();
                    break;
                case 3:
                    message.itemAttrDeltaValue = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return MatchEndItemUpdates;
})());
exports.PlayerQuestData = ($root.PlayerQuestData = (() => {
    /**
     * Properties of a PlayerQuestData.
     * @exports IPlayerQuestData
     * @interface IPlayerQuestData
     * @property {number|null} [questerAccountId] PlayerQuestData questerAccountId
     * @property {Array.<PlayerQuestData.IQuestItemData>|null} [questItemData] PlayerQuestData questItemData
     * @property {Array.<IXpProgressData>|null} [xpProgressData] PlayerQuestData xpProgressData
     * @property {number|null} [timePlayed] PlayerQuestData timePlayed
     * @property {number|null} [mmGameMode] PlayerQuestData mmGameMode
     * @property {Array.<IMatchEndItemUpdates>|null} [itemUpdates] PlayerQuestData itemUpdates
     */
    /**
     * Constructs a new PlayerQuestData.
     * @exports PlayerQuestData
     * @classdesc Represents a PlayerQuestData.
     * @implements IPlayerQuestData
     * @constructor
     * @param {IPlayerQuestData=} [properties] Properties to set
     */
    function PlayerQuestData(properties) {
        this.questItemData = [];
        this.xpProgressData = [];
        this.itemUpdates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerQuestData questerAccountId.
     * @member {number} questerAccountId
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.questerAccountId = 0;
    /**
     * PlayerQuestData questItemData.
     * @member {Array.<PlayerQuestData.IQuestItemData>} questItemData
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.questItemData = $util.emptyArray;
    /**
     * PlayerQuestData xpProgressData.
     * @member {Array.<IXpProgressData>} xpProgressData
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.xpProgressData = $util.emptyArray;
    /**
     * PlayerQuestData timePlayed.
     * @member {number} timePlayed
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.timePlayed = 0;
    /**
     * PlayerQuestData mmGameMode.
     * @member {number} mmGameMode
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.mmGameMode = 0;
    /**
     * PlayerQuestData itemUpdates.
     * @member {Array.<IMatchEndItemUpdates>} itemUpdates
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.itemUpdates = $util.emptyArray;
    /**
     * Decodes a PlayerQuestData message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerQuestData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerQuestData} PlayerQuestData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerQuestData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerQuestData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.questerAccountId = reader.uint32();
                    break;
                case 2:
                    if (!(message.questItemData && message.questItemData.length))
                        message.questItemData = [];
                    message.questItemData.push($root.PlayerQuestData.QuestItemData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.xpProgressData && message.xpProgressData.length))
                        message.xpProgressData = [];
                    message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.timePlayed = reader.uint32();
                    break;
                case 5:
                    message.mmGameMode = reader.uint32();
                    break;
                case 6:
                    if (!(message.itemUpdates && message.itemUpdates.length))
                        message.itemUpdates = [];
                    message.itemUpdates.push($root.MatchEndItemUpdates.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    PlayerQuestData.QuestItemData = (function () {
        /**
         * Properties of a QuestItemData.
         * @memberof PlayerQuestData
         * @interface IQuestItemData
         * @property {number|Long|null} [questId] QuestItemData questId
         * @property {number|null} [questNormalPointsEarned] QuestItemData questNormalPointsEarned
         * @property {number|null} [questBonusPointsEarned] QuestItemData questBonusPointsEarned
         */
        /**
         * Constructs a new QuestItemData.
         * @memberof PlayerQuestData
         * @classdesc Represents a QuestItemData.
         * @implements IQuestItemData
         * @constructor
         * @param {PlayerQuestData.IQuestItemData=} [properties] Properties to set
         */
        function QuestItemData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * QuestItemData questId.
         * @member {number|Long} questId
         * @memberof PlayerQuestData.QuestItemData
         * @instance
         */
        QuestItemData.prototype.questId = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;
        /**
         * QuestItemData questNormalPointsEarned.
         * @member {number} questNormalPointsEarned
         * @memberof PlayerQuestData.QuestItemData
         * @instance
         */
        QuestItemData.prototype.questNormalPointsEarned = 0;
        /**
         * QuestItemData questBonusPointsEarned.
         * @member {number} questBonusPointsEarned
         * @memberof PlayerQuestData.QuestItemData
         * @instance
         */
        QuestItemData.prototype.questBonusPointsEarned = 0;
        /**
         * Decodes a QuestItemData message from the specified reader or buffer.
         * @function decode
         * @memberof PlayerQuestData.QuestItemData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PlayerQuestData.QuestItemData} QuestItemData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuestItemData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerQuestData.QuestItemData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.questId = reader.uint64();
                        break;
                    case 2:
                        message.questNormalPointsEarned = reader.int32();
                        break;
                    case 3:
                        message.questBonusPointsEarned = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return QuestItemData;
    })();
    return PlayerQuestData;
})());
exports.CMsgGC_ServerQuestUpdateData = ($root.CMsgGC_ServerQuestUpdateData = (() => {
    /**
     * Properties of a CMsgGC_ServerQuestUpdateData.
     * @exports ICMsgGC_ServerQuestUpdateData
     * @interface ICMsgGC_ServerQuestUpdateData
     * @property {Array.<IPlayerQuestData>|null} [playerQuestData] CMsgGC_ServerQuestUpdateData playerQuestData
     */
    /**
     * Constructs a new CMsgGC_ServerQuestUpdateData.
     * @exports CMsgGC_ServerQuestUpdateData
     * @classdesc Represents a CMsgGC_ServerQuestUpdateData.
     * @implements ICMsgGC_ServerQuestUpdateData
     * @constructor
     * @param {ICMsgGC_ServerQuestUpdateData=} [properties] Properties to set
     */
    function CMsgGC_ServerQuestUpdateData(properties) {
        this.playerQuestData = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_ServerQuestUpdateData playerQuestData.
     * @member {Array.<IPlayerQuestData>} playerQuestData
     * @memberof CMsgGC_ServerQuestUpdateData
     * @instance
     */
    CMsgGC_ServerQuestUpdateData.prototype.playerQuestData = $util.emptyArray;
    /**
     * Decodes a CMsgGC_ServerQuestUpdateData message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_ServerQuestUpdateData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_ServerQuestUpdateData} CMsgGC_ServerQuestUpdateData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_ServerQuestUpdateData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_ServerQuestUpdateData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.playerQuestData && message.playerQuestData.length))
                        message.playerQuestData = [];
                    message.playerQuestData.push($root.PlayerQuestData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_ServerQuestUpdateData;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = ($root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @interface ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @property {number|null} [packetid] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid
     * @property {Array.<IOperationalStatisticDescription>|null} [namekeys] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys
     * @property {Array.<IOperationalStatisticsPacket>|null} [packets] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.
     * @exports CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGCOperationalStats(properties) {
        this.namekeys = [];
        this.packets = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid.
     * @member {number} packetid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packetid = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys.
     * @member {Array.<IOperationalStatisticDescription>} namekeys
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.namekeys =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets.
     * @member {Array.<IOperationalStatisticsPacket>} packets
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packets =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGCOperationalStats} CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.packetid = reader.int32();
                    break;
                case 2:
                    if (!(message.namekeys && message.namekeys.length))
                        message.namekeys = [];
                    message.namekeys.push($root.OperationalStatisticDescription.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.packets && message.packets.length))
                        message.packets = [];
                    message.packets.push($root.OperationalStatisticsPacket.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGCOperationalStats;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @property {number|null} [token] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token
     * @property {number|null} [stamp] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp
     * @property {number|Long|null} [exchange] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token.
     * @member {number} token
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.token = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp.
     * @member {number} stamp
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.stamp = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange.
     * @member {number|Long} exchange
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.exchange = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm} CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.uint32();
                    break;
                case 2:
                    message.stamp = reader.uint32();
                    break;
                case 3:
                    message.exchange = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm;
})());
exports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = ($root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.
     * @exports ICMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @interface ICMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @property {number|null} [viewersExternalTotal] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal
     * @property {number|null} [viewersExternalSteam] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GC2ServerReservationUpdate.
     * @exports CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.
     * @implements ICMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GC2ServerReservationUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GC2ServerReservationUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal.
     * @member {number} viewersExternalTotal
     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalTotal = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam.
     * @member {number} viewersExternalSteam
     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalSteam = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_GC2ServerReservationUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GC2ServerReservationUpdate} CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.viewersExternalTotal = reader.uint32();
                    break;
                case 2:
                    message.viewersExternalSteam = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GC2ServerReservationUpdate;
})());
exports.CMsgGCCStrike15_v2_MatchmakingStart = ($root.CMsgGCCStrike15_v2_MatchmakingStart = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingStart.
     * @exports ICMsgGCCStrike15_v2_MatchmakingStart
     * @interface ICMsgGCCStrike15_v2_MatchmakingStart
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingStart accountIds
     * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingStart gameType
     * @property {string|null} [ticketData] CMsgGCCStrike15_v2_MatchmakingStart ticketData
     * @property {number|null} [clientVersion] CMsgGCCStrike15_v2_MatchmakingStart clientVersion
     * @property {ITournamentMatchSetup|null} [tournamentMatch] CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingStart.
     * @exports CMsgGCCStrike15_v2_MatchmakingStart
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStart.
     * @implements ICMsgGCCStrike15_v2_MatchmakingStart
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingStart=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingStart(properties) {
        this.accountIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.accountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart gameType.
     * @member {number} gameType
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.gameType = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart ticketData.
     * @member {string} ticketData
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.ticketData = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart clientVersion.
     * @member {number} clientVersion
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.clientVersion = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch.
     * @member {ITournamentMatchSetup|null|undefined} tournamentMatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.tournamentMatch = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingStart message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingStart} CMsgGCCStrike15_v2_MatchmakingStart
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingStart.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingStart();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 2:
                    message.gameType = reader.uint32();
                    break;
                case 3:
                    message.ticketData = reader.string();
                    break;
                case 4:
                    message.clientVersion = reader.uint32();
                    break;
                case 5:
                    message.tournamentMatch = $root.TournamentMatchSetup.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingStart;
})());
exports.CMsgGCCStrike15_v2_MatchmakingStop = ($root.CMsgGCCStrike15_v2_MatchmakingStop = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingStop.
     * @exports ICMsgGCCStrike15_v2_MatchmakingStop
     * @interface ICMsgGCCStrike15_v2_MatchmakingStop
     * @property {number|null} [abandon] CMsgGCCStrike15_v2_MatchmakingStop abandon
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingStop.
     * @exports CMsgGCCStrike15_v2_MatchmakingStop
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStop.
     * @implements ICMsgGCCStrike15_v2_MatchmakingStop
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingStop=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingStop(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingStop abandon.
     * @member {number} abandon
     * @memberof CMsgGCCStrike15_v2_MatchmakingStop
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStop.prototype.abandon = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingStop message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingStop
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingStop} CMsgGCCStrike15_v2_MatchmakingStop
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingStop.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingStop();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.abandon = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingStop;
})());
exports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = ($root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.
     * @exports ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @interface ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @property {Array.<IGameServerPing>|null} [gameserverpings] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings
     * @property {number|null} [offsetIndex] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex
     * @property {number|null} [finalBatch] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.
     * @exports CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.
     * @implements ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingClient2ServerPing(properties) {
        this.gameserverpings = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings.
     * @member {Array.<IGameServerPing>} gameserverpings
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.gameserverpings =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex.
     * @member {number} offsetIndex
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.offsetIndex = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch.
     * @member {number} finalBatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.finalBatch = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingClient2ServerPing} CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.gameserverpings && message.gameserverpings.length))
                        message.gameserverpings = [];
                    message.gameserverpings.push($root.GameServerPing.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.offsetIndex = reader.int32();
                    break;
                case 3:
                    message.finalBatch = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingClient2ServerPing;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @property {number|null} [matchmaking] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking
     * @property {Array.<number>|null} [waitingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions
     * @property {string|null} [error] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error
     * @property {Array.<number>|null} [ongoingmatchAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions
     * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats
     * @property {Array.<number>|null} [failpingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions
     * @property {Array.<number>|null} [penaltyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions
     * @property {Array.<number>|null} [failreadyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions
     * @property {Array.<number>|null} [vacbannedAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions
     * @property {IIpAddressMask|null} [serverIpaddressMask] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask
     * @property {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>|null} [notes] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes
     * @property {Array.<number>|null} [penaltyAccountIdSessionsGreen] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen
     * @property {Array.<number>|null} [insufficientlevelSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate(properties) {
        this.waitingAccountIdSessions = [];
        this.ongoingmatchAccountIdSessions = [];
        this.failpingAccountIdSessions = [];
        this.penaltyAccountIdSessions = [];
        this.failreadyAccountIdSessions = [];
        this.vacbannedAccountIdSessions = [];
        this.notes = [];
        this.penaltyAccountIdSessionsGreen = [];
        this.insufficientlevelSessions = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking.
     * @member {number} matchmaking
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.matchmaking = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions.
     * @member {Array.<number>} waitingAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.waitingAccountIdSessions =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error.
     * @member {string} error
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.error = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions.
     * @member {Array.<number>} ongoingmatchAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.ongoingmatchAccountIdSessions =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats.
     * @member {IGlobalStatistics|null|undefined} globalStats
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.globalStats = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions.
     * @member {Array.<number>} failpingAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failpingAccountIdSessions =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions.
     * @member {Array.<number>} penaltyAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessions =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions.
     * @member {Array.<number>} failreadyAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failreadyAccountIdSessions =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions.
     * @member {Array.<number>} vacbannedAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.vacbannedAccountIdSessions =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask.
     * @member {IIpAddressMask|null|undefined} serverIpaddressMask
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.serverIpaddressMask = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes.
     * @member {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>} notes
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.notes =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen.
     * @member {Array.<number>} penaltyAccountIdSessionsGreen
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessionsGreen =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions.
     * @member {Array.<number>} insufficientlevelSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.insufficientlevelSessions =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchmaking = reader.int32();
                    break;
                case 2:
                    if (!(message.waitingAccountIdSessions &&
                        message.waitingAccountIdSessions.length))
                        message.waitingAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waitingAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.waitingAccountIdSessions.push(reader.uint32());
                    break;
                case 3:
                    message.error = reader.string();
                    break;
                case 6:
                    if (!(message.ongoingmatchAccountIdSessions &&
                        message.ongoingmatchAccountIdSessions.length))
                        message.ongoingmatchAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ongoingmatchAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.ongoingmatchAccountIdSessions.push(reader.uint32());
                    break;
                case 7:
                    message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.failpingAccountIdSessions &&
                        message.failpingAccountIdSessions.length))
                        message.failpingAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.failpingAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.failpingAccountIdSessions.push(reader.uint32());
                    break;
                case 9:
                    if (!(message.penaltyAccountIdSessions &&
                        message.penaltyAccountIdSessions.length))
                        message.penaltyAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.penaltyAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.penaltyAccountIdSessions.push(reader.uint32());
                    break;
                case 10:
                    if (!(message.failreadyAccountIdSessions &&
                        message.failreadyAccountIdSessions.length))
                        message.failreadyAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.failreadyAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.failreadyAccountIdSessions.push(reader.uint32());
                    break;
                case 11:
                    if (!(message.vacbannedAccountIdSessions &&
                        message.vacbannedAccountIdSessions.length))
                        message.vacbannedAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.vacbannedAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.vacbannedAccountIdSessions.push(reader.uint32());
                    break;
                case 12:
                    message.serverIpaddressMask = $root.IpAddressMask.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.notes && message.notes.length))
                        message.notes = [];
                    message.notes.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.penaltyAccountIdSessionsGreen &&
                        message.penaltyAccountIdSessionsGreen.length))
                        message.penaltyAccountIdSessionsGreen = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.penaltyAccountIdSessionsGreen.push(reader.uint32());
                    }
                    else
                        message.penaltyAccountIdSessionsGreen.push(reader.uint32());
                    break;
                case 15:
                    if (!(message.insufficientlevelSessions &&
                        message.insufficientlevelSessions.length))
                        message.insufficientlevelSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.insufficientlevelSessions.push(reader.uint32());
                    }
                    else
                        message.insufficientlevelSessions.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note = (function () {
        /**
         * Properties of a Note.
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
         * @interface INote
         * @property {number|null} [type] Note type
         * @property {number|null} [regionId] Note regionId
         * @property {number|null} [regionR] Note regionR
         * @property {number|null} [distance] Note distance
         */
        /**
         * Constructs a new Note.
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
         * @classdesc Represents a Note.
         * @implements INote
         * @constructor
         * @param {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote=} [properties] Properties to set
         */
        function Note(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Note type.
         * @member {number} type
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.type = 0;
        /**
         * Note regionId.
         * @member {number} regionId
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.regionId = 0;
        /**
         * Note regionR.
         * @member {number} regionR
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.regionR = 0;
        /**
         * Note distance.
         * @member {number} distance
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.distance = 0;
        /**
         * Decodes a Note message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note} Note
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Note.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.regionId = reader.int32();
                        break;
                    case 3:
                        message.regionR = reader.float();
                        break;
                    case 4:
                        message.distance = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Note;
    })();
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate;
})());
exports.CDataGCCStrike15_v2_TournamentMatchDraft = ($root.CDataGCCStrike15_v2_TournamentMatchDraft = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentMatchDraft.
     * @exports ICDataGCCStrike15_v2_TournamentMatchDraft
     * @interface ICDataGCCStrike15_v2_TournamentMatchDraft
     * @property {number|null} [eventId] CDataGCCStrike15_v2_TournamentMatchDraft eventId
     * @property {number|null} [eventStageId] CDataGCCStrike15_v2_TournamentMatchDraft eventStageId
     * @property {number|null} [teamId_0] CDataGCCStrike15_v2_TournamentMatchDraft teamId_0
     * @property {number|null} [teamId_1] CDataGCCStrike15_v2_TournamentMatchDraft teamId_1
     * @property {number|null} [mapsCount] CDataGCCStrike15_v2_TournamentMatchDraft mapsCount
     * @property {number|null} [mapsCurrent] CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent
     * @property {number|null} [teamIdStart] CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart
     * @property {number|null} [teamIdVeto1] CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1
     * @property {number|null} [teamIdPickn] CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn
     * @property {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>|null} [drafts] CDataGCCStrike15_v2_TournamentMatchDraft drafts
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentMatchDraft.
     * @exports CDataGCCStrike15_v2_TournamentMatchDraft
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentMatchDraft.
     * @implements ICDataGCCStrike15_v2_TournamentMatchDraft
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentMatchDraft=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentMatchDraft(properties) {
        this.drafts = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft eventId.
     * @member {number} eventId
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventId = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft eventStageId.
     * @member {number} eventStageId
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventStageId = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamId_0.
     * @member {number} teamId_0
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_0 = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamId_1.
     * @member {number} teamId_1
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_1 = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft mapsCount.
     * @member {number} mapsCount
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCount = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent.
     * @member {number} mapsCurrent
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCurrent = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart.
     * @member {number} teamIdStart
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdStart = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1.
     * @member {number} teamIdVeto1
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdVeto1 = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn.
     * @member {number} teamIdPickn
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdPickn = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft drafts.
     * @member {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>} drafts
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.drafts = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentMatchDraft message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentMatchDraft} CDataGCCStrike15_v2_TournamentMatchDraft
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                case 2:
                    message.eventStageId = reader.int32();
                    break;
                case 3:
                    message.teamId_0 = reader.int32();
                    break;
                case 4:
                    message.teamId_1 = reader.int32();
                    break;
                case 5:
                    message.mapsCount = reader.int32();
                    break;
                case 6:
                    message.mapsCurrent = reader.int32();
                    break;
                case 7:
                    message.teamIdStart = reader.int32();
                    break;
                case 8:
                    message.teamIdVeto1 = reader.int32();
                    break;
                case 9:
                    message.teamIdPickn = reader.int32();
                    break;
                case 10:
                    if (!(message.drafts && message.drafts.length))
                        message.drafts = [];
                    message.drafts.push($root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CDataGCCStrike15_v2_TournamentMatchDraft.Entry = (function () {
        /**
         * Properties of an Entry.
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
         * @interface IEntry
         * @property {number|null} [mapid] Entry mapid
         * @property {number|null} [teamIdCt] Entry teamIdCt
         */
        /**
         * Constructs a new Entry.
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
         * @classdesc Represents an Entry.
         * @implements IEntry
         * @constructor
         * @param {CDataGCCStrike15_v2_TournamentMatchDraft.IEntry=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Entry mapid.
         * @member {number} mapid
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry
         * @instance
         */
        Entry.prototype.mapid = 0;
        /**
         * Entry teamIdCt.
         * @member {number} teamIdCt
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry
         * @instance
         */
        Entry.prototype.teamIdCt = 0;
        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @function decode
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDataGCCStrike15_v2_TournamentMatchDraft.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapid = reader.int32();
                        break;
                    case 2:
                        message.teamIdCt = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Entry;
    })();
    return CDataGCCStrike15_v2_TournamentMatchDraft;
})());
exports.CPreMatchInfoData = ($root.CPreMatchInfoData = (() => {
    /**
     * Properties of a CPreMatchInfoData.
     * @exports ICPreMatchInfoData
     * @interface ICPreMatchInfoData
     * @property {number|null} [predictionsPct] CPreMatchInfoData predictionsPct
     * @property {ICDataGCCStrike15_v2_TournamentMatchDraft|null} [draft] CPreMatchInfoData draft
     * @property {Array.<CPreMatchInfoData.ITeamStats>|null} [stats] CPreMatchInfoData stats
     */
    /**
     * Constructs a new CPreMatchInfoData.
     * @exports CPreMatchInfoData
     * @classdesc Represents a CPreMatchInfoData.
     * @implements ICPreMatchInfoData
     * @constructor
     * @param {ICPreMatchInfoData=} [properties] Properties to set
     */
    function CPreMatchInfoData(properties) {
        this.stats = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CPreMatchInfoData predictionsPct.
     * @member {number} predictionsPct
     * @memberof CPreMatchInfoData
     * @instance
     */
    CPreMatchInfoData.prototype.predictionsPct = 0;
    /**
     * CPreMatchInfoData draft.
     * @member {ICDataGCCStrike15_v2_TournamentMatchDraft|null|undefined} draft
     * @memberof CPreMatchInfoData
     * @instance
     */
    CPreMatchInfoData.prototype.draft = null;
    /**
     * CPreMatchInfoData stats.
     * @member {Array.<CPreMatchInfoData.ITeamStats>} stats
     * @memberof CPreMatchInfoData
     * @instance
     */
    CPreMatchInfoData.prototype.stats = $util.emptyArray;
    /**
     * Decodes a CPreMatchInfoData message from the specified reader or buffer.
     * @function decode
     * @memberof CPreMatchInfoData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CPreMatchInfoData} CPreMatchInfoData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CPreMatchInfoData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CPreMatchInfoData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.predictionsPct = reader.int32();
                    break;
                case 4:
                    message.draft = $root.CDataGCCStrike15_v2_TournamentMatchDraft.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CPreMatchInfoData.TeamStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CPreMatchInfoData.TeamStats = (function () {
        /**
         * Properties of a TeamStats.
         * @memberof CPreMatchInfoData
         * @interface ITeamStats
         * @property {number|null} [matchInfoIdxtxt] TeamStats matchInfoIdxtxt
         * @property {string|null} [matchInfoTxt] TeamStats matchInfoTxt
         * @property {Array.<string>|null} [matchInfoTeams] TeamStats matchInfoTeams
         */
        /**
         * Constructs a new TeamStats.
         * @memberof CPreMatchInfoData
         * @classdesc Represents a TeamStats.
         * @implements ITeamStats
         * @constructor
         * @param {CPreMatchInfoData.ITeamStats=} [properties] Properties to set
         */
        function TeamStats(properties) {
            this.matchInfoTeams = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TeamStats matchInfoIdxtxt.
         * @member {number} matchInfoIdxtxt
         * @memberof CPreMatchInfoData.TeamStats
         * @instance
         */
        TeamStats.prototype.matchInfoIdxtxt = 0;
        /**
         * TeamStats matchInfoTxt.
         * @member {string} matchInfoTxt
         * @memberof CPreMatchInfoData.TeamStats
         * @instance
         */
        TeamStats.prototype.matchInfoTxt = "";
        /**
         * TeamStats matchInfoTeams.
         * @member {Array.<string>} matchInfoTeams
         * @memberof CPreMatchInfoData.TeamStats
         * @instance
         */
        TeamStats.prototype.matchInfoTeams = $util.emptyArray;
        /**
         * Decodes a TeamStats message from the specified reader or buffer.
         * @function decode
         * @memberof CPreMatchInfoData.TeamStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CPreMatchInfoData.TeamStats} TeamStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CPreMatchInfoData.TeamStats();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.matchInfoIdxtxt = reader.int32();
                        break;
                    case 2:
                        message.matchInfoTxt = reader.string();
                        break;
                    case 3:
                        if (!(message.matchInfoTeams && message.matchInfoTeams.length))
                            message.matchInfoTeams = [];
                        message.matchInfoTeams.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return TeamStats;
    })();
    return CPreMatchInfoData;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds
     * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId
     * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion
     * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings
     * @property {number|Long|null} [encryptionKey] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey
     * @property {number|Long|null} [encryptionKeyPub] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub
     * @property {Array.<number>|null} [partyIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds
     * @property {Array.<IIpAddressMask>|null} [whitelist] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist
     * @property {number|Long|null} [tvMasterSteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid
     * @property {ITournamentEvent|null} [tournamentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent
     * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams
     * @property {Array.<number>|null} [tournamentCastersAccountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds
     * @property {number|Long|null} [tvRelaySteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid
     * @property {ICPreMatchInfoData|null} [preMatchData] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve(properties) {
        this.accountIds = [];
        this.rankings = [];
        this.partyIds = [];
        this.whitelist = [];
        this.tournamentTeams = [];
        this.tournamentCastersAccountIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.accountIds =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType.
     * @member {number} gameType
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.gameType = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion.
     * @member {number} serverVersion
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.serverVersion = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings.
     * @member {Array.<IPlayerRankingInfo>} rankings
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.rankings =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey.
     * @member {number|Long} encryptionKey
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKey = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub.
     * @member {number|Long} encryptionKeyPub
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKeyPub = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds.
     * @member {Array.<number>} partyIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.partyIds =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist.
     * @member {Array.<IIpAddressMask>} whitelist
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.whitelist =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid.
     * @member {number|Long} tvMasterSteamid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvMasterSteamid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent.
     * @member {ITournamentEvent|null|undefined} tournamentEvent
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentEvent = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams.
     * @member {Array.<ITournamentTeam>} tournamentTeams
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentTeams =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds.
     * @member {Array.<number>} tournamentCastersAccountIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentCastersAccountIds =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid.
     * @member {number|Long} tvRelaySteamid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvRelaySteamid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData.
     * @member {ICPreMatchInfoData|null|undefined} preMatchData
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.preMatchData = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve} CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 2:
                    message.gameType = reader.uint32();
                    break;
                case 3:
                    message.matchId = reader.uint64();
                    break;
                case 4:
                    message.serverVersion = reader.uint32();
                    break;
                case 5:
                    if (!(message.rankings && message.rankings.length))
                        message.rankings = [];
                    message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.encryptionKey = reader.uint64();
                    break;
                case 7:
                    message.encryptionKeyPub = reader.uint64();
                    break;
                case 8:
                    if (!(message.partyIds && message.partyIds.length))
                        message.partyIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.partyIds.push(reader.uint32());
                    }
                    else
                        message.partyIds.push(reader.uint32());
                    break;
                case 9:
                    if (!(message.whitelist && message.whitelist.length))
                        message.whitelist = [];
                    message.whitelist.push($root.IpAddressMask.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.tvMasterSteamid = reader.uint64();
                    break;
                case 11:
                    message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());
                    break;
                case 12:
                    if (!(message.tournamentTeams && message.tournamentTeams.length))
                        message.tournamentTeams = [];
                    message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.tournamentCastersAccountIds &&
                        message.tournamentCastersAccountIds.length))
                        message.tournamentCastersAccountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tournamentCastersAccountIds.push(reader.uint32());
                    }
                    else
                        message.tournamentCastersAccountIds.push(reader.uint32());
                    break;
                case 14:
                    message.tvRelaySteamid = reader.uint64();
                    break;
                case 15:
                    message.preMatchData = $root.CPreMatchInfoData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve;
})());
exports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = ($root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @interface ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation
     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map
     * @property {number|Long|null} [gcReservationSent] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent
     * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion
     * @property {IServerHltvInfo|null} [tvInfo] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo
     * @property {Array.<number>|null} [rewardPlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts
     * @property {Array.<number>|null} [idlePlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts
     * @property {number|null} [rewardItemAttrDefIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx
     * @property {number|null} [rewardItemAttrValue] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue
     * @property {number|null} [rewardItemAttrRewardIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx
     * @property {number|null} [rewardDropList] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList
     * @property {string|null} [tournamentTag] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag
     * @property {number|null} [steamdatagramPort] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.
     * @exports CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServerReservationResponse(properties) {
        this.rewardPlayerAccounts = [];
        this.idlePlayerAccounts = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid.
     * @member {number|Long} reservationid
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservationid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map.
     * @member {string} map
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.map = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent.
     * @member {number|Long} gcReservationSent
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.gcReservationSent = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion.
     * @member {number} serverVersion
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.serverVersion = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo.
     * @member {IServerHltvInfo|null|undefined} tvInfo
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tvInfo = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts.
     * @member {Array.<number>} rewardPlayerAccounts
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardPlayerAccounts =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts.
     * @member {Array.<number>} idlePlayerAccounts
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.idlePlayerAccounts =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx.
     * @member {number} rewardItemAttrDefIdx
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrDefIdx = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue.
     * @member {number} rewardItemAttrValue
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrValue = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx.
     * @member {number} rewardItemAttrRewardIdx
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrRewardIdx = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList.
     * @member {number} rewardDropList
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardDropList = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag.
     * @member {string} tournamentTag
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tournamentTag =
        "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort.
     * @member {number} steamdatagramPort
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.steamdatagramPort = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServerReservationResponse} CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reservationid = reader.uint64();
                    break;
                case 2:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.map = reader.string();
                    break;
                case 4:
                    message.gcReservationSent = reader.uint64();
                    break;
                case 5:
                    message.serverVersion = reader.uint32();
                    break;
                case 6:
                    message.tvInfo = $root.ServerHltvInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.rewardPlayerAccounts &&
                        message.rewardPlayerAccounts.length))
                        message.rewardPlayerAccounts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rewardPlayerAccounts.push(reader.uint32());
                    }
                    else
                        message.rewardPlayerAccounts.push(reader.uint32());
                    break;
                case 8:
                    if (!(message.idlePlayerAccounts && message.idlePlayerAccounts.length))
                        message.idlePlayerAccounts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.idlePlayerAccounts.push(reader.uint32());
                    }
                    else
                        message.idlePlayerAccounts.push(reader.uint32());
                    break;
                case 9:
                    message.rewardItemAttrDefIdx = reader.uint32();
                    break;
                case 10:
                    message.rewardItemAttrValue = reader.uint32();
                    break;
                case 11:
                    message.rewardItemAttrRewardIdx = reader.uint32();
                    break;
                case 12:
                    message.rewardDropList = reader.uint32();
                    break;
                case 13:
                    message.tournamentTag = reader.string();
                    break;
                case 14:
                    message.steamdatagramPort = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingServerReservationResponse;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid
     * @property {string|null} [serverAddress] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress
     * @property {number|null} [legacyServerip] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip
     * @property {number|null} [legacyServerport] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport
     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation
     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid.
     * @member {number|Long} serverid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress.
     * @member {string} serverAddress
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverAddress = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip.
     * @member {number} legacyServerip
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerip = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport.
     * @member {number} legacyServerport
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerport = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid.
     * @member {number|Long} reservationid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservationid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map.
     * @member {string} map
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.map = "";
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve} CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.serverid = reader.uint64();
                    break;
                case 7:
                    message.serverAddress = reader.string();
                    break;
                case 2:
                    message.legacyServerip = reader.uint32();
                    break;
                case 3:
                    message.legacyServerport = reader.uint32();
                    break;
                case 4:
                    message.reservationid = reader.uint64();
                    break;
                case 5:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.map = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve;
})());
exports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = ($root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @interface ICMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation
     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerRoundStats map
     * @property {number|null} [round] CMsgGCCStrike15_v2_MatchmakingServerRoundStats round
     * @property {Array.<number>|null} [kills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills
     * @property {Array.<number>|null} [assists] CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists
     * @property {Array.<number>|null} [deaths] CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths
     * @property {Array.<number>|null} [scores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores
     * @property {Array.<number>|null} [pings] CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings
     * @property {number|null} [roundResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult
     * @property {number|null} [matchResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult
     * @property {Array.<number>|null} [teamScores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm
     * @property {number|null} [reservationStage] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage
     * @property {number|null} [matchDuration] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration
     * @property {Array.<number>|null} [enemyKills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills
     * @property {Array.<number>|null} [enemyHeadshots] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots
     * @property {Array.<number>|null} [enemy_3ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks
     * @property {Array.<number>|null} [enemy_4ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks
     * @property {Array.<number>|null} [enemy_5ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks
     * @property {Array.<number>|null} [mvps] CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps
     * @property {number|null} [spectatorsCount] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount
     * @property {number|null} [spectatorsCountTv] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv
     * @property {number|null} [spectatorsCountLnk] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk
     * @property {Array.<number>|null} [enemyKillsAgg] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg
     * @property {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null} [dropInfo] CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerRoundStats.
     * @exports CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServerRoundStats(properties) {
        this.kills = [];
        this.assists = [];
        this.deaths = [];
        this.scores = [];
        this.pings = [];
        this.teamScores = [];
        this.enemyKills = [];
        this.enemyHeadshots = [];
        this.enemy_3ks = [];
        this.enemy_4ks = [];
        this.enemy_5ks = [];
        this.mvps = [];
        this.enemyKillsAgg = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid.
     * @member {number|Long} reservationid
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats map.
     * @member {string} map
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.map = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats round.
     * @member {number} round
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.round = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills.
     * @member {Array.<number>} kills
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.kills =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists.
     * @member {Array.<number>} assists
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.assists =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths.
     * @member {Array.<number>} deaths
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.deaths =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores.
     * @member {Array.<number>} scores
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.scores =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings.
     * @member {Array.<number>} pings
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.pings =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult.
     * @member {number} roundResult
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.roundResult = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult.
     * @member {number} matchResult
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchResult = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores.
     * @member {Array.<number>} teamScores
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.teamScores =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.confirm = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage.
     * @member {number} reservationStage
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationStage = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration.
     * @member {number} matchDuration
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchDuration = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills.
     * @member {Array.<number>} enemyKills
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKills =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots.
     * @member {Array.<number>} enemyHeadshots
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyHeadshots =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks.
     * @member {Array.<number>} enemy_3ks
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_3ks =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks.
     * @member {Array.<number>} enemy_4ks
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_4ks =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks.
     * @member {Array.<number>} enemy_5ks
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_5ks =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps.
     * @member {Array.<number>} mvps
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.mvps =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount.
     * @member {number} spectatorsCount
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCount = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv.
     * @member {number} spectatorsCountTv
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountTv = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk.
     * @member {number} spectatorsCountLnk
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountLnk = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg.
     * @member {Array.<number>} enemyKillsAgg
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKillsAgg =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo.
     * @member {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null|undefined} dropInfo
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.dropInfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerRoundStats message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats} CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reservationid = reader.uint64();
                    break;
                case 2:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.map = reader.string();
                    break;
                case 4:
                    message.round = reader.int32();
                    break;
                case 5:
                    if (!(message.kills && message.kills.length))
                        message.kills = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.kills.push(reader.int32());
                    }
                    else
                        message.kills.push(reader.int32());
                    break;
                case 6:
                    if (!(message.assists && message.assists.length))
                        message.assists = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.assists.push(reader.int32());
                    }
                    else
                        message.assists.push(reader.int32());
                    break;
                case 7:
                    if (!(message.deaths && message.deaths.length))
                        message.deaths = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.deaths.push(reader.int32());
                    }
                    else
                        message.deaths.push(reader.int32());
                    break;
                case 8:
                    if (!(message.scores && message.scores.length))
                        message.scores = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.scores.push(reader.int32());
                    }
                    else
                        message.scores.push(reader.int32());
                    break;
                case 9:
                    if (!(message.pings && message.pings.length))
                        message.pings = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.pings.push(reader.int32());
                    }
                    else
                        message.pings.push(reader.int32());
                    break;
                case 10:
                    message.roundResult = reader.int32();
                    break;
                case 11:
                    message.matchResult = reader.int32();
                    break;
                case 12:
                    if (!(message.teamScores && message.teamScores.length))
                        message.teamScores = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.teamScores.push(reader.int32());
                    }
                    else
                        message.teamScores.push(reader.int32());
                    break;
                case 13:
                    message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.reservationStage = reader.int32();
                    break;
                case 15:
                    message.matchDuration = reader.int32();
                    break;
                case 16:
                    if (!(message.enemyKills && message.enemyKills.length))
                        message.enemyKills = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemyKills.push(reader.int32());
                    }
                    else
                        message.enemyKills.push(reader.int32());
                    break;
                case 17:
                    if (!(message.enemyHeadshots && message.enemyHeadshots.length))
                        message.enemyHeadshots = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemyHeadshots.push(reader.int32());
                    }
                    else
                        message.enemyHeadshots.push(reader.int32());
                    break;
                case 18:
                    if (!(message.enemy_3ks && message.enemy_3ks.length))
                        message.enemy_3ks = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemy_3ks.push(reader.int32());
                    }
                    else
                        message.enemy_3ks.push(reader.int32());
                    break;
                case 19:
                    if (!(message.enemy_4ks && message.enemy_4ks.length))
                        message.enemy_4ks = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemy_4ks.push(reader.int32());
                    }
                    else
                        message.enemy_4ks.push(reader.int32());
                    break;
                case 20:
                    if (!(message.enemy_5ks && message.enemy_5ks.length))
                        message.enemy_5ks = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemy_5ks.push(reader.int32());
                    }
                    else
                        message.enemy_5ks.push(reader.int32());
                    break;
                case 21:
                    if (!(message.mvps && message.mvps.length))
                        message.mvps = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.mvps.push(reader.int32());
                    }
                    else
                        message.mvps.push(reader.int32());
                    break;
                case 22:
                    message.spectatorsCount = reader.uint32();
                    break;
                case 23:
                    message.spectatorsCountTv = reader.uint32();
                    break;
                case 24:
                    message.spectatorsCountLnk = reader.uint32();
                    break;
                case 25:
                    if (!(message.enemyKillsAgg && message.enemyKillsAgg.length))
                        message.enemyKillsAgg = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemyKillsAgg.push(reader.int32());
                    }
                    else
                        message.enemyKillsAgg.push(reader.int32());
                    break;
                case 26:
                    message.dropInfo = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo = (function () {
        /**
         * Properties of a DropInfo.
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
         * @interface IDropInfo
         * @property {number|null} [accountMvp] DropInfo accountMvp
         */
        /**
         * Constructs a new DropInfo.
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
         * @classdesc Represents a DropInfo.
         * @implements IDropInfo
         * @constructor
         * @param {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo=} [properties] Properties to set
         */
        function DropInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DropInfo accountMvp.
         * @member {number} accountMvp
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo
         * @instance
         */
        DropInfo.prototype.accountMvp = 0;
        /**
         * Decodes a DropInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo} DropInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DropInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountMvp = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return DropInfo;
    })();
    return CMsgGCCStrike15_v2_MatchmakingServerRoundStats;
})());
exports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = ($root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @interface ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [stats] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm
     * @property {number|Long|null} [rematch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch
     * @property {number|null} [replayToken] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken
     * @property {number|null} [replayClusterId] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId
     * @property {boolean|null} [abortedMatch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch
     * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.
     * @exports CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServerMatchEnd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats.
     * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} stats
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.stats = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.confirm = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch.
     * @member {number|Long} rematch
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.rematch = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken.
     * @member {number} replayToken
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayToken = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId.
     * @member {number} replayClusterId
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayClusterId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch.
     * @member {boolean} abortedMatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.abortedMatch = false;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData.
     * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.matchEndQuestData = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServerMatchEnd} CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stats = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.rematch = reader.uint64();
                    break;
                case 5:
                    message.replayToken = reader.uint32();
                    break;
                case 6:
                    message.replayClusterId = reader.uint32();
                    break;
                case 7:
                    message.abortedMatch = reader.bool();
                    break;
                case 8:
                    message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingServerMatchEnd;
})());
exports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = ($root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.
     * @exports ICMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @interface ICMsgGCCStrike15_v2_MatchmakingClient2GCHello
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2GCHello.
     * @exports CMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.
     * @implements ICMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingClient2GCHello=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingClient2GCHello(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2GCHello message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingClient2GCHello} CMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingClient2GCHello.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingClient2GCHello;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [ongoingmatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch
     * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats
     * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds
     * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason
     * @property {number|null} [vacBanned] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned
     * @property {IPlayerRankingInfo|null} [ranking] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking
     * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation
     * @property {IPlayerMedalsInfo|null} [medals] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals
     * @property {ITournamentEvent|null} [myCurrentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent
     * @property {Array.<ITournamentTeam>|null} [myCurrentEventTeams] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams
     * @property {ITournamentTeam|null} [myCurrentTeam] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam
     * @property {Array.<ITournamentEvent>|null} [myCurrentEventStages] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages
     * @property {number|null} [surveyVote] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote
     * @property {IAccountActivity|null} [activity] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity
     * @property {number|null} [playerLevel] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel
     * @property {number|null} [playerCurXp] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp
     * @property {number|null} [playerXpBonusFlags] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientHello(properties) {
        this.myCurrentEventTeams = [];
        this.myCurrentEventStages = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} ongoingmatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ongoingmatch = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats.
     * @member {IGlobalStatistics|null|undefined} globalStats
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.globalStats = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds.
     * @member {number} penaltySeconds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltySeconds = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason.
     * @member {number} penaltyReason
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltyReason = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned.
     * @member {number} vacBanned
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.vacBanned = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking.
     * @member {IPlayerRankingInfo|null|undefined} ranking
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ranking = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation.
     * @member {IPlayerCommendationInfo|null|undefined} commendation
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.commendation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals.
     * @member {IPlayerMedalsInfo|null|undefined} medals
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.medals = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent.
     * @member {ITournamentEvent|null|undefined} myCurrentEvent
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEvent = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams.
     * @member {Array.<ITournamentTeam>} myCurrentEventTeams
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventTeams =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam.
     * @member {ITournamentTeam|null|undefined} myCurrentTeam
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentTeam = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages.
     * @member {Array.<ITournamentEvent>} myCurrentEventStages
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventStages =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote.
     * @member {number} surveyVote
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.surveyVote = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity.
     * @member {IAccountActivity|null|undefined} activity
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.activity = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel.
     * @member {number} playerLevel
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerLevel = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp.
     * @member {number} playerCurXp
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerCurXp = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags.
     * @member {number} playerXpBonusFlags
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerXpBonusFlags = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientHello} CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.ongoingmatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.penaltySeconds = reader.uint32();
                    break;
                case 5:
                    message.penaltyReason = reader.uint32();
                    break;
                case 6:
                    message.vacBanned = reader.int32();
                    break;
                case 7:
                    message.ranking = $root.PlayerRankingInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.medals = $root.PlayerMedalsInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.myCurrentEvent = $root.TournamentEvent.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.myCurrentEventTeams && message.myCurrentEventTeams.length))
                        message.myCurrentEventTeams = [];
                    message.myCurrentEventTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.myCurrentTeam = $root.TournamentTeam.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.myCurrentEventStages &&
                        message.myCurrentEventStages.length))
                        message.myCurrentEventStages = [];
                    message.myCurrentEventStages.push($root.TournamentEvent.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.surveyVote = reader.uint32();
                    break;
                case 15:
                    message.activity = $root.AccountActivity.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.playerLevel = reader.int32();
                    break;
                case 18:
                    message.playerCurXp = reader.int32();
                    break;
                case 19:
                    message.playerXpBonusFlags = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientHello;
})());
exports.CMsgGCCStrike15_v2_AccountPrivacySettings = ($root.CMsgGCCStrike15_v2_AccountPrivacySettings = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_AccountPrivacySettings.
     * @exports ICMsgGCCStrike15_v2_AccountPrivacySettings
     * @interface ICMsgGCCStrike15_v2_AccountPrivacySettings
     * @property {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>|null} [settings] CMsgGCCStrike15_v2_AccountPrivacySettings settings
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_AccountPrivacySettings.
     * @exports CMsgGCCStrike15_v2_AccountPrivacySettings
     * @classdesc Represents a CMsgGCCStrike15_v2_AccountPrivacySettings.
     * @implements ICMsgGCCStrike15_v2_AccountPrivacySettings
     * @constructor
     * @param {ICMsgGCCStrike15_v2_AccountPrivacySettings=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_AccountPrivacySettings(properties) {
        this.settings = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_AccountPrivacySettings settings.
     * @member {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>} settings
     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
     * @instance
     */
    CMsgGCCStrike15_v2_AccountPrivacySettings.prototype.settings =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_AccountPrivacySettings message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings} CMsgGCCStrike15_v2_AccountPrivacySettings
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_AccountPrivacySettings.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.settings && message.settings.length))
                        message.settings = [];
                    message.settings.push($root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_AccountPrivacySettings.Setting = (function () {
        /**
         * Properties of a Setting.
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
         * @interface ISetting
         * @property {number|null} [settingType] Setting settingType
         * @property {number|null} [settingValue] Setting settingValue
         */
        /**
         * Constructs a new Setting.
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
         * @classdesc Represents a Setting.
         * @implements ISetting
         * @constructor
         * @param {CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting=} [properties] Properties to set
         */
        function Setting(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Setting settingType.
         * @member {number} settingType
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting
         * @instance
         */
        Setting.prototype.settingType = 0;
        /**
         * Setting settingValue.
         * @member {number} settingValue
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting
         * @instance
         */
        Setting.prototype.settingValue = 0;
        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.settingType = reader.uint32();
                        break;
                    case 2:
                        message.settingValue = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Setting;
    })();
    return CMsgGCCStrike15_v2_AccountPrivacySettings;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [abandonedMatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch
     * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds
     * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} abandonedMatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.abandonedMatch = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds.
     * @member {number} penaltySeconds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltySeconds = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason.
     * @member {number} penaltyReason
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltyReason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon} CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.abandonedMatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.penaltySeconds = reader.uint32();
                    break;
                case 4:
                    message.penaltyReason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon;
})());
exports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = ($root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @interface ICMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation
     * @property {number|null} [reason] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServer2GCKick.
     * @exports CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServer2GCKick=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServer2GCKick(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServer2GCKick message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServer2GCKick} CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.reason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingServer2GCKick;
})());
exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate(properties) {
        this.rankings = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings.
     * @member {Array.<IPlayerRankingInfo>} rankings
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.rankings =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.rankings && message.rankings.length))
                        message.rankings = [];
                    message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.matchId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate;
})());
exports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = ($root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.
     * @exports ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @interface ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @property {string|null} [mainPostUrl] CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.
     * @exports CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.
     * @implements ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl.
     * @member {string} mainPostUrl
     * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.prototype.mainPostUrl =
        "";
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate} CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mainPostUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate;
})());
exports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = ($root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.
     * @exports ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @interface ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId
     * @property {number|null} [reason] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason
     * @property {number|null} [seconds] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.
     * @exports CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @classdesc Represents a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.
     * @implements ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ServerNotificationForUserPenalty(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @instance
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @instance
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.reason = 0;
    /**
     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds.
     * @member {number} seconds
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @instance
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.seconds = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ServerNotificationForUserPenalty} CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.reason = reader.uint32();
                    break;
                case 3:
                    message.seconds = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ServerNotificationForUserPenalty;
})());
exports.CMsgGCCStrike15_v2_ClientReportPlayer = ($root.CMsgGCCStrike15_v2_ClientReportPlayer = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientReportPlayer.
     * @exports ICMsgGCCStrike15_v2_ClientReportPlayer
     * @interface ICMsgGCCStrike15_v2_ClientReportPlayer
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportPlayer accountId
     * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot
     * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack
     * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack
     * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm
     * @property {number|null} [rptTextabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse
     * @property {number|null} [rptVoiceabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportPlayer matchId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientReportPlayer.
     * @exports CMsgGCCStrike15_v2_ClientReportPlayer
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportPlayer.
     * @implements ICMsgGCCStrike15_v2_ClientReportPlayer
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientReportPlayer=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientReportPlayer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot.
     * @member {number} rptAimbot
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptAimbot = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack.
     * @member {number} rptWallhack
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptWallhack = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack.
     * @member {number} rptSpeedhack
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptSpeedhack = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm.
     * @member {number} rptTeamharm
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTeamharm = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse.
     * @member {number} rptTextabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTextabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse.
     * @member {number} rptVoiceabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptVoiceabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientReportPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientReportPlayer} CMsgGCCStrike15_v2_ClientReportPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportPlayer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.rptAimbot = reader.uint32();
                    break;
                case 3:
                    message.rptWallhack = reader.uint32();
                    break;
                case 4:
                    message.rptSpeedhack = reader.uint32();
                    break;
                case 5:
                    message.rptTeamharm = reader.uint32();
                    break;
                case 6:
                    message.rptTextabuse = reader.uint32();
                    break;
                case 7:
                    message.rptVoiceabuse = reader.uint32();
                    break;
                case 8:
                    message.matchId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientReportPlayer;
})());
exports.CMsgGCCStrike15_v2_ClientCommendPlayer = ($root.CMsgGCCStrike15_v2_ClientCommendPlayer = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientCommendPlayer.
     * @exports ICMsgGCCStrike15_v2_ClientCommendPlayer
     * @interface ICMsgGCCStrike15_v2_ClientCommendPlayer
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientCommendPlayer accountId
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientCommendPlayer matchId
     * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_ClientCommendPlayer commendation
     * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientCommendPlayer tokens
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientCommendPlayer.
     * @exports CMsgGCCStrike15_v2_ClientCommendPlayer
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientCommendPlayer.
     * @implements ICMsgGCCStrike15_v2_ClientCommendPlayer
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientCommendPlayer=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientCommendPlayer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer commendation.
     * @member {IPlayerCommendationInfo|null|undefined} commendation
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.commendation = null;
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer tokens.
     * @member {number} tokens
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.tokens = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientCommendPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientCommendPlayer} CMsgGCCStrike15_v2_ClientCommendPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientCommendPlayer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 8:
                    message.matchId = reader.uint64();
                    break;
                case 9:
                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.tokens = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientCommendPlayer;
})());
exports.CMsgGCCStrike15_v2_ClientReportServer = ($root.CMsgGCCStrike15_v2_ClientReportServer = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientReportServer.
     * @exports ICMsgGCCStrike15_v2_ClientReportServer
     * @interface ICMsgGCCStrike15_v2_ClientReportServer
     * @property {number|null} [rptPoorperf] CMsgGCCStrike15_v2_ClientReportServer rptPoorperf
     * @property {number|null} [rptAbusivemodels] CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels
     * @property {number|null} [rptBadmotd] CMsgGCCStrike15_v2_ClientReportServer rptBadmotd
     * @property {number|null} [rptListingabuse] CMsgGCCStrike15_v2_ClientReportServer rptListingabuse
     * @property {number|null} [rptInventoryabuse] CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportServer matchId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientReportServer.
     * @exports CMsgGCCStrike15_v2_ClientReportServer
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportServer.
     * @implements ICMsgGCCStrike15_v2_ClientReportServer
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientReportServer=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientReportServer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptPoorperf.
     * @member {number} rptPoorperf
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptPoorperf = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels.
     * @member {number} rptAbusivemodels
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptAbusivemodels = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptBadmotd.
     * @member {number} rptBadmotd
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptBadmotd = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptListingabuse.
     * @member {number} rptListingabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptListingabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse.
     * @member {number} rptInventoryabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptInventoryabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientReportServer message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientReportServer} CMsgGCCStrike15_v2_ClientReportServer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientReportServer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportServer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rptPoorperf = reader.uint32();
                    break;
                case 2:
                    message.rptAbusivemodels = reader.uint32();
                    break;
                case 3:
                    message.rptBadmotd = reader.uint32();
                    break;
                case 4:
                    message.rptListingabuse = reader.uint32();
                    break;
                case 5:
                    message.rptInventoryabuse = reader.uint32();
                    break;
                case 8:
                    message.matchId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientReportServer;
})());
exports.CMsgGCCStrike15_v2_ClientReportResponse = ($root.CMsgGCCStrike15_v2_ClientReportResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientReportResponse.
     * @exports ICMsgGCCStrike15_v2_ClientReportResponse
     * @interface ICMsgGCCStrike15_v2_ClientReportResponse
     * @property {number|Long|null} [confirmationId] CMsgGCCStrike15_v2_ClientReportResponse confirmationId
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportResponse accountId
     * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientReportResponse serverIp
     * @property {number|null} [responseType] CMsgGCCStrike15_v2_ClientReportResponse responseType
     * @property {number|null} [responseResult] CMsgGCCStrike15_v2_ClientReportResponse responseResult
     * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientReportResponse tokens
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientReportResponse.
     * @exports CMsgGCCStrike15_v2_ClientReportResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportResponse.
     * @implements ICMsgGCCStrike15_v2_ClientReportResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientReportResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientReportResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse confirmationId.
     * @member {number|Long} confirmationId
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.confirmationId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse serverIp.
     * @member {number} serverIp
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.serverIp = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse responseType.
     * @member {number} responseType
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseType = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse responseResult.
     * @member {number} responseResult
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseResult = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse tokens.
     * @member {number} tokens
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.tokens = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientReportResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientReportResponse} CMsgGCCStrike15_v2_ClientReportResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientReportResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.confirmationId = reader.uint64();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.serverIp = reader.uint32();
                    break;
                case 4:
                    message.responseType = reader.uint32();
                    break;
                case 5:
                    message.responseResult = reader.uint32();
                    break;
                case 6:
                    message.tokens = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientReportResponse;
})());
exports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = ($root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.
     * @exports ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @interface ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @property {number|null} [requestId] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds
     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid
     * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.
     * @exports CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.
     * @implements ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends(properties) {
        this.accountIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId.
     * @member {number} requestId
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.requestId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.accountIds =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid.
     * @member {number|Long} serverid
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.serverid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid.
     * @member {number|Long} matchid
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.matchid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends} CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 3:
                    message.serverid = reader.uint64();
                    break;
                case 4:
                    message.matchid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends;
})());
exports.WatchableMatchInfo = ($root.WatchableMatchInfo = (() => {
    /**
     * Properties of a WatchableMatchInfo.
     * @exports IWatchableMatchInfo
     * @interface IWatchableMatchInfo
     * @property {number|null} [serverIp] WatchableMatchInfo serverIp
     * @property {number|null} [tvPort] WatchableMatchInfo tvPort
     * @property {number|null} [tvSpectators] WatchableMatchInfo tvSpectators
     * @property {number|null} [tvTime] WatchableMatchInfo tvTime
     * @property {Uint8Array|null} [tvWatchPassword] WatchableMatchInfo tvWatchPassword
     * @property {number|Long|null} [clDecryptdataKey] WatchableMatchInfo clDecryptdataKey
     * @property {number|Long|null} [clDecryptdataKeyPub] WatchableMatchInfo clDecryptdataKeyPub
     * @property {number|null} [gameType] WatchableMatchInfo gameType
     * @property {string|null} [gameMapgroup] WatchableMatchInfo gameMapgroup
     * @property {string|null} [gameMap] WatchableMatchInfo gameMap
     * @property {number|Long|null} [serverId] WatchableMatchInfo serverId
     * @property {number|Long|null} [matchId] WatchableMatchInfo matchId
     * @property {number|Long|null} [reservationId] WatchableMatchInfo reservationId
     */
    /**
     * Constructs a new WatchableMatchInfo.
     * @exports WatchableMatchInfo
     * @classdesc Represents a WatchableMatchInfo.
     * @implements IWatchableMatchInfo
     * @constructor
     * @param {IWatchableMatchInfo=} [properties] Properties to set
     */
    function WatchableMatchInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * WatchableMatchInfo serverIp.
     * @member {number} serverIp
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.serverIp = 0;
    /**
     * WatchableMatchInfo tvPort.
     * @member {number} tvPort
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvPort = 0;
    /**
     * WatchableMatchInfo tvSpectators.
     * @member {number} tvSpectators
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvSpectators = 0;
    /**
     * WatchableMatchInfo tvTime.
     * @member {number} tvTime
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvTime = 0;
    /**
     * WatchableMatchInfo tvWatchPassword.
     * @member {Uint8Array} tvWatchPassword
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvWatchPassword = $util.newBuffer([]);
    /**
     * WatchableMatchInfo clDecryptdataKey.
     * @member {number|Long} clDecryptdataKey
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.clDecryptdataKey = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * WatchableMatchInfo clDecryptdataKeyPub.
     * @member {number|Long} clDecryptdataKeyPub
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.clDecryptdataKeyPub = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * WatchableMatchInfo gameType.
     * @member {number} gameType
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.gameType = 0;
    /**
     * WatchableMatchInfo gameMapgroup.
     * @member {string} gameMapgroup
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.gameMapgroup = "";
    /**
     * WatchableMatchInfo gameMap.
     * @member {string} gameMap
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.gameMap = "";
    /**
     * WatchableMatchInfo serverId.
     * @member {number|Long} serverId
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.serverId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * WatchableMatchInfo matchId.
     * @member {number|Long} matchId
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * WatchableMatchInfo reservationId.
     * @member {number|Long} reservationId
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.reservationId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a WatchableMatchInfo message from the specified reader or buffer.
     * @function decode
     * @memberof WatchableMatchInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WatchableMatchInfo} WatchableMatchInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WatchableMatchInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WatchableMatchInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.serverIp = reader.uint32();
                    break;
                case 2:
                    message.tvPort = reader.uint32();
                    break;
                case 3:
                    message.tvSpectators = reader.uint32();
                    break;
                case 4:
                    message.tvTime = reader.uint32();
                    break;
                case 5:
                    message.tvWatchPassword = reader.bytes();
                    break;
                case 6:
                    message.clDecryptdataKey = reader.uint64();
                    break;
                case 7:
                    message.clDecryptdataKeyPub = reader.uint64();
                    break;
                case 8:
                    message.gameType = reader.uint32();
                    break;
                case 9:
                    message.gameMapgroup = reader.string();
                    break;
                case 10:
                    message.gameMap = reader.string();
                    break;
                case 11:
                    message.serverId = reader.uint64();
                    break;
                case 12:
                    message.matchId = reader.uint64();
                    break;
                case 13:
                    message.reservationId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return WatchableMatchInfo;
})());
exports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = ($root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.
     * @exports ICMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @interface ICMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinFriendData version
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId
     * @property {number|null} [joinToken] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken
     * @property {number|null} [joinIpp] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinFriendData res
     * @property {string|null} [errormsg] CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinFriendData.
     * @exports CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.
     * @implements ICMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestJoinFriendData=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestJoinFriendData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData version.
     * @member {number} version
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.version = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken.
     * @member {number} joinToken
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinToken = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp.
     * @member {number} joinIpp
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinIpp = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData res.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.res = null;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg.
     * @member {string} errormsg
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.errormsg = "";
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinFriendData message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestJoinFriendData} CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.joinToken = reader.uint32();
                    break;
                case 4:
                    message.joinIpp = reader.uint32();
                    break;
                case 5:
                    message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.errormsg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestJoinFriendData;
})());
exports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = ($root.CMsgGCCStrike15_v2_ClientRequestJoinServerData = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinServerData.
     * @exports ICMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @interface ICMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinServerData version
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId
     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid
     * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp
     * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinServerData res
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinServerData.
     * @exports CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinServerData.
     * @implements ICMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestJoinServerData=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestJoinServerData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData version.
     * @member {number} version
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.version = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid.
     * @member {number|Long} serverid
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp.
     * @member {number} serverIp
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverIp = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort.
     * @member {number} serverPort
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverPort = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData res.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.res = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinServerData message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestJoinServerData} CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinServerData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.serverid = reader.uint64();
                    break;
                case 4:
                    message.serverIp = reader.uint32();
                    break;
                case 5:
                    message.serverPort = reader.uint32();
                    break;
                case 6:
                    message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestJoinServerData;
})());
exports.CMsgGCCstrike15_v2_ClientRequestNewMission = ($root.CMsgGCCstrike15_v2_ClientRequestNewMission = (() => {
    /**
     * Properties of a CMsgGCCstrike15_v2_ClientRequestNewMission.
     * @exports ICMsgGCCstrike15_v2_ClientRequestNewMission
     * @interface ICMsgGCCstrike15_v2_ClientRequestNewMission
     * @property {number|null} [missionId] CMsgGCCstrike15_v2_ClientRequestNewMission missionId
     * @property {number|null} [campaignId] CMsgGCCstrike15_v2_ClientRequestNewMission campaignId
     */
    /**
     * Constructs a new CMsgGCCstrike15_v2_ClientRequestNewMission.
     * @exports CMsgGCCstrike15_v2_ClientRequestNewMission
     * @classdesc Represents a CMsgGCCstrike15_v2_ClientRequestNewMission.
     * @implements ICMsgGCCstrike15_v2_ClientRequestNewMission
     * @constructor
     * @param {ICMsgGCCstrike15_v2_ClientRequestNewMission=} [properties] Properties to set
     */
    function CMsgGCCstrike15_v2_ClientRequestNewMission(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCstrike15_v2_ClientRequestNewMission missionId.
     * @member {number} missionId
     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission
     * @instance
     */
    CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.missionId = 0;
    /**
     * CMsgGCCstrike15_v2_ClientRequestNewMission campaignId.
     * @member {number} campaignId
     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission
     * @instance
     */
    CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.campaignId = 0;
    /**
     * Decodes a CMsgGCCstrike15_v2_ClientRequestNewMission message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCstrike15_v2_ClientRequestNewMission} CMsgGCCstrike15_v2_ClientRequestNewMission
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCstrike15_v2_ClientRequestNewMission.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCstrike15_v2_ClientRequestNewMission();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.missionId = reader.uint32();
                    break;
                case 3:
                    message.campaignId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCstrike15_v2_ClientRequestNewMission;
})());
exports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = ($root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = (() => {
    /**
     * Properties of a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.
     * @exports ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @interface ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @property {Array.<IXpProgressData>|null} [xpProgressData] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData
     * @property {number|null} [accountId] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId
     * @property {number|null} [currentXp] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp
     * @property {number|null} [currentLevel] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel
     * @property {number|null} [upgradedDefidx] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx
     */
    /**
     * Constructs a new CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.
     * @exports CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @classdesc Represents a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.
     * @implements ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @constructor
     * @param {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded=} [properties] Properties to set
     */
    function CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded(properties) {
        this.xpProgressData = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData.
     * @member {Array.<IXpProgressData>} xpProgressData
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.xpProgressData =
        $util.emptyArray;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId.
     * @member {number} accountId
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.accountId = 0;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp.
     * @member {number} currentXp
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentXp = 0;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel.
     * @member {number} currentLevel
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentLevel = 0;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx.
     * @member {number} upgradedDefidx
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.upgradedDefidx = 0;
    /**
     * Decodes a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded} CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.xpProgressData && message.xpProgressData.length))
                        message.xpProgressData = [];
                    message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.currentXp = reader.uint32();
                    break;
                case 4:
                    message.currentLevel = reader.uint32();
                    break;
                case 5:
                    message.upgradedDefidx = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded;
})());
exports.CMsgGCCStrike15_v2_WatchInfoUsers = ($root.CMsgGCCStrike15_v2_WatchInfoUsers = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_WatchInfoUsers.
     * @exports ICMsgGCCStrike15_v2_WatchInfoUsers
     * @interface ICMsgGCCStrike15_v2_WatchInfoUsers
     * @property {number|null} [requestId] CMsgGCCStrike15_v2_WatchInfoUsers requestId
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_WatchInfoUsers accountIds
     * @property {Array.<IWatchableMatchInfo>|null} [watchableMatchInfos] CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos
     * @property {number|null} [extendedTimeout] CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_WatchInfoUsers.
     * @exports CMsgGCCStrike15_v2_WatchInfoUsers
     * @classdesc Represents a CMsgGCCStrike15_v2_WatchInfoUsers.
     * @implements ICMsgGCCStrike15_v2_WatchInfoUsers
     * @constructor
     * @param {ICMsgGCCStrike15_v2_WatchInfoUsers=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_WatchInfoUsers(properties) {
        this.accountIds = [];
        this.watchableMatchInfos = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers requestId.
     * @member {number} requestId
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.requestId = 0;
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.accountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos.
     * @member {Array.<IWatchableMatchInfo>} watchableMatchInfos
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.watchableMatchInfos =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout.
     * @member {number} extendedTimeout
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.extendedTimeout = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_WatchInfoUsers message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_WatchInfoUsers} CMsgGCCStrike15_v2_WatchInfoUsers
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_WatchInfoUsers();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 3:
                    if (!(message.watchableMatchInfos && message.watchableMatchInfos.length))
                        message.watchableMatchInfos = [];
                    message.watchableMatchInfos.push($root.WatchableMatchInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.extendedTimeout = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_WatchInfoUsers;
})());
exports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = ($root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.
     * @exports ICMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @interface ICMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @property {number|null} [requestId_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated
     * @property {Array.<number>|null} [accountIds_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId
     * @property {number|null} [requestLevel] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestPlayersProfile.
     * @exports CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.
     * @implements ICMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestPlayersProfile=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestPlayersProfile(properties) {
        this.accountIds_Deprecated = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated.
     * @member {number} requestId_Deprecated
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestId_Deprecated = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated.
     * @member {Array.<number>} accountIds_Deprecated
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountIds_Deprecated =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel.
     * @member {number} requestLevel
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestLevel = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestPlayersProfile message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestPlayersProfile} CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId_Deprecated = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountIds_Deprecated &&
                        message.accountIds_Deprecated.length))
                        message.accountIds_Deprecated = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds_Deprecated.push(reader.uint32());
                    }
                    else
                        message.accountIds_Deprecated.push(reader.uint32());
                    break;
                case 3:
                    message.accountId = reader.uint32();
                    break;
                case 4:
                    message.requestLevel = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestPlayersProfile;
})());
exports.CMsgGCCStrike15_v2_PlayersProfile = ($root.CMsgGCCStrike15_v2_PlayersProfile = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayersProfile.
     * @exports ICMsgGCCStrike15_v2_PlayersProfile
     * @interface ICMsgGCCStrike15_v2_PlayersProfile
     * @property {number|null} [requestId] CMsgGCCStrike15_v2_PlayersProfile requestId
     * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>|null} [accountProfiles] CMsgGCCStrike15_v2_PlayersProfile accountProfiles
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayersProfile.
     * @exports CMsgGCCStrike15_v2_PlayersProfile
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayersProfile.
     * @implements ICMsgGCCStrike15_v2_PlayersProfile
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayersProfile=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayersProfile(properties) {
        this.accountProfiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayersProfile requestId.
     * @member {number} requestId
     * @memberof CMsgGCCStrike15_v2_PlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_PlayersProfile.prototype.requestId = 0;
    /**
     * CMsgGCCStrike15_v2_PlayersProfile accountProfiles.
     * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>} accountProfiles
     * @memberof CMsgGCCStrike15_v2_PlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_PlayersProfile.prototype.accountProfiles =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayersProfile message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayersProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayersProfile} CMsgGCCStrike15_v2_PlayersProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayersProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayersProfile();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountProfiles && message.accountProfiles.length))
                        message.accountProfiles = [];
                    message.accountProfiles.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayersProfile;
})());
exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = ($root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.
     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid
     * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid
     * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid
     * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot
     * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack
     * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack
     * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm
     * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.
     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.
     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid.
     * @member {number|Long} caseid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.caseid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid.
     * @member {number} suspectid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.suspectid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid.
     * @member {number} fractionid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.fractionid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot.
     * @member {number} rptAimbot
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptAimbot = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack.
     * @member {number} rptWallhack
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptWallhack = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack.
     * @member {number} rptSpeedhack
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptSpeedhack = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm.
     * @member {number} rptTeamharm
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptTeamharm = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.reason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate} CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.caseid = reader.uint64();
                    break;
                case 3:
                    message.suspectid = reader.uint32();
                    break;
                case 4:
                    message.fractionid = reader.uint32();
                    break;
                case 5:
                    message.rptAimbot = reader.uint32();
                    break;
                case 6:
                    message.rptWallhack = reader.uint32();
                    break;
                case 7:
                    message.rptSpeedhack = reader.uint32();
                    break;
                case 8:
                    message.rptTeamharm = reader.uint32();
                    break;
                case 9:
                    message.reason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate;
})());
exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = ($root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.
     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid
     * @property {string|null} [caseurl] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl
     * @property {number|null} [verdict] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict
     * @property {number|null} [timestamp] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp
     * @property {number|null} [throttleseconds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds
     * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid
     * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid
     * @property {number|null} [numrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds
     * @property {number|null} [fractionrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds
     * @property {number|null} [streakconvictions] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions
     * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.
     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.
     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid.
     * @member {number|Long} caseid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl.
     * @member {string} caseurl
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseurl = "";
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict.
     * @member {number} verdict
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.verdict = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp.
     * @member {number} timestamp
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.timestamp = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds.
     * @member {number} throttleseconds
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.throttleseconds = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid.
     * @member {number} suspectid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.suspectid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid.
     * @member {number} fractionid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds.
     * @member {number} numrounds
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.numrounds = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds.
     * @member {number} fractionrounds
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionrounds = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions.
     * @member {number} streakconvictions
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.streakconvictions = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.reason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment} CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.caseid = reader.uint64();
                    break;
                case 2:
                    message.caseurl = reader.string();
                    break;
                case 3:
                    message.verdict = reader.uint32();
                    break;
                case 4:
                    message.timestamp = reader.uint32();
                    break;
                case 5:
                    message.throttleseconds = reader.uint32();
                    break;
                case 6:
                    message.suspectid = reader.uint32();
                    break;
                case 7:
                    message.fractionid = reader.uint32();
                    break;
                case 8:
                    message.numrounds = reader.uint32();
                    break;
                case 9:
                    message.fractionrounds = reader.uint32();
                    break;
                case 10:
                    message.streakconvictions = reader.int32();
                    break;
                case 11:
                    message.reason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment;
})());
exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = ($root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.
     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid
     * @property {number|null} [statusid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.
     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.
     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid.
     * @member {number|Long} caseid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.caseid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid.
     * @member {number} statusid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.statusid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus} CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.caseid = reader.uint64();
                    break;
                case 2:
                    message.statusid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus;
})());
exports.CClientHeaderOverwatchEvidence = ($root.CClientHeaderOverwatchEvidence = (() => {
    /**
     * Properties of a CClientHeaderOverwatchEvidence.
     * @exports ICClientHeaderOverwatchEvidence
     * @interface ICClientHeaderOverwatchEvidence
     * @property {number|null} [accountid] CClientHeaderOverwatchEvidence accountid
     * @property {number|Long|null} [caseid] CClientHeaderOverwatchEvidence caseid
     */
    /**
     * Constructs a new CClientHeaderOverwatchEvidence.
     * @exports CClientHeaderOverwatchEvidence
     * @classdesc Represents a CClientHeaderOverwatchEvidence.
     * @implements ICClientHeaderOverwatchEvidence
     * @constructor
     * @param {ICClientHeaderOverwatchEvidence=} [properties] Properties to set
     */
    function CClientHeaderOverwatchEvidence(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CClientHeaderOverwatchEvidence accountid.
     * @member {number} accountid
     * @memberof CClientHeaderOverwatchEvidence
     * @instance
     */
    CClientHeaderOverwatchEvidence.prototype.accountid = 0;
    /**
     * CClientHeaderOverwatchEvidence caseid.
     * @member {number|Long} caseid
     * @memberof CClientHeaderOverwatchEvidence
     * @instance
     */
    CClientHeaderOverwatchEvidence.prototype.caseid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CClientHeaderOverwatchEvidence message from the specified reader or buffer.
     * @function decode
     * @memberof CClientHeaderOverwatchEvidence
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CClientHeaderOverwatchEvidence} CClientHeaderOverwatchEvidence
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CClientHeaderOverwatchEvidence.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CClientHeaderOverwatchEvidence();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.caseid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CClientHeaderOverwatchEvidence;
})());
exports.CMsgGCCStrike15_v2_GC2ClientTextMsg = ($root.CMsgGCCStrike15_v2_GC2ClientTextMsg = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GC2ClientTextMsg.
     * @exports ICMsgGCCStrike15_v2_GC2ClientTextMsg
     * @interface ICMsgGCCStrike15_v2_GC2ClientTextMsg
     * @property {number|null} [id] CMsgGCCStrike15_v2_GC2ClientTextMsg id
     * @property {number|null} [type] CMsgGCCStrike15_v2_GC2ClientTextMsg type
     * @property {Uint8Array|null} [payload] CMsgGCCStrike15_v2_GC2ClientTextMsg payload
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GC2ClientTextMsg.
     * @exports CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTextMsg.
     * @implements ICMsgGCCStrike15_v2_GC2ClientTextMsg
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GC2ClientTextMsg=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GC2ClientTextMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GC2ClientTextMsg id.
     * @member {number} id
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.id = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTextMsg type.
     * @member {number} type
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.type = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTextMsg payload.
     * @member {Uint8Array} payload
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.payload = $util.newBuffer([]);
    /**
     * Decodes a CMsgGCCStrike15_v2_GC2ClientTextMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GC2ClientTextMsg} CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ClientTextMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GC2ClientTextMsg;
})());
exports.CMsgGCCStrike15_v2_Client2GCTextMsg = ($root.CMsgGCCStrike15_v2_Client2GCTextMsg = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCTextMsg.
     * @exports ICMsgGCCStrike15_v2_Client2GCTextMsg
     * @interface ICMsgGCCStrike15_v2_Client2GCTextMsg
     * @property {number|null} [id] CMsgGCCStrike15_v2_Client2GCTextMsg id
     * @property {Array.<Uint8Array>|null} [args] CMsgGCCStrike15_v2_Client2GCTextMsg args
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCTextMsg.
     * @exports CMsgGCCStrike15_v2_Client2GCTextMsg
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCTextMsg.
     * @implements ICMsgGCCStrike15_v2_Client2GCTextMsg
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCTextMsg=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCTextMsg(properties) {
        this.args = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCTextMsg id.
     * @member {number} id
     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.id = 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCTextMsg args.
     * @member {Array.<Uint8Array>} args
     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.args = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCTextMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCTextMsg} CMsgGCCStrike15_v2_Client2GCTextMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCTextMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCTextMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    if (!(message.args && message.args.length))
                        message.args = [];
                    message.args.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCTextMsg;
})());
exports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = ($root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.
     * @exports ICMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @interface ICMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @property {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null} [serverinfo] CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo
     * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchEndRunRewardDrops.
     * @exports CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.
     * @implements ICMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchEndRunRewardDrops=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchEndRunRewardDrops(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo.
     * @member {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null|undefined} serverinfo
     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @instance
     */
    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.serverinfo = null;
    /**
     * CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData.
     * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData
     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @instance
     */
    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.matchEndQuestData = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchEndRunRewardDrops message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchEndRunRewardDrops} CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.serverinfo = $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchEndRunRewardDrops;
})());
exports.CEconItemPreviewDataBlock = ($root.CEconItemPreviewDataBlock = (() => {
    /**
     * Properties of a CEconItemPreviewDataBlock.
     * @exports ICEconItemPreviewDataBlock
     * @interface ICEconItemPreviewDataBlock
     * @property {number|null} [accountid] CEconItemPreviewDataBlock accountid
     * @property {number|Long|null} [itemid] CEconItemPreviewDataBlock itemid
     * @property {number|null} [defindex] CEconItemPreviewDataBlock defindex
     * @property {number|null} [paintindex] CEconItemPreviewDataBlock paintindex
     * @property {number|null} [rarity] CEconItemPreviewDataBlock rarity
     * @property {number|null} [quality] CEconItemPreviewDataBlock quality
     * @property {number|null} [paintwear] CEconItemPreviewDataBlock paintwear
     * @property {number|null} [paintseed] CEconItemPreviewDataBlock paintseed
     * @property {number|null} [killeaterscoretype] CEconItemPreviewDataBlock killeaterscoretype
     * @property {number|null} [killeatervalue] CEconItemPreviewDataBlock killeatervalue
     * @property {string|null} [customname] CEconItemPreviewDataBlock customname
     * @property {Array.<CEconItemPreviewDataBlock.ISticker>|null} [stickers] CEconItemPreviewDataBlock stickers
     * @property {number|null} [inventory] CEconItemPreviewDataBlock inventory
     * @property {number|null} [origin] CEconItemPreviewDataBlock origin
     * @property {number|null} [questid] CEconItemPreviewDataBlock questid
     * @property {number|null} [dropreason] CEconItemPreviewDataBlock dropreason
     */
    /**
     * Constructs a new CEconItemPreviewDataBlock.
     * @exports CEconItemPreviewDataBlock
     * @classdesc Represents a CEconItemPreviewDataBlock.
     * @implements ICEconItemPreviewDataBlock
     * @constructor
     * @param {ICEconItemPreviewDataBlock=} [properties] Properties to set
     */
    function CEconItemPreviewDataBlock(properties) {
        this.stickers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CEconItemPreviewDataBlock accountid.
     * @member {number} accountid
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.accountid = 0;
    /**
     * CEconItemPreviewDataBlock itemid.
     * @member {number|Long} itemid
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.itemid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CEconItemPreviewDataBlock defindex.
     * @member {number} defindex
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.defindex = 0;
    /**
     * CEconItemPreviewDataBlock paintindex.
     * @member {number} paintindex
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.paintindex = 0;
    /**
     * CEconItemPreviewDataBlock rarity.
     * @member {number} rarity
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.rarity = 0;
    /**
     * CEconItemPreviewDataBlock quality.
     * @member {number} quality
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.quality = 0;
    /**
     * CEconItemPreviewDataBlock paintwear.
     * @member {number} paintwear
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.paintwear = 0;
    /**
     * CEconItemPreviewDataBlock paintseed.
     * @member {number} paintseed
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.paintseed = 0;
    /**
     * CEconItemPreviewDataBlock killeaterscoretype.
     * @member {number} killeaterscoretype
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.killeaterscoretype = 0;
    /**
     * CEconItemPreviewDataBlock killeatervalue.
     * @member {number} killeatervalue
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.killeatervalue = 0;
    /**
     * CEconItemPreviewDataBlock customname.
     * @member {string} customname
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.customname = "";
    /**
     * CEconItemPreviewDataBlock stickers.
     * @member {Array.<CEconItemPreviewDataBlock.ISticker>} stickers
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.stickers = $util.emptyArray;
    /**
     * CEconItemPreviewDataBlock inventory.
     * @member {number} inventory
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.inventory = 0;
    /**
     * CEconItemPreviewDataBlock origin.
     * @member {number} origin
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.origin = 0;
    /**
     * CEconItemPreviewDataBlock questid.
     * @member {number} questid
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.questid = 0;
    /**
     * CEconItemPreviewDataBlock dropreason.
     * @member {number} dropreason
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.dropreason = 0;
    /**
     * Decodes a CEconItemPreviewDataBlock message from the specified reader or buffer.
     * @function decode
     * @memberof CEconItemPreviewDataBlock
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CEconItemPreviewDataBlock} CEconItemPreviewDataBlock
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CEconItemPreviewDataBlock.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEconItemPreviewDataBlock();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.itemid = reader.uint64();
                    break;
                case 3:
                    message.defindex = reader.uint32();
                    break;
                case 4:
                    message.paintindex = reader.uint32();
                    break;
                case 5:
                    message.rarity = reader.uint32();
                    break;
                case 6:
                    message.quality = reader.uint32();
                    break;
                case 7:
                    message.paintwear = reader.uint32();
                    break;
                case 8:
                    message.paintseed = reader.uint32();
                    break;
                case 9:
                    message.killeaterscoretype = reader.uint32();
                    break;
                case 10:
                    message.killeatervalue = reader.uint32();
                    break;
                case 11:
                    message.customname = reader.string();
                    break;
                case 12:
                    if (!(message.stickers && message.stickers.length))
                        message.stickers = [];
                    message.stickers.push($root.CEconItemPreviewDataBlock.Sticker.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.inventory = reader.uint32();
                    break;
                case 14:
                    message.origin = reader.uint32();
                    break;
                case 15:
                    message.questid = reader.uint32();
                    break;
                case 16:
                    message.dropreason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CEconItemPreviewDataBlock.Sticker = (function () {
        /**
         * Properties of a Sticker.
         * @memberof CEconItemPreviewDataBlock
         * @interface ISticker
         * @property {number|null} [slot] Sticker slot
         * @property {number|null} [stickerId] Sticker stickerId
         * @property {number|null} [wear] Sticker wear
         * @property {number|null} [scale] Sticker scale
         * @property {number|null} [rotation] Sticker rotation
         */
        /**
         * Constructs a new Sticker.
         * @memberof CEconItemPreviewDataBlock
         * @classdesc Represents a Sticker.
         * @implements ISticker
         * @constructor
         * @param {CEconItemPreviewDataBlock.ISticker=} [properties] Properties to set
         */
        function Sticker(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Sticker slot.
         * @member {number} slot
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.slot = 0;
        /**
         * Sticker stickerId.
         * @member {number} stickerId
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.stickerId = 0;
        /**
         * Sticker wear.
         * @member {number} wear
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.wear = 0;
        /**
         * Sticker scale.
         * @member {number} scale
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.scale = 0;
        /**
         * Sticker rotation.
         * @member {number} rotation
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.rotation = 0;
        /**
         * Decodes a Sticker message from the specified reader or buffer.
         * @function decode
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEconItemPreviewDataBlock.Sticker} Sticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Sticker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEconItemPreviewDataBlock.Sticker();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.slot = reader.uint32();
                        break;
                    case 2:
                        message.stickerId = reader.uint32();
                        break;
                    case 3:
                        message.wear = reader.float();
                        break;
                    case 4:
                        message.scale = reader.float();
                        break;
                    case 5:
                        message.rotation = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Sticker;
    })();
    return CEconItemPreviewDataBlock;
})());
exports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = ($root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.
     * @exports ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @interface ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.
     * @exports CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.
     * @implements ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchEndRewardDropsNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.prototype.iteminfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchEndRewardDropsNotification} CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 6:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchEndRewardDropsNotification;
})());
exports.CMsgItemAcknowledged = ($root.CMsgItemAcknowledged = (() => {
    /**
     * Properties of a CMsgItemAcknowledged.
     * @exports ICMsgItemAcknowledged
     * @interface ICMsgItemAcknowledged
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgItemAcknowledged iteminfo
     */
    /**
     * Constructs a new CMsgItemAcknowledged.
     * @exports CMsgItemAcknowledged
     * @classdesc Represents a CMsgItemAcknowledged.
     * @implements ICMsgItemAcknowledged
     * @constructor
     * @param {ICMsgItemAcknowledged=} [properties] Properties to set
     */
    function CMsgItemAcknowledged(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgItemAcknowledged iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CMsgItemAcknowledged
     * @instance
     */
    CMsgItemAcknowledged.prototype.iteminfo = null;
    /**
     * Decodes a CMsgItemAcknowledged message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgItemAcknowledged
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgItemAcknowledged} CMsgItemAcknowledged
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgItemAcknowledged.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgItemAcknowledged();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgItemAcknowledged;
})());
exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = ($root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.
     * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @property {number|Long|null} [paramS] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS
     * @property {number|Long|null} [paramA] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA
     * @property {number|Long|null} [paramD] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD
     * @property {number|Long|null} [paramM] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.
     * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.
     * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS.
     * @member {number|Long} paramS
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramS = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA.
     * @member {number|Long} paramA
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramA = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD.
     * @member {number|Long} paramD
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramD = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM.
     * @member {number|Long} paramM
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramM = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paramS = reader.uint64();
                    break;
                case 2:
                    message.paramA = reader.uint64();
                    break;
                case 3:
                    message.paramD = reader.uint64();
                    break;
                case 4:
                    message.paramM = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest;
})());
exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = ($root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.
     * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.
     * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.
     * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.prototype.iteminfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse;
})());
exports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = ($root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.
     * @exports ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @interface ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId
     * @property {number|null} [defindex] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex
     * @property {Array.<number>|null} [accountids] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.
     * @exports CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @classdesc Represents a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.
     * @implements ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @constructor
     * @param {ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification(properties) {
        this.accountids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.matchId = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex.
     * @member {number} defindex
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.defindex = 0;
    /**
     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids.
     * @member {Array.<number>} accountids
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.accountids =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification} CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchId = reader.uint64();
                    break;
                case 2:
                    message.defindex = reader.uint32();
                    break;
                case 3:
                    if (!(message.accountids && message.accountids.length))
                        message.accountids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountids.push(reader.uint32());
                    }
                    else
                        message.accountids.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification;
})());
exports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = ($root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @interface ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.
     * @exports CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames} CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames;
})());
exports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = ($root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @interface ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.
     * @exports CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.prototype.accountid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser} CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser;
})());
exports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = ($root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @interface ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.
     * @exports CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestRecentUserGames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.prototype.accountid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestRecentUserGames} CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestRecentUserGames;
})());
exports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = ($root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @interface ICMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @property {number|null} [eventid] CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestTournamentGames.
     * @exports CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestTournamentGames=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestTournamentGames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid.
     * @member {number} eventid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestTournamentGames.prototype.eventid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestTournamentGames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestTournamentGames} CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestTournamentGames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventid = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestTournamentGames;
})());
exports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = ($root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @interface ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid
     * @property {number|Long|null} [outcomeid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid
     * @property {number|null} [token] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.
     * @exports CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestFullGameInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid.
     * @member {number|Long} matchid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.matchid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid.
     * @member {number|Long} outcomeid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.outcomeid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token.
     * @member {number} token
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.token = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestFullGameInfo} CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchid = reader.uint64();
                    break;
                case 2:
                    message.outcomeid = reader.uint64();
                    break;
                case 3:
                    message.token = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestFullGameInfo;
})());
exports.CDataGCCStrike15_v2_MatchInfo = ($root.CDataGCCStrike15_v2_MatchInfo = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_MatchInfo.
     * @exports ICDataGCCStrike15_v2_MatchInfo
     * @interface ICDataGCCStrike15_v2_MatchInfo
     * @property {number|Long|null} [matchid] CDataGCCStrike15_v2_MatchInfo matchid
     * @property {number|null} [matchtime] CDataGCCStrike15_v2_MatchInfo matchtime
     * @property {IWatchableMatchInfo|null} [watchablematchinfo] CDataGCCStrike15_v2_MatchInfo watchablematchinfo
     * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [roundstatsLegacy] CDataGCCStrike15_v2_MatchInfo roundstatsLegacy
     * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>|null} [roundstatsall] CDataGCCStrike15_v2_MatchInfo roundstatsall
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_MatchInfo.
     * @exports CDataGCCStrike15_v2_MatchInfo
     * @classdesc Represents a CDataGCCStrike15_v2_MatchInfo.
     * @implements ICDataGCCStrike15_v2_MatchInfo
     * @constructor
     * @param {ICDataGCCStrike15_v2_MatchInfo=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_MatchInfo(properties) {
        this.roundstatsall = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_MatchInfo matchid.
     * @member {number|Long} matchid
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.matchid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CDataGCCStrike15_v2_MatchInfo matchtime.
     * @member {number} matchtime
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.matchtime = 0;
    /**
     * CDataGCCStrike15_v2_MatchInfo watchablematchinfo.
     * @member {IWatchableMatchInfo|null|undefined} watchablematchinfo
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.watchablematchinfo = null;
    /**
     * CDataGCCStrike15_v2_MatchInfo roundstatsLegacy.
     * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} roundstatsLegacy
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsLegacy = null;
    /**
     * CDataGCCStrike15_v2_MatchInfo roundstatsall.
     * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>} roundstatsall
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsall = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_MatchInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_MatchInfo} CDataGCCStrike15_v2_MatchInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_MatchInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_MatchInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchid = reader.uint64();
                    break;
                case 2:
                    message.matchtime = reader.uint32();
                    break;
                case 3:
                    message.watchablematchinfo = $root.WatchableMatchInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.roundstatsLegacy = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.roundstatsall && message.roundstatsall.length))
                        message.roundstatsall = [];
                    message.roundstatsall.push($root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_MatchInfo;
})());
exports.CDataGCCStrike15_v2_TournamentGroupTeam = ($root.CDataGCCStrike15_v2_TournamentGroupTeam = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentGroupTeam.
     * @exports ICDataGCCStrike15_v2_TournamentGroupTeam
     * @interface ICDataGCCStrike15_v2_TournamentGroupTeam
     * @property {number|null} [teamId] CDataGCCStrike15_v2_TournamentGroupTeam teamId
     * @property {number|null} [score] CDataGCCStrike15_v2_TournamentGroupTeam score
     * @property {boolean|null} [correctpick] CDataGCCStrike15_v2_TournamentGroupTeam correctpick
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentGroupTeam.
     * @exports CDataGCCStrike15_v2_TournamentGroupTeam
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroupTeam.
     * @implements ICDataGCCStrike15_v2_TournamentGroupTeam
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentGroupTeam=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentGroupTeam(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentGroupTeam teamId.
     * @member {number} teamId
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.teamId = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroupTeam score.
     * @member {number} score
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.score = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroupTeam correctpick.
     * @member {boolean} correctpick
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.correctpick = false;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentGroupTeam message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentGroupTeam} CDataGCCStrike15_v2_TournamentGroupTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroupTeam();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.teamId = reader.int32();
                    break;
                case 2:
                    message.score = reader.int32();
                    break;
                case 3:
                    message.correctpick = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_TournamentGroupTeam;
})());
exports.CDataGCCStrike15_v2_TournamentGroup = ($root.CDataGCCStrike15_v2_TournamentGroup = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentGroup.
     * @exports ICDataGCCStrike15_v2_TournamentGroup
     * @interface ICDataGCCStrike15_v2_TournamentGroup
     * @property {number|null} [groupid] CDataGCCStrike15_v2_TournamentGroup groupid
     * @property {string|null} [name] CDataGCCStrike15_v2_TournamentGroup name
     * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentGroup desc
     * @property {number|null} [picks_Deprecated] CDataGCCStrike15_v2_TournamentGroup picks_Deprecated
     * @property {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>|null} [teams] CDataGCCStrike15_v2_TournamentGroup teams
     * @property {Array.<number>|null} [stageIds] CDataGCCStrike15_v2_TournamentGroup stageIds
     * @property {number|null} [picklockuntiltime] CDataGCCStrike15_v2_TournamentGroup picklockuntiltime
     * @property {number|null} [pickableteams] CDataGCCStrike15_v2_TournamentGroup pickableteams
     * @property {number|null} [pointsPerPick] CDataGCCStrike15_v2_TournamentGroup pointsPerPick
     * @property {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>|null} [picks] CDataGCCStrike15_v2_TournamentGroup picks
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentGroup.
     * @exports CDataGCCStrike15_v2_TournamentGroup
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroup.
     * @implements ICDataGCCStrike15_v2_TournamentGroup
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentGroup=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentGroup(properties) {
        this.teams = [];
        this.stageIds = [];
        this.picks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentGroup groupid.
     * @member {number} groupid
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.groupid = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup name.
     * @member {string} name
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.name = "";
    /**
     * CDataGCCStrike15_v2_TournamentGroup desc.
     * @member {string} desc
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.desc = "";
    /**
     * CDataGCCStrike15_v2_TournamentGroup picks_Deprecated.
     * @member {number} picks_Deprecated
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.picks_Deprecated = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup teams.
     * @member {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>} teams
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.teams = $util.emptyArray;
    /**
     * CDataGCCStrike15_v2_TournamentGroup stageIds.
     * @member {Array.<number>} stageIds
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.stageIds = $util.emptyArray;
    /**
     * CDataGCCStrike15_v2_TournamentGroup picklockuntiltime.
     * @member {number} picklockuntiltime
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.picklockuntiltime = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup pickableteams.
     * @member {number} pickableteams
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.pickableteams = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup pointsPerPick.
     * @member {number} pointsPerPick
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.pointsPerPick = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup picks.
     * @member {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>} picks
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.picks = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentGroup message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentGroup} CDataGCCStrike15_v2_TournamentGroup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentGroup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.groupid = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.desc = reader.string();
                    break;
                case 4:
                    message.picks_Deprecated = reader.uint32();
                    break;
                case 5:
                    if (!(message.teams && message.teams.length))
                        message.teams = [];
                    message.teams.push($root.CDataGCCStrike15_v2_TournamentGroupTeam.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.stageIds && message.stageIds.length))
                        message.stageIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stageIds.push(reader.int32());
                    }
                    else
                        message.stageIds.push(reader.int32());
                    break;
                case 7:
                    message.picklockuntiltime = reader.uint32();
                    break;
                case 8:
                    message.pickableteams = reader.uint32();
                    break;
                case 9:
                    message.pointsPerPick = reader.uint32();
                    break;
                case 10:
                    if (!(message.picks && message.picks.length))
                        message.picks = [];
                    message.picks.push($root.CDataGCCStrike15_v2_TournamentGroup.Picks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CDataGCCStrike15_v2_TournamentGroup.Picks = (function () {
        /**
         * Properties of a Picks.
         * @memberof CDataGCCStrike15_v2_TournamentGroup
         * @interface IPicks
         * @property {Array.<number>|null} [pickids] Picks pickids
         */
        /**
         * Constructs a new Picks.
         * @memberof CDataGCCStrike15_v2_TournamentGroup
         * @classdesc Represents a Picks.
         * @implements IPicks
         * @constructor
         * @param {CDataGCCStrike15_v2_TournamentGroup.IPicks=} [properties] Properties to set
         */
        function Picks(properties) {
            this.pickids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Picks pickids.
         * @member {Array.<number>} pickids
         * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks
         * @instance
         */
        Picks.prototype.pickids = $util.emptyArray;
        /**
         * Decodes a Picks message from the specified reader or buffer.
         * @function decode
         * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDataGCCStrike15_v2_TournamentGroup.Picks} Picks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Picks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroup.Picks();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.pickids && message.pickids.length))
                            message.pickids = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.pickids.push(reader.int32());
                        }
                        else
                            message.pickids.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Picks;
    })();
    return CDataGCCStrike15_v2_TournamentGroup;
})());
exports.CDataGCCStrike15_v2_TournamentSection = ($root.CDataGCCStrike15_v2_TournamentSection = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentSection.
     * @exports ICDataGCCStrike15_v2_TournamentSection
     * @interface ICDataGCCStrike15_v2_TournamentSection
     * @property {number|null} [sectionid] CDataGCCStrike15_v2_TournamentSection sectionid
     * @property {string|null} [name] CDataGCCStrike15_v2_TournamentSection name
     * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentSection desc
     * @property {Array.<ICDataGCCStrike15_v2_TournamentGroup>|null} [groups] CDataGCCStrike15_v2_TournamentSection groups
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentSection.
     * @exports CDataGCCStrike15_v2_TournamentSection
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentSection.
     * @implements ICDataGCCStrike15_v2_TournamentSection
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentSection=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentSection(properties) {
        this.groups = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentSection sectionid.
     * @member {number} sectionid
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.sectionid = 0;
    /**
     * CDataGCCStrike15_v2_TournamentSection name.
     * @member {string} name
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.name = "";
    /**
     * CDataGCCStrike15_v2_TournamentSection desc.
     * @member {string} desc
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.desc = "";
    /**
     * CDataGCCStrike15_v2_TournamentSection groups.
     * @member {Array.<ICDataGCCStrike15_v2_TournamentGroup>} groups
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.groups = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentSection message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentSection} CDataGCCStrike15_v2_TournamentSection
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentSection.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentSection();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sectionid = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.desc = reader.string();
                    break;
                case 4:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push($root.CDataGCCStrike15_v2_TournamentGroup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_TournamentSection;
})());
exports.CDataGCCStrike15_v2_TournamentInfo = ($root.CDataGCCStrike15_v2_TournamentInfo = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentInfo.
     * @exports ICDataGCCStrike15_v2_TournamentInfo
     * @interface ICDataGCCStrike15_v2_TournamentInfo
     * @property {Array.<ICDataGCCStrike15_v2_TournamentSection>|null} [sections] CDataGCCStrike15_v2_TournamentInfo sections
     * @property {ITournamentEvent|null} [tournamentEvent] CDataGCCStrike15_v2_TournamentInfo tournamentEvent
     * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CDataGCCStrike15_v2_TournamentInfo tournamentTeams
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentInfo.
     * @exports CDataGCCStrike15_v2_TournamentInfo
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentInfo.
     * @implements ICDataGCCStrike15_v2_TournamentInfo
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentInfo=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentInfo(properties) {
        this.sections = [];
        this.tournamentTeams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentInfo sections.
     * @member {Array.<ICDataGCCStrike15_v2_TournamentSection>} sections
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @instance
     */
    CDataGCCStrike15_v2_TournamentInfo.prototype.sections = $util.emptyArray;
    /**
     * CDataGCCStrike15_v2_TournamentInfo tournamentEvent.
     * @member {ITournamentEvent|null|undefined} tournamentEvent
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @instance
     */
    CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentEvent = null;
    /**
     * CDataGCCStrike15_v2_TournamentInfo tournamentTeams.
     * @member {Array.<ITournamentTeam>} tournamentTeams
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @instance
     */
    CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentTeams =
        $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentInfo} CDataGCCStrike15_v2_TournamentInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.sections && message.sections.length))
                        message.sections = [];
                    message.sections.push($root.CDataGCCStrike15_v2_TournamentSection.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.tournamentTeams && message.tournamentTeams.length))
                        message.tournamentTeams = [];
                    message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_TournamentInfo;
})());
exports.CMsgGCCStrike15_v2_MatchList = ($root.CMsgGCCStrike15_v2_MatchList = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchList.
     * @exports ICMsgGCCStrike15_v2_MatchList
     * @interface ICMsgGCCStrike15_v2_MatchList
     * @property {number|null} [msgrequestid] CMsgGCCStrike15_v2_MatchList msgrequestid
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchList accountid
     * @property {number|null} [servertime] CMsgGCCStrike15_v2_MatchList servertime
     * @property {Array.<ICDataGCCStrike15_v2_MatchInfo>|null} [matches] CMsgGCCStrike15_v2_MatchList matches
     * @property {Array.<ITournamentTeam>|null} [streams] CMsgGCCStrike15_v2_MatchList streams
     * @property {ICDataGCCStrike15_v2_TournamentInfo|null} [tournamentinfo] CMsgGCCStrike15_v2_MatchList tournamentinfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchList.
     * @exports CMsgGCCStrike15_v2_MatchList
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchList.
     * @implements ICMsgGCCStrike15_v2_MatchList
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchList=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchList(properties) {
        this.matches = [];
        this.streams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchList msgrequestid.
     * @member {number} msgrequestid
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.msgrequestid = 0;
    /**
     * CMsgGCCStrike15_v2_MatchList accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.accountid = 0;
    /**
     * CMsgGCCStrike15_v2_MatchList servertime.
     * @member {number} servertime
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.servertime = 0;
    /**
     * CMsgGCCStrike15_v2_MatchList matches.
     * @member {Array.<ICDataGCCStrike15_v2_MatchInfo>} matches
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.matches = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchList streams.
     * @member {Array.<ITournamentTeam>} streams
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.streams = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchList tournamentinfo.
     * @member {ICDataGCCStrike15_v2_TournamentInfo|null|undefined} tournamentinfo
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.tournamentinfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchList message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchList} CMsgGCCStrike15_v2_MatchList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgrequestid = reader.uint32();
                    break;
                case 2:
                    message.accountid = reader.uint32();
                    break;
                case 3:
                    message.servertime = reader.uint32();
                    break;
                case 4:
                    if (!(message.matches && message.matches.length))
                        message.matches = [];
                    message.matches.push($root.CDataGCCStrike15_v2_MatchInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.streams && message.streams.length))
                        message.streams = [];
                    message.streams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.tournamentinfo = $root.CDataGCCStrike15_v2_TournamentInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchList;
})());
exports.CMsgGCCStrike15_v2_Predictions = ($root.CMsgGCCStrike15_v2_Predictions = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Predictions.
     * @exports ICMsgGCCStrike15_v2_Predictions
     * @interface ICMsgGCCStrike15_v2_Predictions
     * @property {number|null} [eventId] CMsgGCCStrike15_v2_Predictions eventId
     * @property {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>|null} [groupMatchTeamPicks] CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Predictions.
     * @exports CMsgGCCStrike15_v2_Predictions
     * @classdesc Represents a CMsgGCCStrike15_v2_Predictions.
     * @implements ICMsgGCCStrike15_v2_Predictions
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Predictions=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Predictions(properties) {
        this.groupMatchTeamPicks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Predictions eventId.
     * @member {number} eventId
     * @memberof CMsgGCCStrike15_v2_Predictions
     * @instance
     */
    CMsgGCCStrike15_v2_Predictions.prototype.eventId = 0;
    /**
     * CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks.
     * @member {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>} groupMatchTeamPicks
     * @memberof CMsgGCCStrike15_v2_Predictions
     * @instance
     */
    CMsgGCCStrike15_v2_Predictions.prototype.groupMatchTeamPicks =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_Predictions message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Predictions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Predictions} CMsgGCCStrike15_v2_Predictions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Predictions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Predictions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.uint32();
                    break;
                case 2:
                    if (!(message.groupMatchTeamPicks && message.groupMatchTeamPicks.length))
                        message.groupMatchTeamPicks = [];
                    message.groupMatchTeamPicks.push($root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick = (function () {
        /**
         * Properties of a GroupMatchTeamPick.
         * @memberof CMsgGCCStrike15_v2_Predictions
         * @interface IGroupMatchTeamPick
         * @property {number|null} [sectionid] GroupMatchTeamPick sectionid
         * @property {number|null} [groupid] GroupMatchTeamPick groupid
         * @property {number|null} [index] GroupMatchTeamPick index
         * @property {number|null} [teamid] GroupMatchTeamPick teamid
         * @property {number|Long|null} [itemid] GroupMatchTeamPick itemid
         */
        /**
         * Constructs a new GroupMatchTeamPick.
         * @memberof CMsgGCCStrike15_v2_Predictions
         * @classdesc Represents a GroupMatchTeamPick.
         * @implements IGroupMatchTeamPick
         * @constructor
         * @param {CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick=} [properties] Properties to set
         */
        function GroupMatchTeamPick(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GroupMatchTeamPick sectionid.
         * @member {number} sectionid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.sectionid = 0;
        /**
         * GroupMatchTeamPick groupid.
         * @member {number} groupid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.groupid = 0;
        /**
         * GroupMatchTeamPick index.
         * @member {number} index
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.index = 0;
        /**
         * GroupMatchTeamPick teamid.
         * @member {number} teamid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.teamid = 0;
        /**
         * GroupMatchTeamPick itemid.
         * @member {number|Long} itemid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.itemid = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;
        /**
         * Decodes a GroupMatchTeamPick message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick} GroupMatchTeamPick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMatchTeamPick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.sectionid = reader.int32();
                        break;
                    case 2:
                        message.groupid = reader.int32();
                        break;
                    case 3:
                        message.index = reader.int32();
                        break;
                    case 4:
                        message.teamid = reader.int32();
                        break;
                    case 5:
                        message.itemid = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return GroupMatchTeamPick;
    })();
    return CMsgGCCStrike15_v2_Predictions;
})());
exports.CMsgGCCStrike15_v2_Fantasy = ($root.CMsgGCCStrike15_v2_Fantasy = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Fantasy.
     * @exports ICMsgGCCStrike15_v2_Fantasy
     * @interface ICMsgGCCStrike15_v2_Fantasy
     * @property {number|null} [eventId] CMsgGCCStrike15_v2_Fantasy eventId
     * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>|null} [teams] CMsgGCCStrike15_v2_Fantasy teams
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Fantasy.
     * @exports CMsgGCCStrike15_v2_Fantasy
     * @classdesc Represents a CMsgGCCStrike15_v2_Fantasy.
     * @implements ICMsgGCCStrike15_v2_Fantasy
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Fantasy=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Fantasy(properties) {
        this.teams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Fantasy eventId.
     * @member {number} eventId
     * @memberof CMsgGCCStrike15_v2_Fantasy
     * @instance
     */
    CMsgGCCStrike15_v2_Fantasy.prototype.eventId = 0;
    /**
     * CMsgGCCStrike15_v2_Fantasy teams.
     * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>} teams
     * @memberof CMsgGCCStrike15_v2_Fantasy
     * @instance
     */
    CMsgGCCStrike15_v2_Fantasy.prototype.teams = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_Fantasy message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Fantasy
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Fantasy} CMsgGCCStrike15_v2_Fantasy
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Fantasy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.uint32();
                    break;
                case 2:
                    if (!(message.teams && message.teams.length))
                        message.teams = [];
                    message.teams.push($root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_Fantasy.FantasySlot = (function () {
        /**
         * Properties of a FantasySlot.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @interface IFantasySlot
         * @property {number|null} [type] FantasySlot type
         * @property {number|null} [pick] FantasySlot pick
         * @property {number|Long|null} [itemid] FantasySlot itemid
         */
        /**
         * Constructs a new FantasySlot.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @classdesc Represents a FantasySlot.
         * @implements IFantasySlot
         * @constructor
         * @param {CMsgGCCStrike15_v2_Fantasy.IFantasySlot=} [properties] Properties to set
         */
        function FantasySlot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * FantasySlot type.
         * @member {number} type
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @instance
         */
        FantasySlot.prototype.type = 0;
        /**
         * FantasySlot pick.
         * @member {number} pick
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @instance
         */
        FantasySlot.prototype.pick = 0;
        /**
         * FantasySlot itemid.
         * @member {number|Long} itemid
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @instance
         */
        FantasySlot.prototype.itemid = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;
        /**
         * Decodes a FantasySlot message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_Fantasy.FantasySlot} FantasySlot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FantasySlot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasySlot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.pick = reader.int32();
                        break;
                    case 3:
                        message.itemid = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return FantasySlot;
    })();
    CMsgGCCStrike15_v2_Fantasy.FantasyTeam = (function () {
        /**
         * Properties of a FantasyTeam.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @interface IFantasyTeam
         * @property {number|null} [sectionid] FantasyTeam sectionid
         * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>|null} [slots] FantasyTeam slots
         */
        /**
         * Constructs a new FantasyTeam.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @classdesc Represents a FantasyTeam.
         * @implements IFantasyTeam
         * @constructor
         * @param {CMsgGCCStrike15_v2_Fantasy.IFantasyTeam=} [properties] Properties to set
         */
        function FantasyTeam(properties) {
            this.slots = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * FantasyTeam sectionid.
         * @member {number} sectionid
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam
         * @instance
         */
        FantasyTeam.prototype.sectionid = 0;
        /**
         * FantasyTeam slots.
         * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>} slots
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam
         * @instance
         */
        FantasyTeam.prototype.slots = $util.emptyArray;
        /**
         * Decodes a FantasyTeam message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_Fantasy.FantasyTeam} FantasyTeam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FantasyTeam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.sectionid = reader.int32();
                        break;
                    case 2:
                        if (!(message.slots && message.slots.length))
                            message.slots = [];
                        message.slots.push($root.CMsgGCCStrike15_v2_Fantasy.FantasySlot.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return FantasyTeam;
    })();
    return CMsgGCCStrike15_v2_Fantasy;
})());
exports.CAttribute_String = ($root.CAttribute_String = (() => {
    /**
     * Properties of a CAttribute_String.
     * @exports ICAttribute_String
     * @interface ICAttribute_String
     * @property {string|null} [value] CAttribute_String value
     */
    /**
     * Constructs a new CAttribute_String.
     * @exports CAttribute_String
     * @classdesc Represents a CAttribute_String.
     * @implements ICAttribute_String
     * @constructor
     * @param {ICAttribute_String=} [properties] Properties to set
     */
    function CAttribute_String(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CAttribute_String value.
     * @member {string} value
     * @memberof CAttribute_String
     * @instance
     */
    CAttribute_String.prototype.value = "";
    /**
     * Decodes a CAttribute_String message from the specified reader or buffer.
     * @function decode
     * @memberof CAttribute_String
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CAttribute_String} CAttribute_String
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CAttribute_String.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CAttribute_String();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CAttribute_String;
})());
exports.CMsgGCToGCReloadVersions = ($root.CMsgGCToGCReloadVersions = (() => {
    /**
     * Properties of a CMsgGCToGCReloadVersions.
     * @exports ICMsgGCToGCReloadVersions
     * @interface ICMsgGCToGCReloadVersions
     */
    /**
     * Constructs a new CMsgGCToGCReloadVersions.
     * @exports CMsgGCToGCReloadVersions
     * @classdesc Represents a CMsgGCToGCReloadVersions.
     * @implements ICMsgGCToGCReloadVersions
     * @constructor
     * @param {ICMsgGCToGCReloadVersions=} [properties] Properties to set
     */
    function CMsgGCToGCReloadVersions(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCToGCReloadVersions message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCToGCReloadVersions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCToGCReloadVersions} CMsgGCToGCReloadVersions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCToGCReloadVersions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCToGCReloadVersions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCToGCReloadVersions;
})());
exports.CMsgCStrike15Welcome = ($root.CMsgCStrike15Welcome = (() => {
    /**
     * Properties of a CMsgCStrike15Welcome.
     * @exports ICMsgCStrike15Welcome
     * @interface ICMsgCStrike15Welcome
     * @property {number|null} [storeItemHash] CMsgCStrike15Welcome storeItemHash
     * @property {number|null} [timeplayedconsecutively] CMsgCStrike15Welcome timeplayedconsecutively
     * @property {number|null} [timeFirstPlayed] CMsgCStrike15Welcome timeFirstPlayed
     * @property {number|null} [lastTimePlayed] CMsgCStrike15Welcome lastTimePlayed
     * @property {number|null} [lastIpAddress] CMsgCStrike15Welcome lastIpAddress
     * @property {number|Long|null} [gscookieid] CMsgCStrike15Welcome gscookieid
     * @property {number|Long|null} [uniqueid] CMsgCStrike15Welcome uniqueid
     */
    /**
     * Constructs a new CMsgCStrike15Welcome.
     * @exports CMsgCStrike15Welcome
     * @classdesc Represents a CMsgCStrike15Welcome.
     * @implements ICMsgCStrike15Welcome
     * @constructor
     * @param {ICMsgCStrike15Welcome=} [properties] Properties to set
     */
    function CMsgCStrike15Welcome(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgCStrike15Welcome storeItemHash.
     * @member {number} storeItemHash
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.storeItemHash = 0;
    /**
     * CMsgCStrike15Welcome timeplayedconsecutively.
     * @member {number} timeplayedconsecutively
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.timeplayedconsecutively = 0;
    /**
     * CMsgCStrike15Welcome timeFirstPlayed.
     * @member {number} timeFirstPlayed
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.timeFirstPlayed = 0;
    /**
     * CMsgCStrike15Welcome lastTimePlayed.
     * @member {number} lastTimePlayed
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.lastTimePlayed = 0;
    /**
     * CMsgCStrike15Welcome lastIpAddress.
     * @member {number} lastIpAddress
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.lastIpAddress = 0;
    /**
     * CMsgCStrike15Welcome gscookieid.
     * @member {number|Long} gscookieid
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.gscookieid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgCStrike15Welcome uniqueid.
     * @member {number|Long} uniqueid
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.uniqueid = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgCStrike15Welcome message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgCStrike15Welcome
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgCStrike15Welcome} CMsgCStrike15Welcome
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgCStrike15Welcome.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgCStrike15Welcome();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 5:
                    message.storeItemHash = reader.uint32();
                    break;
                case 6:
                    message.timeplayedconsecutively = reader.uint32();
                    break;
                case 10:
                    message.timeFirstPlayed = reader.uint32();
                    break;
                case 12:
                    message.lastTimePlayed = reader.uint32();
                    break;
                case 13:
                    message.lastIpAddress = reader.uint32();
                    break;
                case 18:
                    message.gscookieid = reader.uint64();
                    break;
                case 19:
                    message.uniqueid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgCStrike15Welcome;
})());
exports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = ($root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.
     * @exports ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @interface ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @property {string|null} [valueName] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName
     * @property {number|null} [valueInt] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt
     * @property {number|null} [serverAddr] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr
     * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort
     * @property {Array.<string>|null} [chokedBlocks] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.
     * @exports CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.
     * @implements ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientVarValueNotificationInfo(properties) {
        this.chokedBlocks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName.
     * @member {string} valueName
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueName = "";
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt.
     * @member {number} valueInt
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueInt = 0;
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr.
     * @member {number} serverAddr
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverAddr = 0;
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort.
     * @member {number} serverPort
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverPort = 0;
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks.
     * @member {Array.<string>} chokedBlocks
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.chokedBlocks =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientVarValueNotificationInfo} CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.valueName = reader.string();
                    break;
                case 2:
                    message.valueInt = reader.int32();
                    break;
                case 3:
                    message.serverAddr = reader.uint32();
                    break;
                case 4:
                    message.serverPort = reader.uint32();
                    break;
                case 5:
                    if (!(message.chokedBlocks && message.chokedBlocks.length))
                        message.chokedBlocks = [];
                    message.chokedBlocks.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientVarValueNotificationInfo;
})());
exports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = ($root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.
     * @exports ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @interface ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid
     * @property {Array.<number>|null} [viewangles] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles
     * @property {number|null} [type] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.
     * @exports CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.
     * @implements ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ServerVarValueNotificationInfo(properties) {
        this.viewangles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.accountid = 0;
    /**
     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles.
     * @member {Array.<number>} viewangles
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.viewangles =
        $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type.
     * @member {number} type
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.type = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ServerVarValueNotificationInfo} CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    if (!(message.viewangles && message.viewangles.length))
                        message.viewangles = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.viewangles.push(reader.uint32());
                    }
                    else
                        message.viewangles.push(reader.uint32());
                    break;
                case 3:
                    message.type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ServerVarValueNotificationInfo;
})());
exports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = ($root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.
     * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardRequest
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardRequest.
     * @exports CMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.
     * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardRequest=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GiftsLeaderboardRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardRequest} CMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GiftsLeaderboardRequest;
})());
exports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = ($root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.
     * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @property {number|null} [servertime] CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime
     * @property {number|null} [timePeriodSeconds] CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds
     * @property {number|null} [totalGiftsGiven] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven
     * @property {number|null} [totalGivers] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers
     * @property {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>|null} [entries] CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardResponse.
     * @exports CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.
     * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GiftsLeaderboardResponse(properties) {
        this.entries = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime.
     * @member {number} servertime
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.servertime = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds.
     * @member {number} timePeriodSeconds
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.timePeriodSeconds = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven.
     * @member {number} totalGiftsGiven
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGiftsGiven = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers.
     * @member {number} totalGivers
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGivers = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries.
     * @member {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>} entries
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.entries =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse} CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.servertime = reader.uint32();
                    break;
                case 2:
                    message.timePeriodSeconds = reader.uint32();
                    break;
                case 3:
                    message.totalGiftsGiven = reader.uint32();
                    break;
                case 4:
                    message.totalGivers = reader.uint32();
                    break;
                case 5:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry = (function () {
        /**
         * Properties of a GiftLeaderboardEntry.
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
         * @interface IGiftLeaderboardEntry
         * @property {number|null} [accountid] GiftLeaderboardEntry accountid
         * @property {number|null} [gifts] GiftLeaderboardEntry gifts
         */
        /**
         * Constructs a new GiftLeaderboardEntry.
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
         * @classdesc Represents a GiftLeaderboardEntry.
         * @implements IGiftLeaderboardEntry
         * @constructor
         * @param {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry=} [properties] Properties to set
         */
        function GiftLeaderboardEntry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GiftLeaderboardEntry accountid.
         * @member {number} accountid
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry
         * @instance
         */
        GiftLeaderboardEntry.prototype.accountid = 0;
        /**
         * GiftLeaderboardEntry gifts.
         * @member {number} gifts
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry
         * @instance
         */
        GiftLeaderboardEntry.prototype.gifts = 0;
        /**
         * Decodes a GiftLeaderboardEntry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry} GiftLeaderboardEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GiftLeaderboardEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountid = reader.uint32();
                        break;
                    case 2:
                        message.gifts = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return GiftLeaderboardEntry;
    })();
    return CMsgGCCStrike15_v2_GiftsLeaderboardResponse;
})());
exports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = ($root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.
     * @exports ICMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @interface ICMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @property {number|null} [surveyId] CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId
     * @property {number|null} [vote] CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientSubmitSurveyVote.
     * @exports CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.
     * @implements ICMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientSubmitSurveyVote=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientSubmitSurveyVote(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId.
     * @member {number} surveyId
     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @instance
     */
    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.surveyId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote.
     * @member {number} vote
     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @instance
     */
    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.vote = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientSubmitSurveyVote message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientSubmitSurveyVote} CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.surveyId = reader.uint32();
                    break;
                case 2:
                    message.vote = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientSubmitSurveyVote;
})());
exports.CMsgGCCStrike15_v2_Server2GCClientValidate = ($root.CMsgGCCStrike15_v2_Server2GCClientValidate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Server2GCClientValidate.
     * @exports ICMsgGCCStrike15_v2_Server2GCClientValidate
     * @interface ICMsgGCCStrike15_v2_Server2GCClientValidate
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCClientValidate accountid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Server2GCClientValidate.
     * @exports CMsgGCCStrike15_v2_Server2GCClientValidate
     * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCClientValidate.
     * @implements ICMsgGCCStrike15_v2_Server2GCClientValidate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Server2GCClientValidate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Server2GCClientValidate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Server2GCClientValidate accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCClientValidate.prototype.accountid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Server2GCClientValidate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Server2GCClientValidate} CMsgGCCStrike15_v2_Server2GCClientValidate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Server2GCClientValidate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Server2GCClientValidate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Server2GCClientValidate;
})());
exports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = ($root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.
     * @exports ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @interface ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid
     * @property {string|null} [path] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path
     * @property {string|null} [file] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file
     * @property {number|null} [crc] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc
     * @property {number|null} [hash] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash
     * @property {number|null} [len] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len
     * @property {number|null} [packNumber] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber
     * @property {number|null} [packFileId] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.
     * @exports CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.
     * @implements ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.accountid = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path.
     * @member {string} path
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.path = "";
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file.
     * @member {string} file
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.file = "";
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc.
     * @member {number} crc
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.crc = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash.
     * @member {number} hash
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.hash = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len.
     * @member {number} len
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.len = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber.
     * @member {number} packNumber
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packNumber = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId.
     * @member {number} packFileId
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packFileId = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure} CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.file = reader.string();
                    break;
                case 4:
                    message.crc = reader.uint32();
                    break;
                case 5:
                    message.hash = reader.int32();
                    break;
                case 6:
                    message.len = reader.int32();
                    break;
                case 7:
                    message.packNumber = reader.int32();
                    break;
                case 8:
                    message.packFileId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure;
})());
exports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = ($root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.
     * @exports ICMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @interface ICMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @property {number|null} [eventid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid
     * @property {number|null} [stageid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid
     * @property {number|null} [gameType] CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType
     * @property {Array.<number>|null} [teamids] CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GC2ClientTournamentInfo.
     * @exports CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.
     * @implements ICMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GC2ClientTournamentInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GC2ClientTournamentInfo(properties) {
        this.teamids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid.
     * @member {number} eventid
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.eventid = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid.
     * @member {number} stageid
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.stageid = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType.
     * @member {number} gameType
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.gameType = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids.
     * @member {Array.<number>} teamids
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.teamids =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_GC2ClientTournamentInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GC2ClientTournamentInfo} CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventid = reader.uint32();
                    break;
                case 2:
                    message.stageid = reader.uint32();
                    break;
                case 3:
                    message.gameType = reader.uint32();
                    break;
                case 4:
                    if (!(message.teamids && message.teamids.length))
                        message.teamids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.teamids.push(reader.uint32());
                    }
                    else
                        message.teamids.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GC2ClientTournamentInfo;
})());
exports.CSOEconCoupon = ($root.CSOEconCoupon = (() => {
    /**
     * Properties of a CSOEconCoupon.
     * @exports ICSOEconCoupon
     * @interface ICSOEconCoupon
     * @property {number|null} [entryid] CSOEconCoupon entryid
     * @property {number|null} [defidx] CSOEconCoupon defidx
     * @property {number|null} [expirationDate] CSOEconCoupon expirationDate
     */
    /**
     * Constructs a new CSOEconCoupon.
     * @exports CSOEconCoupon
     * @classdesc Represents a CSOEconCoupon.
     * @implements ICSOEconCoupon
     * @constructor
     * @param {ICSOEconCoupon=} [properties] Properties to set
     */
    function CSOEconCoupon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSOEconCoupon entryid.
     * @member {number} entryid
     * @memberof CSOEconCoupon
     * @instance
     */
    CSOEconCoupon.prototype.entryid = 0;
    /**
     * CSOEconCoupon defidx.
     * @member {number} defidx
     * @memberof CSOEconCoupon
     * @instance
     */
    CSOEconCoupon.prototype.defidx = 0;
    /**
     * CSOEconCoupon expirationDate.
     * @member {number} expirationDate
     * @memberof CSOEconCoupon
     * @instance
     */
    CSOEconCoupon.prototype.expirationDate = 0;
    /**
     * Decodes a CSOEconCoupon message from the specified reader or buffer.
     * @function decode
     * @memberof CSOEconCoupon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSOEconCoupon} CSOEconCoupon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSOEconCoupon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOEconCoupon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entryid = reader.uint32();
                    break;
                case 2:
                    message.defidx = reader.uint32();
                    break;
                case 3:
                    message.expirationDate = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSOEconCoupon;
})());
exports.CSOQuestProgress = ($root.CSOQuestProgress = (() => {
    /**
     * Properties of a CSOQuestProgress.
     * @exports ICSOQuestProgress
     * @interface ICSOQuestProgress
     * @property {number|null} [questid] CSOQuestProgress questid
     * @property {number|null} [pointsRemaining] CSOQuestProgress pointsRemaining
     * @property {number|null} [bonusPoints] CSOQuestProgress bonusPoints
     */
    /**
     * Constructs a new CSOQuestProgress.
     * @exports CSOQuestProgress
     * @classdesc Represents a CSOQuestProgress.
     * @implements ICSOQuestProgress
     * @constructor
     * @param {ICSOQuestProgress=} [properties] Properties to set
     */
    function CSOQuestProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSOQuestProgress questid.
     * @member {number} questid
     * @memberof CSOQuestProgress
     * @instance
     */
    CSOQuestProgress.prototype.questid = 0;
    /**
     * CSOQuestProgress pointsRemaining.
     * @member {number} pointsRemaining
     * @memberof CSOQuestProgress
     * @instance
     */
    CSOQuestProgress.prototype.pointsRemaining = 0;
    /**
     * CSOQuestProgress bonusPoints.
     * @member {number} bonusPoints
     * @memberof CSOQuestProgress
     * @instance
     */
    CSOQuestProgress.prototype.bonusPoints = 0;
    /**
     * Decodes a CSOQuestProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CSOQuestProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSOQuestProgress} CSOQuestProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSOQuestProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOQuestProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.questid = reader.uint32();
                    break;
                case 2:
                    message.pointsRemaining = reader.uint32();
                    break;
                case 3:
                    message.bonusPoints = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSOQuestProgress;
})());
exports.CSOPersonaDataPublic = ($root.CSOPersonaDataPublic = (() => {
    /**
     * Properties of a CSOPersonaDataPublic.
     * @exports ICSOPersonaDataPublic
     * @interface ICSOPersonaDataPublic
     * @property {number|null} [playerLevel] CSOPersonaDataPublic playerLevel
     * @property {IPlayerCommendationInfo|null} [commendation] CSOPersonaDataPublic commendation
     */
    /**
     * Constructs a new CSOPersonaDataPublic.
     * @exports CSOPersonaDataPublic
     * @classdesc Represents a CSOPersonaDataPublic.
     * @implements ICSOPersonaDataPublic
     * @constructor
     * @param {ICSOPersonaDataPublic=} [properties] Properties to set
     */
    function CSOPersonaDataPublic(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSOPersonaDataPublic playerLevel.
     * @member {number} playerLevel
     * @memberof CSOPersonaDataPublic
     * @instance
     */
    CSOPersonaDataPublic.prototype.playerLevel = 0;
    /**
     * CSOPersonaDataPublic commendation.
     * @member {IPlayerCommendationInfo|null|undefined} commendation
     * @memberof CSOPersonaDataPublic
     * @instance
     */
    CSOPersonaDataPublic.prototype.commendation = null;
    /**
     * Decodes a CSOPersonaDataPublic message from the specified reader or buffer.
     * @function decode
     * @memberof CSOPersonaDataPublic
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSOPersonaDataPublic} CSOPersonaDataPublic
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSOPersonaDataPublic.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOPersonaDataPublic();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playerLevel = reader.int32();
                    break;
                case 2:
                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSOPersonaDataPublic;
})());
exports.CMsgGC_GlobalGame_Subscribe = ($root.CMsgGC_GlobalGame_Subscribe = (() => {
    /**
     * Properties of a CMsgGC_GlobalGame_Subscribe.
     * @exports ICMsgGC_GlobalGame_Subscribe
     * @interface ICMsgGC_GlobalGame_Subscribe
     * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Subscribe ticket
     */
    /**
     * Constructs a new CMsgGC_GlobalGame_Subscribe.
     * @exports CMsgGC_GlobalGame_Subscribe
     * @classdesc Represents a CMsgGC_GlobalGame_Subscribe.
     * @implements ICMsgGC_GlobalGame_Subscribe
     * @constructor
     * @param {ICMsgGC_GlobalGame_Subscribe=} [properties] Properties to set
     */
    function CMsgGC_GlobalGame_Subscribe(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_GlobalGame_Subscribe ticket.
     * @member {number|Long} ticket
     * @memberof CMsgGC_GlobalGame_Subscribe
     * @instance
     */
    CMsgGC_GlobalGame_Subscribe.prototype.ticket = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CMsgGC_GlobalGame_Subscribe message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_GlobalGame_Subscribe
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_GlobalGame_Subscribe} CMsgGC_GlobalGame_Subscribe
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_GlobalGame_Subscribe.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Subscribe();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ticket = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_GlobalGame_Subscribe;
})());
exports.CMsgGC_GlobalGame_Unsubscribe = ($root.CMsgGC_GlobalGame_Unsubscribe = (() => {
    /**
     * Properties of a CMsgGC_GlobalGame_Unsubscribe.
     * @exports ICMsgGC_GlobalGame_Unsubscribe
     * @interface ICMsgGC_GlobalGame_Unsubscribe
     * @property {number|null} [timeleft] CMsgGC_GlobalGame_Unsubscribe timeleft
     */
    /**
     * Constructs a new CMsgGC_GlobalGame_Unsubscribe.
     * @exports CMsgGC_GlobalGame_Unsubscribe
     * @classdesc Represents a CMsgGC_GlobalGame_Unsubscribe.
     * @implements ICMsgGC_GlobalGame_Unsubscribe
     * @constructor
     * @param {ICMsgGC_GlobalGame_Unsubscribe=} [properties] Properties to set
     */
    function CMsgGC_GlobalGame_Unsubscribe(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_GlobalGame_Unsubscribe timeleft.
     * @member {number} timeleft
     * @memberof CMsgGC_GlobalGame_Unsubscribe
     * @instance
     */
    CMsgGC_GlobalGame_Unsubscribe.prototype.timeleft = 0;
    /**
     * Decodes a CMsgGC_GlobalGame_Unsubscribe message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_GlobalGame_Unsubscribe
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_GlobalGame_Unsubscribe} CMsgGC_GlobalGame_Unsubscribe
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_GlobalGame_Unsubscribe.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Unsubscribe();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.timeleft = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_GlobalGame_Unsubscribe;
})());
exports.CMsgGC_GlobalGame_Play = ($root.CMsgGC_GlobalGame_Play = (() => {
    /**
     * Properties of a CMsgGC_GlobalGame_Play.
     * @exports ICMsgGC_GlobalGame_Play
     * @interface ICMsgGC_GlobalGame_Play
     * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Play ticket
     * @property {number|null} [gametimems] CMsgGC_GlobalGame_Play gametimems
     * @property {number|null} [msperpoint] CMsgGC_GlobalGame_Play msperpoint
     */
    /**
     * Constructs a new CMsgGC_GlobalGame_Play.
     * @exports CMsgGC_GlobalGame_Play
     * @classdesc Represents a CMsgGC_GlobalGame_Play.
     * @implements ICMsgGC_GlobalGame_Play
     * @constructor
     * @param {ICMsgGC_GlobalGame_Play=} [properties] Properties to set
     */
    function CMsgGC_GlobalGame_Play(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_GlobalGame_Play ticket.
     * @member {number|Long} ticket
     * @memberof CMsgGC_GlobalGame_Play
     * @instance
     */
    CMsgGC_GlobalGame_Play.prototype.ticket = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGC_GlobalGame_Play gametimems.
     * @member {number} gametimems
     * @memberof CMsgGC_GlobalGame_Play
     * @instance
     */
    CMsgGC_GlobalGame_Play.prototype.gametimems = 0;
    /**
     * CMsgGC_GlobalGame_Play msperpoint.
     * @member {number} msperpoint
     * @memberof CMsgGC_GlobalGame_Play
     * @instance
     */
    CMsgGC_GlobalGame_Play.prototype.msperpoint = 0;
    /**
     * Decodes a CMsgGC_GlobalGame_Play message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_GlobalGame_Play
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_GlobalGame_Play} CMsgGC_GlobalGame_Play
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_GlobalGame_Play.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Play();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ticket = reader.uint64();
                    break;
                case 2:
                    message.gametimems = reader.uint32();
                    break;
                case 3:
                    message.msperpoint = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_GlobalGame_Play;
})());
exports.CMsgGCCStrike15_v2_AcknowledgePenalty = ($root.CMsgGCCStrike15_v2_AcknowledgePenalty = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_AcknowledgePenalty.
     * @exports ICMsgGCCStrike15_v2_AcknowledgePenalty
     * @interface ICMsgGCCStrike15_v2_AcknowledgePenalty
     * @property {number|null} [acknowledged] CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_AcknowledgePenalty.
     * @exports CMsgGCCStrike15_v2_AcknowledgePenalty
     * @classdesc Represents a CMsgGCCStrike15_v2_AcknowledgePenalty.
     * @implements ICMsgGCCStrike15_v2_AcknowledgePenalty
     * @constructor
     * @param {ICMsgGCCStrike15_v2_AcknowledgePenalty=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_AcknowledgePenalty(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged.
     * @member {number} acknowledged
     * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty
     * @instance
     */
    CMsgGCCStrike15_v2_AcknowledgePenalty.prototype.acknowledged = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_AcknowledgePenalty message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_AcknowledgePenalty} CMsgGCCStrike15_v2_AcknowledgePenalty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_AcknowledgePenalty.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AcknowledgePenalty();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.acknowledged = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_AcknowledgePenalty;
})());
exports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = ($root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.
     * @exports ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @interface ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.
     * @exports CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.
     * @implements ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin} CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin;
})());
exports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = ($root.CMsgGCCStrike15_v2_Client2GCStreamUnlock = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCStreamUnlock.
     * @exports ICMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @interface ICMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @property {number|Long|null} [ticket] CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket
     * @property {number|null} [os] CMsgGCCStrike15_v2_Client2GCStreamUnlock os
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCStreamUnlock.
     * @exports CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCStreamUnlock.
     * @implements ICMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCStreamUnlock=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCStreamUnlock(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket.
     * @member {number|Long} ticket
     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.ticket = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCStreamUnlock os.
     * @member {number} os
     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.os = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCStreamUnlock message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCStreamUnlock} CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCStreamUnlock.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCStreamUnlock();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ticket = reader.uint64();
                    break;
                case 2:
                    message.os = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCStreamUnlock;
})());
/**
 * GCProtoBufMsgSrc enum.
 * @exports GCProtoBufMsgSrc
 * @enum {string}
 * @property {number} GCProtoBufMsgSrc_Unspecified=0 GCProtoBufMsgSrc_Unspecified value
 * @property {number} GCProtoBufMsgSrc_FromSystem=1 GCProtoBufMsgSrc_FromSystem value
 * @property {number} GCProtoBufMsgSrc_FromSteamID=2 GCProtoBufMsgSrc_FromSteamID value
 * @property {number} GCProtoBufMsgSrc_FromGC=3 GCProtoBufMsgSrc_FromGC value
 * @property {number} GCProtoBufMsgSrc_ReplySystem=4 GCProtoBufMsgSrc_ReplySystem value
 */
$root.GCProtoBufMsgSrc = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[(valuesById[0] = "GCProtoBufMsgSrc_Unspecified")] = 0;
    values[(valuesById[1] = "GCProtoBufMsgSrc_FromSystem")] = 1;
    values[(valuesById[2] = "GCProtoBufMsgSrc_FromSteamID")] = 2;
    values[(valuesById[3] = "GCProtoBufMsgSrc_FromGC")] = 3;
    values[(valuesById[4] = "GCProtoBufMsgSrc_ReplySystem")] = 4;
    return values;
})();
exports.CMsgProtoBufHeader = ($root.CMsgProtoBufHeader = (() => {
    /**
     * Properties of a CMsgProtoBufHeader.
     * @exports ICMsgProtoBufHeader
     * @interface ICMsgProtoBufHeader
     * @property {number|Long|null} [clientSteamId] CMsgProtoBufHeader clientSteamId
     * @property {number|null} [clientSessionId] CMsgProtoBufHeader clientSessionId
     * @property {number|null} [sourceAppId] CMsgProtoBufHeader sourceAppId
     * @property {number|Long|null} [jobIdSource] CMsgProtoBufHeader jobIdSource
     * @property {number|Long|null} [jobIdTarget] CMsgProtoBufHeader jobIdTarget
     * @property {string|null} [targetJobName] CMsgProtoBufHeader targetJobName
     * @property {number|null} [eresult] CMsgProtoBufHeader eresult
     * @property {string|null} [errorMessage] CMsgProtoBufHeader errorMessage
     * @property {GCProtoBufMsgSrc|null} [gcMsgSrc] CMsgProtoBufHeader gcMsgSrc
     * @property {number|null} [gcDirIndexSource] CMsgProtoBufHeader gcDirIndexSource
     */
    /**
     * Constructs a new CMsgProtoBufHeader.
     * @exports CMsgProtoBufHeader
     * @classdesc Represents a CMsgProtoBufHeader.
     * @implements ICMsgProtoBufHeader
     * @constructor
     * @param {ICMsgProtoBufHeader=} [properties] Properties to set
     */
    function CMsgProtoBufHeader(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgProtoBufHeader clientSteamId.
     * @member {number|Long} clientSteamId
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.clientSteamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgProtoBufHeader clientSessionId.
     * @member {number} clientSessionId
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.clientSessionId = 0;
    /**
     * CMsgProtoBufHeader sourceAppId.
     * @member {number} sourceAppId
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.sourceAppId = 0;
    /**
     * CMsgProtoBufHeader jobIdSource.
     * @member {number|Long} jobIdSource
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.jobIdSource = $util.Long
        ? $util.Long.fromBits(-1, 2147483647, false)
        : 9223372036854776000;
    /**
     * CMsgProtoBufHeader jobIdTarget.
     * @member {number|Long} jobIdTarget
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.jobIdTarget = $util.Long
        ? $util.Long.fromBits(-1, 2147483647, false)
        : 9223372036854776000;
    /**
     * CMsgProtoBufHeader targetJobName.
     * @member {string} targetJobName
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.targetJobName = "";
    /**
     * CMsgProtoBufHeader eresult.
     * @member {number} eresult
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.eresult = 2;
    /**
     * CMsgProtoBufHeader errorMessage.
     * @member {string} errorMessage
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.errorMessage = "";
    /**
     * CMsgProtoBufHeader gcMsgSrc.
     * @member {GCProtoBufMsgSrc} gcMsgSrc
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.gcMsgSrc = 0;
    /**
     * CMsgProtoBufHeader gcDirIndexSource.
     * @member {number} gcDirIndexSource
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.gcDirIndexSource = 0;
    /**
     * Decodes a CMsgProtoBufHeader message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgProtoBufHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgProtoBufHeader} CMsgProtoBufHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgProtoBufHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgProtoBufHeader();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.clientSteamId = reader.fixed64();
                    break;
                case 2:
                    message.clientSessionId = reader.int32();
                    break;
                case 3:
                    message.sourceAppId = reader.uint32();
                    break;
                case 10:
                    message.jobIdSource = reader.fixed64();
                    break;
                case 11:
                    message.jobIdTarget = reader.fixed64();
                    break;
                case 12:
                    message.targetJobName = reader.string();
                    break;
                case 13:
                    message.eresult = reader.int32();
                    break;
                case 14:
                    message.errorMessage = reader.string();
                    break;
                case 200:
                    message.gcMsgSrc = reader.int32();
                    break;
                case 201:
                    message.gcDirIndexSource = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgProtoBufHeader;
})());
exports.CMsgWebAPIKey = ($root.CMsgWebAPIKey = (() => {
    /**
     * Properties of a CMsgWebAPIKey.
     * @exports ICMsgWebAPIKey
     * @interface ICMsgWebAPIKey
     * @property {number|null} [status] CMsgWebAPIKey status
     * @property {number|null} [accountId] CMsgWebAPIKey accountId
     * @property {number|null} [publisherGroupId] CMsgWebAPIKey publisherGroupId
     * @property {number|null} [keyId] CMsgWebAPIKey keyId
     * @property {string|null} [domain] CMsgWebAPIKey domain
     */
    /**
     * Constructs a new CMsgWebAPIKey.
     * @exports CMsgWebAPIKey
     * @classdesc Represents a CMsgWebAPIKey.
     * @implements ICMsgWebAPIKey
     * @constructor
     * @param {ICMsgWebAPIKey=} [properties] Properties to set
     */
    function CMsgWebAPIKey(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgWebAPIKey status.
     * @member {number} status
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.status = 255;
    /**
     * CMsgWebAPIKey accountId.
     * @member {number} accountId
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.accountId = 0;
    /**
     * CMsgWebAPIKey publisherGroupId.
     * @member {number} publisherGroupId
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.publisherGroupId = 0;
    /**
     * CMsgWebAPIKey keyId.
     * @member {number} keyId
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.keyId = 0;
    /**
     * CMsgWebAPIKey domain.
     * @member {string} domain
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.domain = "";
    /**
     * Decodes a CMsgWebAPIKey message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgWebAPIKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgWebAPIKey} CMsgWebAPIKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgWebAPIKey.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgWebAPIKey();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.uint32();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.publisherGroupId = reader.uint32();
                    break;
                case 4:
                    message.keyId = reader.uint32();
                    break;
                case 5:
                    message.domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgWebAPIKey;
})());
exports.CMsgHttpRequest = ($root.CMsgHttpRequest = (() => {
    /**
     * Properties of a CMsgHttpRequest.
     * @exports ICMsgHttpRequest
     * @interface ICMsgHttpRequest
     * @property {number|null} [requestMethod] CMsgHttpRequest requestMethod
     * @property {string|null} [hostname] CMsgHttpRequest hostname
     * @property {string|null} [url] CMsgHttpRequest url
     * @property {Array.<CMsgHttpRequest.IRequestHeader>|null} [headers] CMsgHttpRequest headers
     * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [getParams] CMsgHttpRequest getParams
     * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [postParams] CMsgHttpRequest postParams
     * @property {Uint8Array|null} [body] CMsgHttpRequest body
     * @property {number|null} [absoluteTimeout] CMsgHttpRequest absoluteTimeout
     */
    /**
     * Constructs a new CMsgHttpRequest.
     * @exports CMsgHttpRequest
     * @classdesc Represents a CMsgHttpRequest.
     * @implements ICMsgHttpRequest
     * @constructor
     * @param {ICMsgHttpRequest=} [properties] Properties to set
     */
    function CMsgHttpRequest(properties) {
        this.headers = [];
        this.getParams = [];
        this.postParams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgHttpRequest requestMethod.
     * @member {number} requestMethod
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.requestMethod = 0;
    /**
     * CMsgHttpRequest hostname.
     * @member {string} hostname
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.hostname = "";
    /**
     * CMsgHttpRequest url.
     * @member {string} url
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.url = "";
    /**
     * CMsgHttpRequest headers.
     * @member {Array.<CMsgHttpRequest.IRequestHeader>} headers
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.headers = $util.emptyArray;
    /**
     * CMsgHttpRequest getParams.
     * @member {Array.<CMsgHttpRequest.IQueryParam>} getParams
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.getParams = $util.emptyArray;
    /**
     * CMsgHttpRequest postParams.
     * @member {Array.<CMsgHttpRequest.IQueryParam>} postParams
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.postParams = $util.emptyArray;
    /**
     * CMsgHttpRequest body.
     * @member {Uint8Array} body
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.body = $util.newBuffer([]);
    /**
     * CMsgHttpRequest absoluteTimeout.
     * @member {number} absoluteTimeout
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.absoluteTimeout = 0;
    /**
     * Decodes a CMsgHttpRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgHttpRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgHttpRequest} CMsgHttpRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgHttpRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestMethod = reader.uint32();
                    break;
                case 2:
                    message.hostname = reader.string();
                    break;
                case 3:
                    message.url = reader.string();
                    break;
                case 4:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.CMsgHttpRequest.RequestHeader.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.getParams && message.getParams.length))
                        message.getParams = [];
                    message.getParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.postParams && message.postParams.length))
                        message.postParams = [];
                    message.postParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.body = reader.bytes();
                    break;
                case 8:
                    message.absoluteTimeout = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgHttpRequest.RequestHeader = (function () {
        /**
         * Properties of a RequestHeader.
         * @memberof CMsgHttpRequest
         * @interface IRequestHeader
         * @property {string|null} [name] RequestHeader name
         * @property {string|null} [value] RequestHeader value
         */
        /**
         * Constructs a new RequestHeader.
         * @memberof CMsgHttpRequest
         * @classdesc Represents a RequestHeader.
         * @implements IRequestHeader
         * @constructor
         * @param {CMsgHttpRequest.IRequestHeader=} [properties] Properties to set
         */
        function RequestHeader(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestHeader name.
         * @member {string} name
         * @memberof CMsgHttpRequest.RequestHeader
         * @instance
         */
        RequestHeader.prototype.name = "";
        /**
         * RequestHeader value.
         * @member {string} value
         * @memberof CMsgHttpRequest.RequestHeader
         * @instance
         */
        RequestHeader.prototype.value = "";
        /**
         * Decodes a RequestHeader message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHttpRequest.RequestHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHttpRequest.RequestHeader} RequestHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest.RequestHeader();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return RequestHeader;
    })();
    CMsgHttpRequest.QueryParam = (function () {
        /**
         * Properties of a QueryParam.
         * @memberof CMsgHttpRequest
         * @interface IQueryParam
         * @property {string|null} [name] QueryParam name
         * @property {Uint8Array|null} [value] QueryParam value
         */
        /**
         * Constructs a new QueryParam.
         * @memberof CMsgHttpRequest
         * @classdesc Represents a QueryParam.
         * @implements IQueryParam
         * @constructor
         * @param {CMsgHttpRequest.IQueryParam=} [properties] Properties to set
         */
        function QueryParam(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * QueryParam name.
         * @member {string} name
         * @memberof CMsgHttpRequest.QueryParam
         * @instance
         */
        QueryParam.prototype.name = "";
        /**
         * QueryParam value.
         * @member {Uint8Array} value
         * @memberof CMsgHttpRequest.QueryParam
         * @instance
         */
        QueryParam.prototype.value = $util.newBuffer([]);
        /**
         * Decodes a QueryParam message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHttpRequest.QueryParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHttpRequest.QueryParam} QueryParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest.QueryParam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return QueryParam;
    })();
    return CMsgHttpRequest;
})());
exports.CMsgWebAPIRequest = ($root.CMsgWebAPIRequest = (() => {
    /**
     * Properties of a CMsgWebAPIRequest.
     * @exports ICMsgWebAPIRequest
     * @interface ICMsgWebAPIRequest
     * @property {string|null} [UNUSEDJobName] CMsgWebAPIRequest UNUSEDJobName
     * @property {string|null} [interfaceName] CMsgWebAPIRequest interfaceName
     * @property {string|null} [methodName] CMsgWebAPIRequest methodName
     * @property {number|null} [version] CMsgWebAPIRequest version
     * @property {ICMsgWebAPIKey|null} [apiKey] CMsgWebAPIRequest apiKey
     * @property {ICMsgHttpRequest|null} [request] CMsgWebAPIRequest request
     * @property {number|null} [routingAppId] CMsgWebAPIRequest routingAppId
     */
    /**
     * Constructs a new CMsgWebAPIRequest.
     * @exports CMsgWebAPIRequest
     * @classdesc Represents a CMsgWebAPIRequest.
     * @implements ICMsgWebAPIRequest
     * @constructor
     * @param {ICMsgWebAPIRequest=} [properties] Properties to set
     */
    function CMsgWebAPIRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgWebAPIRequest UNUSEDJobName.
     * @member {string} UNUSEDJobName
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.UNUSEDJobName = "";
    /**
     * CMsgWebAPIRequest interfaceName.
     * @member {string} interfaceName
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.interfaceName = "";
    /**
     * CMsgWebAPIRequest methodName.
     * @member {string} methodName
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.methodName = "";
    /**
     * CMsgWebAPIRequest version.
     * @member {number} version
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.version = 0;
    /**
     * CMsgWebAPIRequest apiKey.
     * @member {ICMsgWebAPIKey|null|undefined} apiKey
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.apiKey = null;
    /**
     * CMsgWebAPIRequest request.
     * @member {ICMsgHttpRequest|null|undefined} request
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.request = null;
    /**
     * CMsgWebAPIRequest routingAppId.
     * @member {number} routingAppId
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.routingAppId = 0;
    /**
     * Decodes a CMsgWebAPIRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgWebAPIRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgWebAPIRequest} CMsgWebAPIRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgWebAPIRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgWebAPIRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.UNUSEDJobName = reader.string();
                    break;
                case 2:
                    message.interfaceName = reader.string();
                    break;
                case 3:
                    message.methodName = reader.string();
                    break;
                case 4:
                    message.version = reader.uint32();
                    break;
                case 5:
                    message.apiKey = $root.CMsgWebAPIKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.request = $root.CMsgHttpRequest.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.routingAppId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgWebAPIRequest;
})());
exports.CMsgHttpResponse = ($root.CMsgHttpResponse = (() => {
    /**
     * Properties of a CMsgHttpResponse.
     * @exports ICMsgHttpResponse
     * @interface ICMsgHttpResponse
     * @property {number|null} [statusCode] CMsgHttpResponse statusCode
     * @property {Array.<CMsgHttpResponse.IResponseHeader>|null} [headers] CMsgHttpResponse headers
     * @property {Uint8Array|null} [body] CMsgHttpResponse body
     */
    /**
     * Constructs a new CMsgHttpResponse.
     * @exports CMsgHttpResponse
     * @classdesc Represents a CMsgHttpResponse.
     * @implements ICMsgHttpResponse
     * @constructor
     * @param {ICMsgHttpResponse=} [properties] Properties to set
     */
    function CMsgHttpResponse(properties) {
        this.headers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgHttpResponse statusCode.
     * @member {number} statusCode
     * @memberof CMsgHttpResponse
     * @instance
     */
    CMsgHttpResponse.prototype.statusCode = 0;
    /**
     * CMsgHttpResponse headers.
     * @member {Array.<CMsgHttpResponse.IResponseHeader>} headers
     * @memberof CMsgHttpResponse
     * @instance
     */
    CMsgHttpResponse.prototype.headers = $util.emptyArray;
    /**
     * CMsgHttpResponse body.
     * @member {Uint8Array} body
     * @memberof CMsgHttpResponse
     * @instance
     */
    CMsgHttpResponse.prototype.body = $util.newBuffer([]);
    /**
     * Decodes a CMsgHttpResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgHttpResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgHttpResponse} CMsgHttpResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgHttpResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.statusCode = reader.uint32();
                    break;
                case 2:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.CMsgHttpResponse.ResponseHeader.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgHttpResponse.ResponseHeader = (function () {
        /**
         * Properties of a ResponseHeader.
         * @memberof CMsgHttpResponse
         * @interface IResponseHeader
         * @property {string|null} [name] ResponseHeader name
         * @property {string|null} [value] ResponseHeader value
         */
        /**
         * Constructs a new ResponseHeader.
         * @memberof CMsgHttpResponse
         * @classdesc Represents a ResponseHeader.
         * @implements IResponseHeader
         * @constructor
         * @param {CMsgHttpResponse.IResponseHeader=} [properties] Properties to set
         */
        function ResponseHeader(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseHeader name.
         * @member {string} name
         * @memberof CMsgHttpResponse.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.name = "";
        /**
         * ResponseHeader value.
         * @member {string} value
         * @memberof CMsgHttpResponse.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.value = "";
        /**
         * Decodes a ResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHttpResponse.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHttpResponse.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpResponse.ResponseHeader();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ResponseHeader;
    })();
    return CMsgHttpResponse;
})());
exports.CMsgAMFindAccounts = ($root.CMsgAMFindAccounts = (() => {
    /**
     * Properties of a CMsgAMFindAccounts.
     * @exports ICMsgAMFindAccounts
     * @interface ICMsgAMFindAccounts
     * @property {number|null} [searchType] CMsgAMFindAccounts searchType
     * @property {string|null} [searchString] CMsgAMFindAccounts searchString
     */
    /**
     * Constructs a new CMsgAMFindAccounts.
     * @exports CMsgAMFindAccounts
     * @classdesc Represents a CMsgAMFindAccounts.
     * @implements ICMsgAMFindAccounts
     * @constructor
     * @param {ICMsgAMFindAccounts=} [properties] Properties to set
     */
    function CMsgAMFindAccounts(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMFindAccounts searchType.
     * @member {number} searchType
     * @memberof CMsgAMFindAccounts
     * @instance
     */
    CMsgAMFindAccounts.prototype.searchType = 0;
    /**
     * CMsgAMFindAccounts searchString.
     * @member {string} searchString
     * @memberof CMsgAMFindAccounts
     * @instance
     */
    CMsgAMFindAccounts.prototype.searchString = "";
    /**
     * Decodes a CMsgAMFindAccounts message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMFindAccounts
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMFindAccounts} CMsgAMFindAccounts
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMFindAccounts.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMFindAccounts();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.searchType = reader.uint32();
                    break;
                case 2:
                    message.searchString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMFindAccounts;
})());
exports.CMsgAMFindAccountsResponse = ($root.CMsgAMFindAccountsResponse = (() => {
    /**
     * Properties of a CMsgAMFindAccountsResponse.
     * @exports ICMsgAMFindAccountsResponse
     * @interface ICMsgAMFindAccountsResponse
     * @property {Array.<number|Long>|null} [steamId] CMsgAMFindAccountsResponse steamId
     */
    /**
     * Constructs a new CMsgAMFindAccountsResponse.
     * @exports CMsgAMFindAccountsResponse
     * @classdesc Represents a CMsgAMFindAccountsResponse.
     * @implements ICMsgAMFindAccountsResponse
     * @constructor
     * @param {ICMsgAMFindAccountsResponse=} [properties] Properties to set
     */
    function CMsgAMFindAccountsResponse(properties) {
        this.steamId = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMFindAccountsResponse steamId.
     * @member {Array.<number|Long>} steamId
     * @memberof CMsgAMFindAccountsResponse
     * @instance
     */
    CMsgAMFindAccountsResponse.prototype.steamId = $util.emptyArray;
    /**
     * Decodes a CMsgAMFindAccountsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMFindAccountsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMFindAccountsResponse} CMsgAMFindAccountsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMFindAccountsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMFindAccountsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.steamId && message.steamId.length))
                        message.steamId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.steamId.push(reader.fixed64());
                    }
                    else
                        message.steamId.push(reader.fixed64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMFindAccountsResponse;
})());
exports.CMsgNotifyWatchdog = ($root.CMsgNotifyWatchdog = (() => {
    /**
     * Properties of a CMsgNotifyWatchdog.
     * @exports ICMsgNotifyWatchdog
     * @interface ICMsgNotifyWatchdog
     * @property {number|null} [source] CMsgNotifyWatchdog source
     * @property {number|null} [alertType] CMsgNotifyWatchdog alertType
     * @property {number|null} [alertDestination] CMsgNotifyWatchdog alertDestination
     * @property {boolean|null} [critical] CMsgNotifyWatchdog critical
     * @property {number|null} [time] CMsgNotifyWatchdog time
     * @property {number|null} [appid] CMsgNotifyWatchdog appid
     * @property {string|null} [text] CMsgNotifyWatchdog text
     */
    /**
     * Constructs a new CMsgNotifyWatchdog.
     * @exports CMsgNotifyWatchdog
     * @classdesc Represents a CMsgNotifyWatchdog.
     * @implements ICMsgNotifyWatchdog
     * @constructor
     * @param {ICMsgNotifyWatchdog=} [properties] Properties to set
     */
    function CMsgNotifyWatchdog(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgNotifyWatchdog source.
     * @member {number} source
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.source = 0;
    /**
     * CMsgNotifyWatchdog alertType.
     * @member {number} alertType
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.alertType = 0;
    /**
     * CMsgNotifyWatchdog alertDestination.
     * @member {number} alertDestination
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.alertDestination = 0;
    /**
     * CMsgNotifyWatchdog critical.
     * @member {boolean} critical
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.critical = false;
    /**
     * CMsgNotifyWatchdog time.
     * @member {number} time
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.time = 0;
    /**
     * CMsgNotifyWatchdog appid.
     * @member {number} appid
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.appid = 0;
    /**
     * CMsgNotifyWatchdog text.
     * @member {string} text
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.text = "";
    /**
     * Decodes a CMsgNotifyWatchdog message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgNotifyWatchdog
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgNotifyWatchdog} CMsgNotifyWatchdog
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgNotifyWatchdog.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotifyWatchdog();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.source = reader.uint32();
                    break;
                case 2:
                    message.alertType = reader.uint32();
                    break;
                case 3:
                    message.alertDestination = reader.uint32();
                    break;
                case 4:
                    message.critical = reader.bool();
                    break;
                case 5:
                    message.time = reader.uint32();
                    break;
                case 6:
                    message.appid = reader.uint32();
                    break;
                case 7:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgNotifyWatchdog;
})());
exports.CMsgAMGetLicenses = ($root.CMsgAMGetLicenses = (() => {
    /**
     * Properties of a CMsgAMGetLicenses.
     * @exports ICMsgAMGetLicenses
     * @interface ICMsgAMGetLicenses
     * @property {number|Long|null} [steamid] CMsgAMGetLicenses steamid
     */
    /**
     * Constructs a new CMsgAMGetLicenses.
     * @exports CMsgAMGetLicenses
     * @classdesc Represents a CMsgAMGetLicenses.
     * @implements ICMsgAMGetLicenses
     * @constructor
     * @param {ICMsgAMGetLicenses=} [properties] Properties to set
     */
    function CMsgAMGetLicenses(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetLicenses steamid.
     * @member {number|Long} steamid
     * @memberof CMsgAMGetLicenses
     * @instance
     */
    CMsgAMGetLicenses.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * Decodes a CMsgAMGetLicenses message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetLicenses
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetLicenses} CMsgAMGetLicenses
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetLicenses.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetLicenses();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGetLicenses;
})());
exports.CMsgPackageLicense = ($root.CMsgPackageLicense = (() => {
    /**
     * Properties of a CMsgPackageLicense.
     * @exports ICMsgPackageLicense
     * @interface ICMsgPackageLicense
     * @property {number|null} [packageId] CMsgPackageLicense packageId
     * @property {number|null} [timeCreated] CMsgPackageLicense timeCreated
     * @property {number|null} [ownerId] CMsgPackageLicense ownerId
     */
    /**
     * Constructs a new CMsgPackageLicense.
     * @exports CMsgPackageLicense
     * @classdesc Represents a CMsgPackageLicense.
     * @implements ICMsgPackageLicense
     * @constructor
     * @param {ICMsgPackageLicense=} [properties] Properties to set
     */
    function CMsgPackageLicense(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgPackageLicense packageId.
     * @member {number} packageId
     * @memberof CMsgPackageLicense
     * @instance
     */
    CMsgPackageLicense.prototype.packageId = 0;
    /**
     * CMsgPackageLicense timeCreated.
     * @member {number} timeCreated
     * @memberof CMsgPackageLicense
     * @instance
     */
    CMsgPackageLicense.prototype.timeCreated = 0;
    /**
     * CMsgPackageLicense ownerId.
     * @member {number} ownerId
     * @memberof CMsgPackageLicense
     * @instance
     */
    CMsgPackageLicense.prototype.ownerId = 0;
    /**
     * Decodes a CMsgPackageLicense message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgPackageLicense
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgPackageLicense} CMsgPackageLicense
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgPackageLicense.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPackageLicense();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.packageId = reader.uint32();
                    break;
                case 2:
                    message.timeCreated = reader.uint32();
                    break;
                case 3:
                    message.ownerId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgPackageLicense;
})());
exports.CMsgAMGetLicensesResponse = ($root.CMsgAMGetLicensesResponse = (() => {
    /**
     * Properties of a CMsgAMGetLicensesResponse.
     * @exports ICMsgAMGetLicensesResponse
     * @interface ICMsgAMGetLicensesResponse
     * @property {Array.<ICMsgPackageLicense>|null} [license] CMsgAMGetLicensesResponse license
     * @property {number|null} [result] CMsgAMGetLicensesResponse result
     */
    /**
     * Constructs a new CMsgAMGetLicensesResponse.
     * @exports CMsgAMGetLicensesResponse
     * @classdesc Represents a CMsgAMGetLicensesResponse.
     * @implements ICMsgAMGetLicensesResponse
     * @constructor
     * @param {ICMsgAMGetLicensesResponse=} [properties] Properties to set
     */
    function CMsgAMGetLicensesResponse(properties) {
        this.license = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetLicensesResponse license.
     * @member {Array.<ICMsgPackageLicense>} license
     * @memberof CMsgAMGetLicensesResponse
     * @instance
     */
    CMsgAMGetLicensesResponse.prototype.license = $util.emptyArray;
    /**
     * CMsgAMGetLicensesResponse result.
     * @member {number} result
     * @memberof CMsgAMGetLicensesResponse
     * @instance
     */
    CMsgAMGetLicensesResponse.prototype.result = 0;
    /**
     * Decodes a CMsgAMGetLicensesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetLicensesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetLicensesResponse} CMsgAMGetLicensesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetLicensesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetLicensesResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.license && message.license.length))
                        message.license = [];
                    message.license.push($root.CMsgPackageLicense.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.result = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGetLicensesResponse;
})());
exports.CMsgAMGetUserGameStats = ($root.CMsgAMGetUserGameStats = (() => {
    /**
     * Properties of a CMsgAMGetUserGameStats.
     * @exports ICMsgAMGetUserGameStats
     * @interface ICMsgAMGetUserGameStats
     * @property {number|Long|null} [steamId] CMsgAMGetUserGameStats steamId
     * @property {number|Long|null} [gameId] CMsgAMGetUserGameStats gameId
     * @property {Array.<number>|null} [stats] CMsgAMGetUserGameStats stats
     */
    /**
     * Constructs a new CMsgAMGetUserGameStats.
     * @exports CMsgAMGetUserGameStats
     * @classdesc Represents a CMsgAMGetUserGameStats.
     * @implements ICMsgAMGetUserGameStats
     * @constructor
     * @param {ICMsgAMGetUserGameStats=} [properties] Properties to set
     */
    function CMsgAMGetUserGameStats(properties) {
        this.stats = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetUserGameStats steamId.
     * @member {number|Long} steamId
     * @memberof CMsgAMGetUserGameStats
     * @instance
     */
    CMsgAMGetUserGameStats.prototype.steamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMGetUserGameStats gameId.
     * @member {number|Long} gameId
     * @memberof CMsgAMGetUserGameStats
     * @instance
     */
    CMsgAMGetUserGameStats.prototype.gameId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMGetUserGameStats stats.
     * @member {Array.<number>} stats
     * @memberof CMsgAMGetUserGameStats
     * @instance
     */
    CMsgAMGetUserGameStats.prototype.stats = $util.emptyArray;
    /**
     * Decodes a CMsgAMGetUserGameStats message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetUserGameStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetUserGameStats} CMsgAMGetUserGameStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetUserGameStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.gameId = reader.fixed64();
                    break;
                case 3:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stats.push(reader.uint32());
                    }
                    else
                        message.stats.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGetUserGameStats;
})());
exports.CMsgAMGetUserGameStatsResponse = ($root.CMsgAMGetUserGameStatsResponse = (() => {
    /**
     * Properties of a CMsgAMGetUserGameStatsResponse.
     * @exports ICMsgAMGetUserGameStatsResponse
     * @interface ICMsgAMGetUserGameStatsResponse
     * @property {number|Long|null} [steamId] CMsgAMGetUserGameStatsResponse steamId
     * @property {number|Long|null} [gameId] CMsgAMGetUserGameStatsResponse gameId
     * @property {number|null} [eresult] CMsgAMGetUserGameStatsResponse eresult
     * @property {Array.<CMsgAMGetUserGameStatsResponse.IStats>|null} [stats] CMsgAMGetUserGameStatsResponse stats
     * @property {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>|null} [achievementBlocks] CMsgAMGetUserGameStatsResponse achievementBlocks
     */
    /**
     * Constructs a new CMsgAMGetUserGameStatsResponse.
     * @exports CMsgAMGetUserGameStatsResponse
     * @classdesc Represents a CMsgAMGetUserGameStatsResponse.
     * @implements ICMsgAMGetUserGameStatsResponse
     * @constructor
     * @param {ICMsgAMGetUserGameStatsResponse=} [properties] Properties to set
     */
    function CMsgAMGetUserGameStatsResponse(properties) {
        this.stats = [];
        this.achievementBlocks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetUserGameStatsResponse steamId.
     * @member {number|Long} steamId
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.steamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMGetUserGameStatsResponse gameId.
     * @member {number|Long} gameId
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.gameId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMGetUserGameStatsResponse eresult.
     * @member {number} eresult
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.eresult = 2;
    /**
     * CMsgAMGetUserGameStatsResponse stats.
     * @member {Array.<CMsgAMGetUserGameStatsResponse.IStats>} stats
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.stats = $util.emptyArray;
    /**
     * CMsgAMGetUserGameStatsResponse achievementBlocks.
     * @member {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>} achievementBlocks
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.achievementBlocks = $util.emptyArray;
    /**
     * Decodes a CMsgAMGetUserGameStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetUserGameStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetUserGameStatsResponse} CMsgAMGetUserGameStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetUserGameStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.gameId = reader.fixed64();
                    break;
                case 3:
                    message.eresult = reader.int32();
                    break;
                case 4:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CMsgAMGetUserGameStatsResponse.Stats.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.achievementBlocks && message.achievementBlocks.length))
                        message.achievementBlocks = [];
                    message.achievementBlocks.push($root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgAMGetUserGameStatsResponse.Stats = (function () {
        /**
         * Properties of a Stats.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @interface IStats
         * @property {number|null} [statId] Stats statId
         * @property {number|null} [statValue] Stats statValue
         */
        /**
         * Constructs a new Stats.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @classdesc Represents a Stats.
         * @implements IStats
         * @constructor
         * @param {CMsgAMGetUserGameStatsResponse.IStats=} [properties] Properties to set
         */
        function Stats(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Stats statId.
         * @member {number} statId
         * @memberof CMsgAMGetUserGameStatsResponse.Stats
         * @instance
         */
        Stats.prototype.statId = 0;
        /**
         * Stats statValue.
         * @member {number} statValue
         * @memberof CMsgAMGetUserGameStatsResponse.Stats
         * @instance
         */
        Stats.prototype.statValue = 0;
        /**
         * Decodes a Stats message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMGetUserGameStatsResponse.Stats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMGetUserGameStatsResponse.Stats} Stats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Stats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse.Stats();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.statId = reader.uint32();
                        break;
                    case 2:
                        message.statValue = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Stats;
    })();
    CMsgAMGetUserGameStatsResponse.Achievement_Blocks = (function () {
        /**
         * Properties of an Achievement_Blocks.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @interface IAchievement_Blocks
         * @property {number|null} [achievementId] Achievement_Blocks achievementId
         * @property {number|null} [achievementBitId] Achievement_Blocks achievementBitId
         * @property {number|null} [unlockTime] Achievement_Blocks unlockTime
         */
        /**
         * Constructs a new Achievement_Blocks.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @classdesc Represents an Achievement_Blocks.
         * @implements IAchievement_Blocks
         * @constructor
         * @param {CMsgAMGetUserGameStatsResponse.IAchievement_Blocks=} [properties] Properties to set
         */
        function Achievement_Blocks(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Achievement_Blocks achievementId.
         * @member {number} achievementId
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @instance
         */
        Achievement_Blocks.prototype.achievementId = 0;
        /**
         * Achievement_Blocks achievementBitId.
         * @member {number} achievementBitId
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @instance
         */
        Achievement_Blocks.prototype.achievementBitId = 0;
        /**
         * Achievement_Blocks unlockTime.
         * @member {number} unlockTime
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @instance
         */
        Achievement_Blocks.prototype.unlockTime = 0;
        /**
         * Decodes an Achievement_Blocks message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMGetUserGameStatsResponse.Achievement_Blocks} Achievement_Blocks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Achievement_Blocks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.achievementId = reader.uint32();
                        break;
                    case 2:
                        message.achievementBitId = reader.uint32();
                        break;
                    case 3:
                        message.unlockTime = reader.fixed32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Achievement_Blocks;
    })();
    return CMsgAMGetUserGameStatsResponse;
})());
exports.CMsgGCGetCommandList = ($root.CMsgGCGetCommandList = (() => {
    /**
     * Properties of a CMsgGCGetCommandList.
     * @exports ICMsgGCGetCommandList
     * @interface ICMsgGCGetCommandList
     * @property {number|null} [appId] CMsgGCGetCommandList appId
     * @property {string|null} [commandPrefix] CMsgGCGetCommandList commandPrefix
     */
    /**
     * Constructs a new CMsgGCGetCommandList.
     * @exports CMsgGCGetCommandList
     * @classdesc Represents a CMsgGCGetCommandList.
     * @implements ICMsgGCGetCommandList
     * @constructor
     * @param {ICMsgGCGetCommandList=} [properties] Properties to set
     */
    function CMsgGCGetCommandList(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetCommandList appId.
     * @member {number} appId
     * @memberof CMsgGCGetCommandList
     * @instance
     */
    CMsgGCGetCommandList.prototype.appId = 0;
    /**
     * CMsgGCGetCommandList commandPrefix.
     * @member {string} commandPrefix
     * @memberof CMsgGCGetCommandList
     * @instance
     */
    CMsgGCGetCommandList.prototype.commandPrefix = "";
    /**
     * Decodes a CMsgGCGetCommandList message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetCommandList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetCommandList} CMsgGCGetCommandList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetCommandList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetCommandList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appId = reader.uint32();
                    break;
                case 2:
                    message.commandPrefix = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetCommandList;
})());
exports.CMsgGCGetCommandListResponse = ($root.CMsgGCGetCommandListResponse = (() => {
    /**
     * Properties of a CMsgGCGetCommandListResponse.
     * @exports ICMsgGCGetCommandListResponse
     * @interface ICMsgGCGetCommandListResponse
     * @property {Array.<string>|null} [commandName] CMsgGCGetCommandListResponse commandName
     */
    /**
     * Constructs a new CMsgGCGetCommandListResponse.
     * @exports CMsgGCGetCommandListResponse
     * @classdesc Represents a CMsgGCGetCommandListResponse.
     * @implements ICMsgGCGetCommandListResponse
     * @constructor
     * @param {ICMsgGCGetCommandListResponse=} [properties] Properties to set
     */
    function CMsgGCGetCommandListResponse(properties) {
        this.commandName = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetCommandListResponse commandName.
     * @member {Array.<string>} commandName
     * @memberof CMsgGCGetCommandListResponse
     * @instance
     */
    CMsgGCGetCommandListResponse.prototype.commandName = $util.emptyArray;
    /**
     * Decodes a CMsgGCGetCommandListResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetCommandListResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetCommandListResponse} CMsgGCGetCommandListResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetCommandListResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetCommandListResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.commandName && message.commandName.length))
                        message.commandName = [];
                    message.commandName.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetCommandListResponse;
})());
exports.CGCMsgMemCachedGet = ($root.CGCMsgMemCachedGet = (() => {
    /**
     * Properties of a CGCMsgMemCachedGet.
     * @exports ICGCMsgMemCachedGet
     * @interface ICGCMsgMemCachedGet
     * @property {Array.<string>|null} [keys] CGCMsgMemCachedGet keys
     */
    /**
     * Constructs a new CGCMsgMemCachedGet.
     * @exports CGCMsgMemCachedGet
     * @classdesc Represents a CGCMsgMemCachedGet.
     * @implements ICGCMsgMemCachedGet
     * @constructor
     * @param {ICGCMsgMemCachedGet=} [properties] Properties to set
     */
    function CGCMsgMemCachedGet(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedGet keys.
     * @member {Array.<string>} keys
     * @memberof CGCMsgMemCachedGet
     * @instance
     */
    CGCMsgMemCachedGet.prototype.keys = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedGet message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedGet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedGet} CGCMsgMemCachedGet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedGet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGet();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedGet;
})());
exports.CGCMsgMemCachedGetResponse = ($root.CGCMsgMemCachedGetResponse = (() => {
    /**
     * Properties of a CGCMsgMemCachedGetResponse.
     * @exports ICGCMsgMemCachedGetResponse
     * @interface ICGCMsgMemCachedGetResponse
     * @property {Array.<CGCMsgMemCachedGetResponse.IValueTag>|null} [values] CGCMsgMemCachedGetResponse values
     */
    /**
     * Constructs a new CGCMsgMemCachedGetResponse.
     * @exports CGCMsgMemCachedGetResponse
     * @classdesc Represents a CGCMsgMemCachedGetResponse.
     * @implements ICGCMsgMemCachedGetResponse
     * @constructor
     * @param {ICGCMsgMemCachedGetResponse=} [properties] Properties to set
     */
    function CGCMsgMemCachedGetResponse(properties) {
        this.values = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedGetResponse values.
     * @member {Array.<CGCMsgMemCachedGetResponse.IValueTag>} values
     * @memberof CGCMsgMemCachedGetResponse
     * @instance
     */
    CGCMsgMemCachedGetResponse.prototype.values = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedGetResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedGetResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedGetResponse} CGCMsgMemCachedGetResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedGetResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGetResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    message.values.push($root.CGCMsgMemCachedGetResponse.ValueTag.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CGCMsgMemCachedGetResponse.ValueTag = (function () {
        /**
         * Properties of a ValueTag.
         * @memberof CGCMsgMemCachedGetResponse
         * @interface IValueTag
         * @property {boolean|null} [found] ValueTag found
         * @property {Uint8Array|null} [value] ValueTag value
         */
        /**
         * Constructs a new ValueTag.
         * @memberof CGCMsgMemCachedGetResponse
         * @classdesc Represents a ValueTag.
         * @implements IValueTag
         * @constructor
         * @param {CGCMsgMemCachedGetResponse.IValueTag=} [properties] Properties to set
         */
        function ValueTag(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ValueTag found.
         * @member {boolean} found
         * @memberof CGCMsgMemCachedGetResponse.ValueTag
         * @instance
         */
        ValueTag.prototype.found = false;
        /**
         * ValueTag value.
         * @member {Uint8Array} value
         * @memberof CGCMsgMemCachedGetResponse.ValueTag
         * @instance
         */
        ValueTag.prototype.value = $util.newBuffer([]);
        /**
         * Decodes a ValueTag message from the specified reader or buffer.
         * @function decode
         * @memberof CGCMsgMemCachedGetResponse.ValueTag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CGCMsgMemCachedGetResponse.ValueTag} ValueTag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueTag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGetResponse.ValueTag();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.found = reader.bool();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ValueTag;
    })();
    return CGCMsgMemCachedGetResponse;
})());
exports.CGCMsgMemCachedSet = ($root.CGCMsgMemCachedSet = (() => {
    /**
     * Properties of a CGCMsgMemCachedSet.
     * @exports ICGCMsgMemCachedSet
     * @interface ICGCMsgMemCachedSet
     * @property {Array.<CGCMsgMemCachedSet.IKeyPair>|null} [keys] CGCMsgMemCachedSet keys
     */
    /**
     * Constructs a new CGCMsgMemCachedSet.
     * @exports CGCMsgMemCachedSet
     * @classdesc Represents a CGCMsgMemCachedSet.
     * @implements ICGCMsgMemCachedSet
     * @constructor
     * @param {ICGCMsgMemCachedSet=} [properties] Properties to set
     */
    function CGCMsgMemCachedSet(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedSet keys.
     * @member {Array.<CGCMsgMemCachedSet.IKeyPair>} keys
     * @memberof CGCMsgMemCachedSet
     * @instance
     */
    CGCMsgMemCachedSet.prototype.keys = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedSet message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedSet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedSet} CGCMsgMemCachedSet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedSet();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CGCMsgMemCachedSet.KeyPair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CGCMsgMemCachedSet.KeyPair = (function () {
        /**
         * Properties of a KeyPair.
         * @memberof CGCMsgMemCachedSet
         * @interface IKeyPair
         * @property {string|null} [name] KeyPair name
         * @property {Uint8Array|null} [value] KeyPair value
         */
        /**
         * Constructs a new KeyPair.
         * @memberof CGCMsgMemCachedSet
         * @classdesc Represents a KeyPair.
         * @implements IKeyPair
         * @constructor
         * @param {CGCMsgMemCachedSet.IKeyPair=} [properties] Properties to set
         */
        function KeyPair(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * KeyPair name.
         * @member {string} name
         * @memberof CGCMsgMemCachedSet.KeyPair
         * @instance
         */
        KeyPair.prototype.name = "";
        /**
         * KeyPair value.
         * @member {Uint8Array} value
         * @memberof CGCMsgMemCachedSet.KeyPair
         * @instance
         */
        KeyPair.prototype.value = $util.newBuffer([]);
        /**
         * Decodes a KeyPair message from the specified reader or buffer.
         * @function decode
         * @memberof CGCMsgMemCachedSet.KeyPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CGCMsgMemCachedSet.KeyPair} KeyPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedSet.KeyPair();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return KeyPair;
    })();
    return CGCMsgMemCachedSet;
})());
exports.CGCMsgMemCachedDelete = ($root.CGCMsgMemCachedDelete = (() => {
    /**
     * Properties of a CGCMsgMemCachedDelete.
     * @exports ICGCMsgMemCachedDelete
     * @interface ICGCMsgMemCachedDelete
     * @property {Array.<string>|null} [keys] CGCMsgMemCachedDelete keys
     */
    /**
     * Constructs a new CGCMsgMemCachedDelete.
     * @exports CGCMsgMemCachedDelete
     * @classdesc Represents a CGCMsgMemCachedDelete.
     * @implements ICGCMsgMemCachedDelete
     * @constructor
     * @param {ICGCMsgMemCachedDelete=} [properties] Properties to set
     */
    function CGCMsgMemCachedDelete(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedDelete keys.
     * @member {Array.<string>} keys
     * @memberof CGCMsgMemCachedDelete
     * @instance
     */
    CGCMsgMemCachedDelete.prototype.keys = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedDelete message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedDelete
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedDelete} CGCMsgMemCachedDelete
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedDelete.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedDelete();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedDelete;
})());
exports.CGCMsgMemCachedStats = ($root.CGCMsgMemCachedStats = (() => {
    /**
     * Properties of a CGCMsgMemCachedStats.
     * @exports ICGCMsgMemCachedStats
     * @interface ICGCMsgMemCachedStats
     */
    /**
     * Constructs a new CGCMsgMemCachedStats.
     * @exports CGCMsgMemCachedStats
     * @classdesc Represents a CGCMsgMemCachedStats.
     * @implements ICGCMsgMemCachedStats
     * @constructor
     * @param {ICGCMsgMemCachedStats=} [properties] Properties to set
     */
    function CGCMsgMemCachedStats(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CGCMsgMemCachedStats message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedStats} CGCMsgMemCachedStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedStats;
})());
exports.CGCMsgMemCachedStatsResponse = ($root.CGCMsgMemCachedStatsResponse = (() => {
    /**
     * Properties of a CGCMsgMemCachedStatsResponse.
     * @exports ICGCMsgMemCachedStatsResponse
     * @interface ICGCMsgMemCachedStatsResponse
     * @property {number|Long|null} [currConnections] CGCMsgMemCachedStatsResponse currConnections
     * @property {number|Long|null} [cmdGet] CGCMsgMemCachedStatsResponse cmdGet
     * @property {number|Long|null} [cmdSet] CGCMsgMemCachedStatsResponse cmdSet
     * @property {number|Long|null} [cmdFlush] CGCMsgMemCachedStatsResponse cmdFlush
     * @property {number|Long|null} [getHits] CGCMsgMemCachedStatsResponse getHits
     * @property {number|Long|null} [getMisses] CGCMsgMemCachedStatsResponse getMisses
     * @property {number|Long|null} [deleteHits] CGCMsgMemCachedStatsResponse deleteHits
     * @property {number|Long|null} [deleteMisses] CGCMsgMemCachedStatsResponse deleteMisses
     * @property {number|Long|null} [bytesRead] CGCMsgMemCachedStatsResponse bytesRead
     * @property {number|Long|null} [bytesWritten] CGCMsgMemCachedStatsResponse bytesWritten
     * @property {number|Long|null} [limitMaxbytes] CGCMsgMemCachedStatsResponse limitMaxbytes
     * @property {number|Long|null} [currItems] CGCMsgMemCachedStatsResponse currItems
     * @property {number|Long|null} [evictions] CGCMsgMemCachedStatsResponse evictions
     * @property {number|Long|null} [bytes] CGCMsgMemCachedStatsResponse bytes
     */
    /**
     * Constructs a new CGCMsgMemCachedStatsResponse.
     * @exports CGCMsgMemCachedStatsResponse
     * @classdesc Represents a CGCMsgMemCachedStatsResponse.
     * @implements ICGCMsgMemCachedStatsResponse
     * @constructor
     * @param {ICGCMsgMemCachedStatsResponse=} [properties] Properties to set
     */
    function CGCMsgMemCachedStatsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedStatsResponse currConnections.
     * @member {number|Long} currConnections
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.currConnections = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse cmdGet.
     * @member {number|Long} cmdGet
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.cmdGet = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse cmdSet.
     * @member {number|Long} cmdSet
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.cmdSet = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse cmdFlush.
     * @member {number|Long} cmdFlush
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.cmdFlush = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse getHits.
     * @member {number|Long} getHits
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.getHits = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse getMisses.
     * @member {number|Long} getMisses
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.getMisses = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse deleteHits.
     * @member {number|Long} deleteHits
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.deleteHits = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse deleteMisses.
     * @member {number|Long} deleteMisses
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.deleteMisses = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse bytesRead.
     * @member {number|Long} bytesRead
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.bytesRead = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse bytesWritten.
     * @member {number|Long} bytesWritten
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.bytesWritten = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse limitMaxbytes.
     * @member {number|Long} limitMaxbytes
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.limitMaxbytes = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse currItems.
     * @member {number|Long} currItems
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.currItems = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse evictions.
     * @member {number|Long} evictions
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.evictions = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * CGCMsgMemCachedStatsResponse bytes.
     * @member {number|Long} bytes
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.bytes = $util.Long
        ? $util.Long.fromBits(0, 0, true)
        : 0;
    /**
     * Decodes a CGCMsgMemCachedStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedStatsResponse} CGCMsgMemCachedStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currConnections = reader.uint64();
                    break;
                case 2:
                    message.cmdGet = reader.uint64();
                    break;
                case 3:
                    message.cmdSet = reader.uint64();
                    break;
                case 4:
                    message.cmdFlush = reader.uint64();
                    break;
                case 5:
                    message.getHits = reader.uint64();
                    break;
                case 6:
                    message.getMisses = reader.uint64();
                    break;
                case 7:
                    message.deleteHits = reader.uint64();
                    break;
                case 8:
                    message.deleteMisses = reader.uint64();
                    break;
                case 9:
                    message.bytesRead = reader.uint64();
                    break;
                case 10:
                    message.bytesWritten = reader.uint64();
                    break;
                case 11:
                    message.limitMaxbytes = reader.uint64();
                    break;
                case 12:
                    message.currItems = reader.uint64();
                    break;
                case 13:
                    message.evictions = reader.uint64();
                    break;
                case 14:
                    message.bytes = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedStatsResponse;
})());
exports.CGCMsgSQLStats = ($root.CGCMsgSQLStats = (() => {
    /**
     * Properties of a CGCMsgSQLStats.
     * @exports ICGCMsgSQLStats
     * @interface ICGCMsgSQLStats
     * @property {number|null} [schemaCatalog] CGCMsgSQLStats schemaCatalog
     */
    /**
     * Constructs a new CGCMsgSQLStats.
     * @exports CGCMsgSQLStats
     * @classdesc Represents a CGCMsgSQLStats.
     * @implements ICGCMsgSQLStats
     * @constructor
     * @param {ICGCMsgSQLStats=} [properties] Properties to set
     */
    function CGCMsgSQLStats(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgSQLStats schemaCatalog.
     * @member {number} schemaCatalog
     * @memberof CGCMsgSQLStats
     * @instance
     */
    CGCMsgSQLStats.prototype.schemaCatalog = 0;
    /**
     * Decodes a CGCMsgSQLStats message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgSQLStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgSQLStats} CGCMsgSQLStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgSQLStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSQLStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.schemaCatalog = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgSQLStats;
})());
exports.CGCMsgSQLStatsResponse = ($root.CGCMsgSQLStatsResponse = (() => {
    /**
     * Properties of a CGCMsgSQLStatsResponse.
     * @exports ICGCMsgSQLStatsResponse
     * @interface ICGCMsgSQLStatsResponse
     * @property {number|null} [threads] CGCMsgSQLStatsResponse threads
     * @property {number|null} [threadsConnected] CGCMsgSQLStatsResponse threadsConnected
     * @property {number|null} [threadsActive] CGCMsgSQLStatsResponse threadsActive
     * @property {number|null} [operationsSubmitted] CGCMsgSQLStatsResponse operationsSubmitted
     * @property {number|null} [preparedStatementsExecuted] CGCMsgSQLStatsResponse preparedStatementsExecuted
     * @property {number|null} [nonPreparedStatementsExecuted] CGCMsgSQLStatsResponse nonPreparedStatementsExecuted
     * @property {number|null} [deadlockRetries] CGCMsgSQLStatsResponse deadlockRetries
     * @property {number|null} [operationsTimedOutInQueue] CGCMsgSQLStatsResponse operationsTimedOutInQueue
     * @property {number|null} [errors] CGCMsgSQLStatsResponse errors
     */
    /**
     * Constructs a new CGCMsgSQLStatsResponse.
     * @exports CGCMsgSQLStatsResponse
     * @classdesc Represents a CGCMsgSQLStatsResponse.
     * @implements ICGCMsgSQLStatsResponse
     * @constructor
     * @param {ICGCMsgSQLStatsResponse=} [properties] Properties to set
     */
    function CGCMsgSQLStatsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgSQLStatsResponse threads.
     * @member {number} threads
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.threads = 0;
    /**
     * CGCMsgSQLStatsResponse threadsConnected.
     * @member {number} threadsConnected
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.threadsConnected = 0;
    /**
     * CGCMsgSQLStatsResponse threadsActive.
     * @member {number} threadsActive
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.threadsActive = 0;
    /**
     * CGCMsgSQLStatsResponse operationsSubmitted.
     * @member {number} operationsSubmitted
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.operationsSubmitted = 0;
    /**
     * CGCMsgSQLStatsResponse preparedStatementsExecuted.
     * @member {number} preparedStatementsExecuted
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.preparedStatementsExecuted = 0;
    /**
     * CGCMsgSQLStatsResponse nonPreparedStatementsExecuted.
     * @member {number} nonPreparedStatementsExecuted
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.nonPreparedStatementsExecuted = 0;
    /**
     * CGCMsgSQLStatsResponse deadlockRetries.
     * @member {number} deadlockRetries
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.deadlockRetries = 0;
    /**
     * CGCMsgSQLStatsResponse operationsTimedOutInQueue.
     * @member {number} operationsTimedOutInQueue
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.operationsTimedOutInQueue = 0;
    /**
     * CGCMsgSQLStatsResponse errors.
     * @member {number} errors
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.errors = 0;
    /**
     * Decodes a CGCMsgSQLStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgSQLStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgSQLStatsResponse} CGCMsgSQLStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgSQLStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSQLStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.threads = reader.uint32();
                    break;
                case 2:
                    message.threadsConnected = reader.uint32();
                    break;
                case 3:
                    message.threadsActive = reader.uint32();
                    break;
                case 4:
                    message.operationsSubmitted = reader.uint32();
                    break;
                case 5:
                    message.preparedStatementsExecuted = reader.uint32();
                    break;
                case 6:
                    message.nonPreparedStatementsExecuted = reader.uint32();
                    break;
                case 7:
                    message.deadlockRetries = reader.uint32();
                    break;
                case 8:
                    message.operationsTimedOutInQueue = reader.uint32();
                    break;
                case 9:
                    message.errors = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgSQLStatsResponse;
})());
exports.CMsgAMAddFreeLicense = ($root.CMsgAMAddFreeLicense = (() => {
    /**
     * Properties of a CMsgAMAddFreeLicense.
     * @exports ICMsgAMAddFreeLicense
     * @interface ICMsgAMAddFreeLicense
     * @property {number|Long|null} [steamid] CMsgAMAddFreeLicense steamid
     * @property {number|null} [ipPublic] CMsgAMAddFreeLicense ipPublic
     * @property {number|null} [packageid] CMsgAMAddFreeLicense packageid
     * @property {string|null} [storeCountryCode] CMsgAMAddFreeLicense storeCountryCode
     */
    /**
     * Constructs a new CMsgAMAddFreeLicense.
     * @exports CMsgAMAddFreeLicense
     * @classdesc Represents a CMsgAMAddFreeLicense.
     * @implements ICMsgAMAddFreeLicense
     * @constructor
     * @param {ICMsgAMAddFreeLicense=} [properties] Properties to set
     */
    function CMsgAMAddFreeLicense(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMAddFreeLicense steamid.
     * @member {number|Long} steamid
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMAddFreeLicense ipPublic.
     * @member {number} ipPublic
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.ipPublic = 0;
    /**
     * CMsgAMAddFreeLicense packageid.
     * @member {number} packageid
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.packageid = 0;
    /**
     * CMsgAMAddFreeLicense storeCountryCode.
     * @member {string} storeCountryCode
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.storeCountryCode = "";
    /**
     * Decodes a CMsgAMAddFreeLicense message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMAddFreeLicense
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMAddFreeLicense} CMsgAMAddFreeLicense
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMAddFreeLicense.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMAddFreeLicense();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.ipPublic = reader.uint32();
                    break;
                case 3:
                    message.packageid = reader.uint32();
                    break;
                case 4:
                    message.storeCountryCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMAddFreeLicense;
})());
exports.CMsgAMAddFreeLicenseResponse = ($root.CMsgAMAddFreeLicenseResponse = (() => {
    /**
     * Properties of a CMsgAMAddFreeLicenseResponse.
     * @exports ICMsgAMAddFreeLicenseResponse
     * @interface ICMsgAMAddFreeLicenseResponse
     * @property {number|null} [eresult] CMsgAMAddFreeLicenseResponse eresult
     * @property {number|null} [purchaseResultDetail] CMsgAMAddFreeLicenseResponse purchaseResultDetail
     * @property {number|Long|null} [transid] CMsgAMAddFreeLicenseResponse transid
     */
    /**
     * Constructs a new CMsgAMAddFreeLicenseResponse.
     * @exports CMsgAMAddFreeLicenseResponse
     * @classdesc Represents a CMsgAMAddFreeLicenseResponse.
     * @implements ICMsgAMAddFreeLicenseResponse
     * @constructor
     * @param {ICMsgAMAddFreeLicenseResponse=} [properties] Properties to set
     */
    function CMsgAMAddFreeLicenseResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMAddFreeLicenseResponse eresult.
     * @member {number} eresult
     * @memberof CMsgAMAddFreeLicenseResponse
     * @instance
     */
    CMsgAMAddFreeLicenseResponse.prototype.eresult = 2;
    /**
     * CMsgAMAddFreeLicenseResponse purchaseResultDetail.
     * @member {number} purchaseResultDetail
     * @memberof CMsgAMAddFreeLicenseResponse
     * @instance
     */
    CMsgAMAddFreeLicenseResponse.prototype.purchaseResultDetail = 0;
    /**
     * CMsgAMAddFreeLicenseResponse transid.
     * @member {number|Long} transid
     * @memberof CMsgAMAddFreeLicenseResponse
     * @instance
     */
    CMsgAMAddFreeLicenseResponse.prototype.transid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * Decodes a CMsgAMAddFreeLicenseResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMAddFreeLicenseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMAddFreeLicenseResponse} CMsgAMAddFreeLicenseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMAddFreeLicenseResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMAddFreeLicenseResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                case 2:
                    message.purchaseResultDetail = reader.int32();
                    break;
                case 3:
                    message.transid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMAddFreeLicenseResponse;
})());
exports.CGCMsgGetIPLocation = ($root.CGCMsgGetIPLocation = (() => {
    /**
     * Properties of a CGCMsgGetIPLocation.
     * @exports ICGCMsgGetIPLocation
     * @interface ICGCMsgGetIPLocation
     * @property {Array.<number>|null} [ips] CGCMsgGetIPLocation ips
     */
    /**
     * Constructs a new CGCMsgGetIPLocation.
     * @exports CGCMsgGetIPLocation
     * @classdesc Represents a CGCMsgGetIPLocation.
     * @implements ICGCMsgGetIPLocation
     * @constructor
     * @param {ICGCMsgGetIPLocation=} [properties] Properties to set
     */
    function CGCMsgGetIPLocation(properties) {
        this.ips = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgGetIPLocation ips.
     * @member {Array.<number>} ips
     * @memberof CGCMsgGetIPLocation
     * @instance
     */
    CGCMsgGetIPLocation.prototype.ips = $util.emptyArray;
    /**
     * Decodes a CGCMsgGetIPLocation message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetIPLocation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetIPLocation} CGCMsgGetIPLocation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetIPLocation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetIPLocation();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.ips && message.ips.length))
                        message.ips = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ips.push(reader.fixed32());
                    }
                    else
                        message.ips.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetIPLocation;
})());
exports.CIPLocationInfo = ($root.CIPLocationInfo = (() => {
    /**
     * Properties of a CIPLocationInfo.
     * @exports ICIPLocationInfo
     * @interface ICIPLocationInfo
     * @property {number|null} [ip] CIPLocationInfo ip
     * @property {number|null} [latitude] CIPLocationInfo latitude
     * @property {number|null} [longitude] CIPLocationInfo longitude
     * @property {string|null} [country] CIPLocationInfo country
     * @property {string|null} [state] CIPLocationInfo state
     * @property {string|null} [city] CIPLocationInfo city
     */
    /**
     * Constructs a new CIPLocationInfo.
     * @exports CIPLocationInfo
     * @classdesc Represents a CIPLocationInfo.
     * @implements ICIPLocationInfo
     * @constructor
     * @param {ICIPLocationInfo=} [properties] Properties to set
     */
    function CIPLocationInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CIPLocationInfo ip.
     * @member {number} ip
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.ip = 0;
    /**
     * CIPLocationInfo latitude.
     * @member {number} latitude
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.latitude = 0;
    /**
     * CIPLocationInfo longitude.
     * @member {number} longitude
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.longitude = 0;
    /**
     * CIPLocationInfo country.
     * @member {string} country
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.country = "";
    /**
     * CIPLocationInfo state.
     * @member {string} state
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.state = "";
    /**
     * CIPLocationInfo city.
     * @member {string} city
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.city = "";
    /**
     * Decodes a CIPLocationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CIPLocationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CIPLocationInfo} CIPLocationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CIPLocationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CIPLocationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ip = reader.uint32();
                    break;
                case 2:
                    message.latitude = reader.float();
                    break;
                case 3:
                    message.longitude = reader.float();
                    break;
                case 4:
                    message.country = reader.string();
                    break;
                case 5:
                    message.state = reader.string();
                    break;
                case 6:
                    message.city = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CIPLocationInfo;
})());
exports.CGCMsgGetIPLocationResponse = ($root.CGCMsgGetIPLocationResponse = (() => {
    /**
     * Properties of a CGCMsgGetIPLocationResponse.
     * @exports ICGCMsgGetIPLocationResponse
     * @interface ICGCMsgGetIPLocationResponse
     * @property {Array.<ICIPLocationInfo>|null} [infos] CGCMsgGetIPLocationResponse infos
     */
    /**
     * Constructs a new CGCMsgGetIPLocationResponse.
     * @exports CGCMsgGetIPLocationResponse
     * @classdesc Represents a CGCMsgGetIPLocationResponse.
     * @implements ICGCMsgGetIPLocationResponse
     * @constructor
     * @param {ICGCMsgGetIPLocationResponse=} [properties] Properties to set
     */
    function CGCMsgGetIPLocationResponse(properties) {
        this.infos = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgGetIPLocationResponse infos.
     * @member {Array.<ICIPLocationInfo>} infos
     * @memberof CGCMsgGetIPLocationResponse
     * @instance
     */
    CGCMsgGetIPLocationResponse.prototype.infos = $util.emptyArray;
    /**
     * Decodes a CGCMsgGetIPLocationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetIPLocationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetIPLocationResponse} CGCMsgGetIPLocationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetIPLocationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetIPLocationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.CIPLocationInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetIPLocationResponse;
})());
exports.CGCMsgSystemStatsSchema = ($root.CGCMsgSystemStatsSchema = (() => {
    /**
     * Properties of a CGCMsgSystemStatsSchema.
     * @exports ICGCMsgSystemStatsSchema
     * @interface ICGCMsgSystemStatsSchema
     * @property {number|null} [gcAppId] CGCMsgSystemStatsSchema gcAppId
     * @property {Uint8Array|null} [schemaKv] CGCMsgSystemStatsSchema schemaKv
     */
    /**
     * Constructs a new CGCMsgSystemStatsSchema.
     * @exports CGCMsgSystemStatsSchema
     * @classdesc Represents a CGCMsgSystemStatsSchema.
     * @implements ICGCMsgSystemStatsSchema
     * @constructor
     * @param {ICGCMsgSystemStatsSchema=} [properties] Properties to set
     */
    function CGCMsgSystemStatsSchema(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgSystemStatsSchema gcAppId.
     * @member {number} gcAppId
     * @memberof CGCMsgSystemStatsSchema
     * @instance
     */
    CGCMsgSystemStatsSchema.prototype.gcAppId = 0;
    /**
     * CGCMsgSystemStatsSchema schemaKv.
     * @member {Uint8Array} schemaKv
     * @memberof CGCMsgSystemStatsSchema
     * @instance
     */
    CGCMsgSystemStatsSchema.prototype.schemaKv = $util.newBuffer([]);
    /**
     * Decodes a CGCMsgSystemStatsSchema message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgSystemStatsSchema
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgSystemStatsSchema} CGCMsgSystemStatsSchema
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgSystemStatsSchema.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSystemStatsSchema();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gcAppId = reader.uint32();
                    break;
                case 2:
                    message.schemaKv = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgSystemStatsSchema;
})());
exports.CGCMsgGetSystemStats = ($root.CGCMsgGetSystemStats = (() => {
    /**
     * Properties of a CGCMsgGetSystemStats.
     * @exports ICGCMsgGetSystemStats
     * @interface ICGCMsgGetSystemStats
     */
    /**
     * Constructs a new CGCMsgGetSystemStats.
     * @exports CGCMsgGetSystemStats
     * @classdesc Represents a CGCMsgGetSystemStats.
     * @implements ICGCMsgGetSystemStats
     * @constructor
     * @param {ICGCMsgGetSystemStats=} [properties] Properties to set
     */
    function CGCMsgGetSystemStats(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CGCMsgGetSystemStats message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetSystemStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetSystemStats} CGCMsgGetSystemStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetSystemStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetSystemStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetSystemStats;
})());
exports.CGCMsgGetSystemStatsResponse = ($root.CGCMsgGetSystemStatsResponse = (() => {
    /**
     * Properties of a CGCMsgGetSystemStatsResponse.
     * @exports ICGCMsgGetSystemStatsResponse
     * @interface ICGCMsgGetSystemStatsResponse
     * @property {number|null} [gcAppId] CGCMsgGetSystemStatsResponse gcAppId
     * @property {Uint8Array|null} [statsKv] CGCMsgGetSystemStatsResponse statsKv
     * @property {number|null} [activeJobs] CGCMsgGetSystemStatsResponse activeJobs
     * @property {number|null} [yieldingJobs] CGCMsgGetSystemStatsResponse yieldingJobs
     * @property {number|null} [userSessions] CGCMsgGetSystemStatsResponse userSessions
     * @property {number|null} [gameServerSessions] CGCMsgGetSystemStatsResponse gameServerSessions
     * @property {number|null} [socaches] CGCMsgGetSystemStatsResponse socaches
     * @property {number|null} [socachesToUnload] CGCMsgGetSystemStatsResponse socachesToUnload
     * @property {number|null} [socachesLoading] CGCMsgGetSystemStatsResponse socachesLoading
     * @property {number|null} [writebackQueue] CGCMsgGetSystemStatsResponse writebackQueue
     * @property {number|null} [steamidLocks] CGCMsgGetSystemStatsResponse steamidLocks
     * @property {number|null} [logonQueue] CGCMsgGetSystemStatsResponse logonQueue
     * @property {number|null} [logonJobs] CGCMsgGetSystemStatsResponse logonJobs
     */
    /**
     * Constructs a new CGCMsgGetSystemStatsResponse.
     * @exports CGCMsgGetSystemStatsResponse
     * @classdesc Represents a CGCMsgGetSystemStatsResponse.
     * @implements ICGCMsgGetSystemStatsResponse
     * @constructor
     * @param {ICGCMsgGetSystemStatsResponse=} [properties] Properties to set
     */
    function CGCMsgGetSystemStatsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgGetSystemStatsResponse gcAppId.
     * @member {number} gcAppId
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.gcAppId = 0;
    /**
     * CGCMsgGetSystemStatsResponse statsKv.
     * @member {Uint8Array} statsKv
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.statsKv = $util.newBuffer([]);
    /**
     * CGCMsgGetSystemStatsResponse activeJobs.
     * @member {number} activeJobs
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.activeJobs = 0;
    /**
     * CGCMsgGetSystemStatsResponse yieldingJobs.
     * @member {number} yieldingJobs
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.yieldingJobs = 0;
    /**
     * CGCMsgGetSystemStatsResponse userSessions.
     * @member {number} userSessions
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.userSessions = 0;
    /**
     * CGCMsgGetSystemStatsResponse gameServerSessions.
     * @member {number} gameServerSessions
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.gameServerSessions = 0;
    /**
     * CGCMsgGetSystemStatsResponse socaches.
     * @member {number} socaches
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.socaches = 0;
    /**
     * CGCMsgGetSystemStatsResponse socachesToUnload.
     * @member {number} socachesToUnload
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.socachesToUnload = 0;
    /**
     * CGCMsgGetSystemStatsResponse socachesLoading.
     * @member {number} socachesLoading
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.socachesLoading = 0;
    /**
     * CGCMsgGetSystemStatsResponse writebackQueue.
     * @member {number} writebackQueue
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.writebackQueue = 0;
    /**
     * CGCMsgGetSystemStatsResponse steamidLocks.
     * @member {number} steamidLocks
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.steamidLocks = 0;
    /**
     * CGCMsgGetSystemStatsResponse logonQueue.
     * @member {number} logonQueue
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.logonQueue = 0;
    /**
     * CGCMsgGetSystemStatsResponse logonJobs.
     * @member {number} logonJobs
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.logonJobs = 0;
    /**
     * Decodes a CGCMsgGetSystemStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetSystemStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetSystemStatsResponse} CGCMsgGetSystemStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetSystemStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetSystemStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gcAppId = reader.uint32();
                    break;
                case 2:
                    message.statsKv = reader.bytes();
                    break;
                case 3:
                    message.activeJobs = reader.uint32();
                    break;
                case 4:
                    message.yieldingJobs = reader.uint32();
                    break;
                case 5:
                    message.userSessions = reader.uint32();
                    break;
                case 6:
                    message.gameServerSessions = reader.uint32();
                    break;
                case 7:
                    message.socaches = reader.uint32();
                    break;
                case 8:
                    message.socachesToUnload = reader.uint32();
                    break;
                case 9:
                    message.socachesLoading = reader.uint32();
                    break;
                case 10:
                    message.writebackQueue = reader.uint32();
                    break;
                case 11:
                    message.steamidLocks = reader.uint32();
                    break;
                case 12:
                    message.logonQueue = reader.uint32();
                    break;
                case 13:
                    message.logonJobs = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetSystemStatsResponse;
})());
exports.CMsgAMSendEmail = ($root.CMsgAMSendEmail = (() => {
    /**
     * Properties of a CMsgAMSendEmail.
     * @exports ICMsgAMSendEmail
     * @interface ICMsgAMSendEmail
     * @property {number|Long|null} [steamid] CMsgAMSendEmail steamid
     * @property {number|null} [emailMsgType] CMsgAMSendEmail emailMsgType
     * @property {number|null} [emailFormat] CMsgAMSendEmail emailFormat
     * @property {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>|null} [personaNameTokens] CMsgAMSendEmail personaNameTokens
     * @property {number|null} [sourceGc] CMsgAMSendEmail sourceGc
     * @property {Array.<CMsgAMSendEmail.IReplacementToken>|null} [tokens] CMsgAMSendEmail tokens
     */
    /**
     * Constructs a new CMsgAMSendEmail.
     * @exports CMsgAMSendEmail
     * @classdesc Represents a CMsgAMSendEmail.
     * @implements ICMsgAMSendEmail
     * @constructor
     * @param {ICMsgAMSendEmail=} [properties] Properties to set
     */
    function CMsgAMSendEmail(properties) {
        this.personaNameTokens = [];
        this.tokens = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMSendEmail steamid.
     * @member {number|Long} steamid
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMSendEmail emailMsgType.
     * @member {number} emailMsgType
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.emailMsgType = 0;
    /**
     * CMsgAMSendEmail emailFormat.
     * @member {number} emailFormat
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.emailFormat = 0;
    /**
     * CMsgAMSendEmail personaNameTokens.
     * @member {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>} personaNameTokens
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.personaNameTokens = $util.emptyArray;
    /**
     * CMsgAMSendEmail sourceGc.
     * @member {number} sourceGc
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.sourceGc = 0;
    /**
     * CMsgAMSendEmail tokens.
     * @member {Array.<CMsgAMSendEmail.IReplacementToken>} tokens
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.tokens = $util.emptyArray;
    /**
     * Decodes a CMsgAMSendEmail message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMSendEmail
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMSendEmail} CMsgAMSendEmail
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMSendEmail.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case 3:
                    message.emailFormat = reader.uint32();
                    break;
                case 5:
                    if (!(message.personaNameTokens && message.personaNameTokens.length))
                        message.personaNameTokens = [];
                    message.personaNameTokens.push($root.CMsgAMSendEmail.PersonaNameReplacementToken.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.sourceGc = reader.uint32();
                    break;
                case 7:
                    if (!(message.tokens && message.tokens.length))
                        message.tokens = [];
                    message.tokens.push($root.CMsgAMSendEmail.ReplacementToken.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgAMSendEmail.ReplacementToken = (function () {
        /**
         * Properties of a ReplacementToken.
         * @memberof CMsgAMSendEmail
         * @interface IReplacementToken
         * @property {string|null} [tokenName] ReplacementToken tokenName
         * @property {string|null} [tokenValue] ReplacementToken tokenValue
         */
        /**
         * Constructs a new ReplacementToken.
         * @memberof CMsgAMSendEmail
         * @classdesc Represents a ReplacementToken.
         * @implements IReplacementToken
         * @constructor
         * @param {CMsgAMSendEmail.IReplacementToken=} [properties] Properties to set
         */
        function ReplacementToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ReplacementToken tokenName.
         * @member {string} tokenName
         * @memberof CMsgAMSendEmail.ReplacementToken
         * @instance
         */
        ReplacementToken.prototype.tokenName = "";
        /**
         * ReplacementToken tokenValue.
         * @member {string} tokenValue
         * @memberof CMsgAMSendEmail.ReplacementToken
         * @instance
         */
        ReplacementToken.prototype.tokenValue = "";
        /**
         * Decodes a ReplacementToken message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMSendEmail.ReplacementToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMSendEmail.ReplacementToken} ReplacementToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplacementToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail.ReplacementToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.tokenName = reader.string();
                        break;
                    case 2:
                        message.tokenValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ReplacementToken;
    })();
    CMsgAMSendEmail.PersonaNameReplacementToken = (function () {
        /**
         * Properties of a PersonaNameReplacementToken.
         * @memberof CMsgAMSendEmail
         * @interface IPersonaNameReplacementToken
         * @property {number|Long|null} [steamid] PersonaNameReplacementToken steamid
         * @property {string|null} [tokenName] PersonaNameReplacementToken tokenName
         */
        /**
         * Constructs a new PersonaNameReplacementToken.
         * @memberof CMsgAMSendEmail
         * @classdesc Represents a PersonaNameReplacementToken.
         * @implements IPersonaNameReplacementToken
         * @constructor
         * @param {CMsgAMSendEmail.IPersonaNameReplacementToken=} [properties] Properties to set
         */
        function PersonaNameReplacementToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PersonaNameReplacementToken steamid.
         * @member {number|Long} steamid
         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken
         * @instance
         */
        PersonaNameReplacementToken.prototype.steamid = $util.Long
            ? $util.Long.fromBits(0, 0, false)
            : 0;
        /**
         * PersonaNameReplacementToken tokenName.
         * @member {string} tokenName
         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken
         * @instance
         */
        PersonaNameReplacementToken.prototype.tokenName = "";
        /**
         * Decodes a PersonaNameReplacementToken message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMSendEmail.PersonaNameReplacementToken} PersonaNameReplacementToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersonaNameReplacementToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail.PersonaNameReplacementToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.steamid = reader.fixed64();
                        break;
                    case 2:
                        message.tokenName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return PersonaNameReplacementToken;
    })();
    return CMsgAMSendEmail;
})());
exports.CMsgAMSendEmailResponse = ($root.CMsgAMSendEmailResponse = (() => {
    /**
     * Properties of a CMsgAMSendEmailResponse.
     * @exports ICMsgAMSendEmailResponse
     * @interface ICMsgAMSendEmailResponse
     * @property {number|null} [eresult] CMsgAMSendEmailResponse eresult
     */
    /**
     * Constructs a new CMsgAMSendEmailResponse.
     * @exports CMsgAMSendEmailResponse
     * @classdesc Represents a CMsgAMSendEmailResponse.
     * @implements ICMsgAMSendEmailResponse
     * @constructor
     * @param {ICMsgAMSendEmailResponse=} [properties] Properties to set
     */
    function CMsgAMSendEmailResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMSendEmailResponse eresult.
     * @member {number} eresult
     * @memberof CMsgAMSendEmailResponse
     * @instance
     */
    CMsgAMSendEmailResponse.prototype.eresult = 2;
    /**
     * Decodes a CMsgAMSendEmailResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMSendEmailResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMSendEmailResponse} CMsgAMSendEmailResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMSendEmailResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmailResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMSendEmailResponse;
})());
exports.CMsgGCGetEmailTemplate = ($root.CMsgGCGetEmailTemplate = (() => {
    /**
     * Properties of a CMsgGCGetEmailTemplate.
     * @exports ICMsgGCGetEmailTemplate
     * @interface ICMsgGCGetEmailTemplate
     * @property {number|null} [appId] CMsgGCGetEmailTemplate appId
     * @property {number|null} [emailMsgType] CMsgGCGetEmailTemplate emailMsgType
     * @property {number|null} [emailLang] CMsgGCGetEmailTemplate emailLang
     * @property {number|null} [emailFormat] CMsgGCGetEmailTemplate emailFormat
     */
    /**
     * Constructs a new CMsgGCGetEmailTemplate.
     * @exports CMsgGCGetEmailTemplate
     * @classdesc Represents a CMsgGCGetEmailTemplate.
     * @implements ICMsgGCGetEmailTemplate
     * @constructor
     * @param {ICMsgGCGetEmailTemplate=} [properties] Properties to set
     */
    function CMsgGCGetEmailTemplate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetEmailTemplate appId.
     * @member {number} appId
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.appId = 0;
    /**
     * CMsgGCGetEmailTemplate emailMsgType.
     * @member {number} emailMsgType
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.emailMsgType = 0;
    /**
     * CMsgGCGetEmailTemplate emailLang.
     * @member {number} emailLang
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.emailLang = 0;
    /**
     * CMsgGCGetEmailTemplate emailFormat.
     * @member {number} emailFormat
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.emailFormat = 0;
    /**
     * Decodes a CMsgGCGetEmailTemplate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetEmailTemplate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetEmailTemplate} CMsgGCGetEmailTemplate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetEmailTemplate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetEmailTemplate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appId = reader.uint32();
                    break;
                case 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case 3:
                    message.emailLang = reader.int32();
                    break;
                case 4:
                    message.emailFormat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetEmailTemplate;
})());
exports.CMsgGCGetEmailTemplateResponse = ($root.CMsgGCGetEmailTemplateResponse = (() => {
    /**
     * Properties of a CMsgGCGetEmailTemplateResponse.
     * @exports ICMsgGCGetEmailTemplateResponse
     * @interface ICMsgGCGetEmailTemplateResponse
     * @property {number|null} [eresult] CMsgGCGetEmailTemplateResponse eresult
     * @property {boolean|null} [templateExists] CMsgGCGetEmailTemplateResponse templateExists
     * @property {string|null} [template] CMsgGCGetEmailTemplateResponse template
     */
    /**
     * Constructs a new CMsgGCGetEmailTemplateResponse.
     * @exports CMsgGCGetEmailTemplateResponse
     * @classdesc Represents a CMsgGCGetEmailTemplateResponse.
     * @implements ICMsgGCGetEmailTemplateResponse
     * @constructor
     * @param {ICMsgGCGetEmailTemplateResponse=} [properties] Properties to set
     */
    function CMsgGCGetEmailTemplateResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetEmailTemplateResponse eresult.
     * @member {number} eresult
     * @memberof CMsgGCGetEmailTemplateResponse
     * @instance
     */
    CMsgGCGetEmailTemplateResponse.prototype.eresult = 2;
    /**
     * CMsgGCGetEmailTemplateResponse templateExists.
     * @member {boolean} templateExists
     * @memberof CMsgGCGetEmailTemplateResponse
     * @instance
     */
    CMsgGCGetEmailTemplateResponse.prototype.templateExists = false;
    /**
     * CMsgGCGetEmailTemplateResponse template.
     * @member {string} template
     * @memberof CMsgGCGetEmailTemplateResponse
     * @instance
     */
    CMsgGCGetEmailTemplateResponse.prototype.template = "";
    /**
     * Decodes a CMsgGCGetEmailTemplateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetEmailTemplateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetEmailTemplateResponse} CMsgGCGetEmailTemplateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetEmailTemplateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetEmailTemplateResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.uint32();
                    break;
                case 2:
                    message.templateExists = reader.bool();
                    break;
                case 3:
                    message.template = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetEmailTemplateResponse;
})());
exports.CMsgAMGrantGuestPasses2 = ($root.CMsgAMGrantGuestPasses2 = (() => {
    /**
     * Properties of a CMsgAMGrantGuestPasses2.
     * @exports ICMsgAMGrantGuestPasses2
     * @interface ICMsgAMGrantGuestPasses2
     * @property {number|Long|null} [steamId] CMsgAMGrantGuestPasses2 steamId
     * @property {number|null} [packageId] CMsgAMGrantGuestPasses2 packageId
     * @property {number|null} [passesToGrant] CMsgAMGrantGuestPasses2 passesToGrant
     * @property {number|null} [daysToExpiration] CMsgAMGrantGuestPasses2 daysToExpiration
     * @property {number|null} [action] CMsgAMGrantGuestPasses2 action
     */
    /**
     * Constructs a new CMsgAMGrantGuestPasses2.
     * @exports CMsgAMGrantGuestPasses2
     * @classdesc Represents a CMsgAMGrantGuestPasses2.
     * @implements ICMsgAMGrantGuestPasses2
     * @constructor
     * @param {ICMsgAMGrantGuestPasses2=} [properties] Properties to set
     */
    function CMsgAMGrantGuestPasses2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGrantGuestPasses2 steamId.
     * @member {number|Long} steamId
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.steamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgAMGrantGuestPasses2 packageId.
     * @member {number} packageId
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.packageId = 0;
    /**
     * CMsgAMGrantGuestPasses2 passesToGrant.
     * @member {number} passesToGrant
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.passesToGrant = 0;
    /**
     * CMsgAMGrantGuestPasses2 daysToExpiration.
     * @member {number} daysToExpiration
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.daysToExpiration = 0;
    /**
     * CMsgAMGrantGuestPasses2 action.
     * @member {number} action
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.action = 0;
    /**
     * Decodes a CMsgAMGrantGuestPasses2 message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGrantGuestPasses2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGrantGuestPasses2} CMsgAMGrantGuestPasses2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGrantGuestPasses2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGrantGuestPasses2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.packageId = reader.uint32();
                    break;
                case 3:
                    message.passesToGrant = reader.int32();
                    break;
                case 4:
                    message.daysToExpiration = reader.int32();
                    break;
                case 5:
                    message.action = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGrantGuestPasses2;
})());
exports.CMsgAMGrantGuestPasses2Response = ($root.CMsgAMGrantGuestPasses2Response = (() => {
    /**
     * Properties of a CMsgAMGrantGuestPasses2Response.
     * @exports ICMsgAMGrantGuestPasses2Response
     * @interface ICMsgAMGrantGuestPasses2Response
     * @property {number|null} [eresult] CMsgAMGrantGuestPasses2Response eresult
     * @property {number|null} [passesGranted] CMsgAMGrantGuestPasses2Response passesGranted
     */
    /**
     * Constructs a new CMsgAMGrantGuestPasses2Response.
     * @exports CMsgAMGrantGuestPasses2Response
     * @classdesc Represents a CMsgAMGrantGuestPasses2Response.
     * @implements ICMsgAMGrantGuestPasses2Response
     * @constructor
     * @param {ICMsgAMGrantGuestPasses2Response=} [properties] Properties to set
     */
    function CMsgAMGrantGuestPasses2Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGrantGuestPasses2Response eresult.
     * @member {number} eresult
     * @memberof CMsgAMGrantGuestPasses2Response
     * @instance
     */
    CMsgAMGrantGuestPasses2Response.prototype.eresult = 2;
    /**
     * CMsgAMGrantGuestPasses2Response passesGranted.
     * @member {number} passesGranted
     * @memberof CMsgAMGrantGuestPasses2Response
     * @instance
     */
    CMsgAMGrantGuestPasses2Response.prototype.passesGranted = 0;
    /**
     * Decodes a CMsgAMGrantGuestPasses2Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGrantGuestPasses2Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGrantGuestPasses2Response} CMsgAMGrantGuestPasses2Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGrantGuestPasses2Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGrantGuestPasses2Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                case 2:
                    message.passesGranted = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGrantGuestPasses2Response;
})());
exports.CGCSystemMsg_GetAccountDetails = ($root.CGCSystemMsg_GetAccountDetails = (() => {
    /**
     * Properties of a CGCSystemMsg_GetAccountDetails.
     * @exports ICGCSystemMsg_GetAccountDetails
     * @interface ICGCSystemMsg_GetAccountDetails
     * @property {number|Long|null} [steamid] CGCSystemMsg_GetAccountDetails steamid
     * @property {number|null} [appid] CGCSystemMsg_GetAccountDetails appid
     */
    /**
     * Constructs a new CGCSystemMsg_GetAccountDetails.
     * @exports CGCSystemMsg_GetAccountDetails
     * @classdesc Represents a CGCSystemMsg_GetAccountDetails.
     * @implements ICGCSystemMsg_GetAccountDetails
     * @constructor
     * @param {ICGCSystemMsg_GetAccountDetails=} [properties] Properties to set
     */
    function CGCSystemMsg_GetAccountDetails(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetAccountDetails steamid.
     * @member {number|Long} steamid
     * @memberof CGCSystemMsg_GetAccountDetails
     * @instance
     */
    CGCSystemMsg_GetAccountDetails.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CGCSystemMsg_GetAccountDetails appid.
     * @member {number} appid
     * @memberof CGCSystemMsg_GetAccountDetails
     * @instance
     */
    CGCSystemMsg_GetAccountDetails.prototype.appid = 0;
    /**
     * Decodes a CGCSystemMsg_GetAccountDetails message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetAccountDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetAccountDetails} CGCSystemMsg_GetAccountDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetAccountDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetAccountDetails();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetAccountDetails;
})());
exports.CGCSystemMsg_GetAccountDetails_Response = ($root.CGCSystemMsg_GetAccountDetails_Response = (() => {
    /**
     * Properties of a CGCSystemMsg_GetAccountDetails_Response.
     * @exports ICGCSystemMsg_GetAccountDetails_Response
     * @interface ICGCSystemMsg_GetAccountDetails_Response
     * @property {number|null} [eresultDeprecated] CGCSystemMsg_GetAccountDetails_Response eresultDeprecated
     * @property {string|null} [accountName] CGCSystemMsg_GetAccountDetails_Response accountName
     * @property {string|null} [personaName] CGCSystemMsg_GetAccountDetails_Response personaName
     * @property {boolean|null} [isProfilePublic] CGCSystemMsg_GetAccountDetails_Response isProfilePublic
     * @property {boolean|null} [isInventoryPublic] CGCSystemMsg_GetAccountDetails_Response isInventoryPublic
     * @property {boolean|null} [isVacBanned] CGCSystemMsg_GetAccountDetails_Response isVacBanned
     * @property {boolean|null} [isCyberCafe] CGCSystemMsg_GetAccountDetails_Response isCyberCafe
     * @property {boolean|null} [isSchoolAccount] CGCSystemMsg_GetAccountDetails_Response isSchoolAccount
     * @property {boolean|null} [isLimited] CGCSystemMsg_GetAccountDetails_Response isLimited
     * @property {boolean|null} [isSubscribed] CGCSystemMsg_GetAccountDetails_Response isSubscribed
     * @property {number|null} ["package"] CGCSystemMsg_GetAccountDetails_Response package
     * @property {boolean|null} [isFreeTrialAccount] CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount
     * @property {number|null} [freeTrialExpiration] CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration
     * @property {boolean|null} [isLowViolence] CGCSystemMsg_GetAccountDetails_Response isLowViolence
     * @property {boolean|null} [isAccountLockedDown] CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown
     * @property {boolean|null} [isCommunityBanned] CGCSystemMsg_GetAccountDetails_Response isCommunityBanned
     * @property {boolean|null} [isTradeBanned] CGCSystemMsg_GetAccountDetails_Response isTradeBanned
     * @property {number|null} [tradeBanExpiration] CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration
     * @property {number|null} [accountid] CGCSystemMsg_GetAccountDetails_Response accountid
     * @property {number|null} [suspensionEndTime] CGCSystemMsg_GetAccountDetails_Response suspensionEndTime
     * @property {string|null} [currency] CGCSystemMsg_GetAccountDetails_Response currency
     * @property {number|null} [steamLevel] CGCSystemMsg_GetAccountDetails_Response steamLevel
     */
    /**
     * Constructs a new CGCSystemMsg_GetAccountDetails_Response.
     * @exports CGCSystemMsg_GetAccountDetails_Response
     * @classdesc Represents a CGCSystemMsg_GetAccountDetails_Response.
     * @implements ICGCSystemMsg_GetAccountDetails_Response
     * @constructor
     * @param {ICGCSystemMsg_GetAccountDetails_Response=} [properties] Properties to set
     */
    function CGCSystemMsg_GetAccountDetails_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetAccountDetails_Response eresultDeprecated.
     * @member {number} eresultDeprecated
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.eresultDeprecated = 2;
    /**
     * CGCSystemMsg_GetAccountDetails_Response accountName.
     * @member {string} accountName
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.accountName = "";
    /**
     * CGCSystemMsg_GetAccountDetails_Response personaName.
     * @member {string} personaName
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.personaName = "";
    /**
     * CGCSystemMsg_GetAccountDetails_Response isProfilePublic.
     * @member {boolean} isProfilePublic
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isProfilePublic = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isInventoryPublic.
     * @member {boolean} isInventoryPublic
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isInventoryPublic = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isVacBanned.
     * @member {boolean} isVacBanned
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isVacBanned = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isCyberCafe.
     * @member {boolean} isCyberCafe
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isCyberCafe = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isSchoolAccount.
     * @member {boolean} isSchoolAccount
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isSchoolAccount = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isLimited.
     * @member {boolean} isLimited
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isLimited = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isSubscribed.
     * @member {boolean} isSubscribed
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isSubscribed = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response package.
     * @member {number} package
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype["package"] = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount.
     * @member {boolean} isFreeTrialAccount
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isFreeTrialAccount = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration.
     * @member {number} freeTrialExpiration
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.freeTrialExpiration = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isLowViolence.
     * @member {boolean} isLowViolence
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isLowViolence = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown.
     * @member {boolean} isAccountLockedDown
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isAccountLockedDown = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isCommunityBanned.
     * @member {boolean} isCommunityBanned
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isCommunityBanned = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isTradeBanned.
     * @member {boolean} isTradeBanned
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isTradeBanned = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration.
     * @member {number} tradeBanExpiration
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.tradeBanExpiration = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response accountid.
     * @member {number} accountid
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.accountid = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response suspensionEndTime.
     * @member {number} suspensionEndTime
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.suspensionEndTime = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response currency.
     * @member {string} currency
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.currency = "";
    /**
     * CGCSystemMsg_GetAccountDetails_Response steamLevel.
     * @member {number} steamLevel
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.steamLevel = 0;
    /**
     * Decodes a CGCSystemMsg_GetAccountDetails_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetAccountDetails_Response} CGCSystemMsg_GetAccountDetails_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetAccountDetails_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetAccountDetails_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresultDeprecated = reader.uint32();
                    break;
                case 2:
                    message.accountName = reader.string();
                    break;
                case 3:
                    message.personaName = reader.string();
                    break;
                case 4:
                    message.isProfilePublic = reader.bool();
                    break;
                case 5:
                    message.isInventoryPublic = reader.bool();
                    break;
                case 7:
                    message.isVacBanned = reader.bool();
                    break;
                case 8:
                    message.isCyberCafe = reader.bool();
                    break;
                case 9:
                    message.isSchoolAccount = reader.bool();
                    break;
                case 10:
                    message.isLimited = reader.bool();
                    break;
                case 11:
                    message.isSubscribed = reader.bool();
                    break;
                case 12:
                    message["package"] = reader.uint32();
                    break;
                case 13:
                    message.isFreeTrialAccount = reader.bool();
                    break;
                case 14:
                    message.freeTrialExpiration = reader.uint32();
                    break;
                case 15:
                    message.isLowViolence = reader.bool();
                    break;
                case 16:
                    message.isAccountLockedDown = reader.bool();
                    break;
                case 17:
                    message.isCommunityBanned = reader.bool();
                    break;
                case 18:
                    message.isTradeBanned = reader.bool();
                    break;
                case 19:
                    message.tradeBanExpiration = reader.uint32();
                    break;
                case 20:
                    message.accountid = reader.uint32();
                    break;
                case 21:
                    message.suspensionEndTime = reader.uint32();
                    break;
                case 22:
                    message.currency = reader.string();
                    break;
                case 23:
                    message.steamLevel = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetAccountDetails_Response;
})());
exports.CMsgGCGetPersonaNames = ($root.CMsgGCGetPersonaNames = (() => {
    /**
     * Properties of a CMsgGCGetPersonaNames.
     * @exports ICMsgGCGetPersonaNames
     * @interface ICMsgGCGetPersonaNames
     * @property {Array.<number|Long>|null} [steamids] CMsgGCGetPersonaNames steamids
     */
    /**
     * Constructs a new CMsgGCGetPersonaNames.
     * @exports CMsgGCGetPersonaNames
     * @classdesc Represents a CMsgGCGetPersonaNames.
     * @implements ICMsgGCGetPersonaNames
     * @constructor
     * @param {ICMsgGCGetPersonaNames=} [properties] Properties to set
     */
    function CMsgGCGetPersonaNames(properties) {
        this.steamids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPersonaNames steamids.
     * @member {Array.<number|Long>} steamids
     * @memberof CMsgGCGetPersonaNames
     * @instance
     */
    CMsgGCGetPersonaNames.prototype.steamids = $util.emptyArray;
    /**
     * Decodes a CMsgGCGetPersonaNames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPersonaNames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPersonaNames} CMsgGCGetPersonaNames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPersonaNames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.steamids && message.steamids.length))
                        message.steamids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.steamids.push(reader.fixed64());
                    }
                    else
                        message.steamids.push(reader.fixed64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetPersonaNames;
})());
exports.CMsgGCGetPersonaNames_Response = ($root.CMsgGCGetPersonaNames_Response = (() => {
    /**
     * Properties of a CMsgGCGetPersonaNames_Response.
     * @exports ICMsgGCGetPersonaNames_Response
     * @interface ICMsgGCGetPersonaNames_Response
     * @property {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>|null} [succeededLookups] CMsgGCGetPersonaNames_Response succeededLookups
     * @property {Array.<number|Long>|null} [failedLookupSteamids] CMsgGCGetPersonaNames_Response failedLookupSteamids
     */
    /**
     * Constructs a new CMsgGCGetPersonaNames_Response.
     * @exports CMsgGCGetPersonaNames_Response
     * @classdesc Represents a CMsgGCGetPersonaNames_Response.
     * @implements ICMsgGCGetPersonaNames_Response
     * @constructor
     * @param {ICMsgGCGetPersonaNames_Response=} [properties] Properties to set
     */
    function CMsgGCGetPersonaNames_Response(properties) {
        this.succeededLookups = [];
        this.failedLookupSteamids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPersonaNames_Response succeededLookups.
     * @member {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>} succeededLookups
     * @memberof CMsgGCGetPersonaNames_Response
     * @instance
     */
    CMsgGCGetPersonaNames_Response.prototype.succeededLookups = $util.emptyArray;
    /**
     * CMsgGCGetPersonaNames_Response failedLookupSteamids.
     * @member {Array.<number|Long>} failedLookupSteamids
     * @memberof CMsgGCGetPersonaNames_Response
     * @instance
     */
    CMsgGCGetPersonaNames_Response.prototype.failedLookupSteamids =
        $util.emptyArray;
    /**
     * Decodes a CMsgGCGetPersonaNames_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPersonaNames_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPersonaNames_Response} CMsgGCGetPersonaNames_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPersonaNames_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.succeededLookups && message.succeededLookups.length))
                        message.succeededLookups = [];
                    message.succeededLookups.push($root.CMsgGCGetPersonaNames_Response.PersonaName.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.failedLookupSteamids &&
                        message.failedLookupSteamids.length))
                        message.failedLookupSteamids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.failedLookupSteamids.push(reader.fixed64());
                    }
                    else
                        message.failedLookupSteamids.push(reader.fixed64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCGetPersonaNames_Response.PersonaName = (function () {
        /**
         * Properties of a PersonaName.
         * @memberof CMsgGCGetPersonaNames_Response
         * @interface IPersonaName
         * @property {number|Long|null} [steamid] PersonaName steamid
         * @property {string|null} [personaName] PersonaName personaName
         */
        /**
         * Constructs a new PersonaName.
         * @memberof CMsgGCGetPersonaNames_Response
         * @classdesc Represents a PersonaName.
         * @implements IPersonaName
         * @constructor
         * @param {CMsgGCGetPersonaNames_Response.IPersonaName=} [properties] Properties to set
         */
        function PersonaName(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PersonaName steamid.
         * @member {number|Long} steamid
         * @memberof CMsgGCGetPersonaNames_Response.PersonaName
         * @instance
         */
        PersonaName.prototype.steamid = $util.Long
            ? $util.Long.fromBits(0, 0, false)
            : 0;
        /**
         * PersonaName personaName.
         * @member {string} personaName
         * @memberof CMsgGCGetPersonaNames_Response.PersonaName
         * @instance
         */
        PersonaName.prototype.personaName = "";
        /**
         * Decodes a PersonaName message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCGetPersonaNames_Response.PersonaName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCGetPersonaNames_Response.PersonaName} PersonaName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersonaName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames_Response.PersonaName();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.steamid = reader.fixed64();
                        break;
                    case 2:
                        message.personaName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return PersonaName;
    })();
    return CMsgGCGetPersonaNames_Response;
})());
exports.CMsgGCCheckFriendship = ($root.CMsgGCCheckFriendship = (() => {
    /**
     * Properties of a CMsgGCCheckFriendship.
     * @exports ICMsgGCCheckFriendship
     * @interface ICMsgGCCheckFriendship
     * @property {number|Long|null} [steamidLeft] CMsgGCCheckFriendship steamidLeft
     * @property {number|Long|null} [steamidRight] CMsgGCCheckFriendship steamidRight
     */
    /**
     * Constructs a new CMsgGCCheckFriendship.
     * @exports CMsgGCCheckFriendship
     * @classdesc Represents a CMsgGCCheckFriendship.
     * @implements ICMsgGCCheckFriendship
     * @constructor
     * @param {ICMsgGCCheckFriendship=} [properties] Properties to set
     */
    function CMsgGCCheckFriendship(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCheckFriendship steamidLeft.
     * @member {number|Long} steamidLeft
     * @memberof CMsgGCCheckFriendship
     * @instance
     */
    CMsgGCCheckFriendship.prototype.steamidLeft = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgGCCheckFriendship steamidRight.
     * @member {number|Long} steamidRight
     * @memberof CMsgGCCheckFriendship
     * @instance
     */
    CMsgGCCheckFriendship.prototype.steamidRight = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * Decodes a CMsgGCCheckFriendship message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCheckFriendship
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCheckFriendship} CMsgGCCheckFriendship
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCheckFriendship.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCheckFriendship();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamidLeft = reader.fixed64();
                    break;
                case 2:
                    message.steamidRight = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCheckFriendship;
})());
exports.CMsgGCCheckFriendship_Response = ($root.CMsgGCCheckFriendship_Response = (() => {
    /**
     * Properties of a CMsgGCCheckFriendship_Response.
     * @exports ICMsgGCCheckFriendship_Response
     * @interface ICMsgGCCheckFriendship_Response
     * @property {boolean|null} [success] CMsgGCCheckFriendship_Response success
     * @property {boolean|null} [foundFriendship] CMsgGCCheckFriendship_Response foundFriendship
     */
    /**
     * Constructs a new CMsgGCCheckFriendship_Response.
     * @exports CMsgGCCheckFriendship_Response
     * @classdesc Represents a CMsgGCCheckFriendship_Response.
     * @implements ICMsgGCCheckFriendship_Response
     * @constructor
     * @param {ICMsgGCCheckFriendship_Response=} [properties] Properties to set
     */
    function CMsgGCCheckFriendship_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCheckFriendship_Response success.
     * @member {boolean} success
     * @memberof CMsgGCCheckFriendship_Response
     * @instance
     */
    CMsgGCCheckFriendship_Response.prototype.success = false;
    /**
     * CMsgGCCheckFriendship_Response foundFriendship.
     * @member {boolean} foundFriendship
     * @memberof CMsgGCCheckFriendship_Response
     * @instance
     */
    CMsgGCCheckFriendship_Response.prototype.foundFriendship = false;
    /**
     * Decodes a CMsgGCCheckFriendship_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCheckFriendship_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCheckFriendship_Response} CMsgGCCheckFriendship_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCheckFriendship_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCheckFriendship_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.foundFriendship = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCheckFriendship_Response;
})());
exports.CMsgGCMsgMasterSetDirectory = ($root.CMsgGCMsgMasterSetDirectory = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetDirectory.
     * @exports ICMsgGCMsgMasterSetDirectory
     * @interface ICMsgGCMsgMasterSetDirectory
     * @property {number|null} [masterDirIndex] CMsgGCMsgMasterSetDirectory masterDirIndex
     * @property {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>|null} [dir] CMsgGCMsgMasterSetDirectory dir
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetDirectory.
     * @exports CMsgGCMsgMasterSetDirectory
     * @classdesc Represents a CMsgGCMsgMasterSetDirectory.
     * @implements ICMsgGCMsgMasterSetDirectory
     * @constructor
     * @param {ICMsgGCMsgMasterSetDirectory=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetDirectory(properties) {
        this.dir = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetDirectory masterDirIndex.
     * @member {number} masterDirIndex
     * @memberof CMsgGCMsgMasterSetDirectory
     * @instance
     */
    CMsgGCMsgMasterSetDirectory.prototype.masterDirIndex = 0;
    /**
     * CMsgGCMsgMasterSetDirectory dir.
     * @member {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>} dir
     * @memberof CMsgGCMsgMasterSetDirectory
     * @instance
     */
    CMsgGCMsgMasterSetDirectory.prototype.dir = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgMasterSetDirectory message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetDirectory
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetDirectory} CMsgGCMsgMasterSetDirectory
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetDirectory.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.masterDirIndex = reader.uint32();
                    break;
                case 2:
                    if (!(message.dir && message.dir.length))
                        message.dir = [];
                    message.dir.push($root.CMsgGCMsgMasterSetDirectory.SubGC.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgMasterSetDirectory.SubGC = (function () {
        /**
         * Properties of a SubGC.
         * @memberof CMsgGCMsgMasterSetDirectory
         * @interface ISubGC
         * @property {number|null} [dirIndex] SubGC dirIndex
         * @property {string|null} [name] SubGC name
         * @property {string|null} [box] SubGC box
         * @property {string|null} [commandLine] SubGC commandLine
         * @property {string|null} [gcBinary] SubGC gcBinary
         */
        /**
         * Constructs a new SubGC.
         * @memberof CMsgGCMsgMasterSetDirectory
         * @classdesc Represents a SubGC.
         * @implements ISubGC
         * @constructor
         * @param {CMsgGCMsgMasterSetDirectory.ISubGC=} [properties] Properties to set
         */
        function SubGC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SubGC dirIndex.
         * @member {number} dirIndex
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.dirIndex = 0;
        /**
         * SubGC name.
         * @member {string} name
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.name = "";
        /**
         * SubGC box.
         * @member {string} box
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.box = "";
        /**
         * SubGC commandLine.
         * @member {string} commandLine
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.commandLine = "";
        /**
         * SubGC gcBinary.
         * @member {string} gcBinary
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.gcBinary = "";
        /**
         * Decodes a SubGC message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgMasterSetDirectory.SubGC} SubGC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubGC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory.SubGC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.dirIndex = reader.uint32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.box = reader.string();
                        break;
                    case 4:
                        message.commandLine = reader.string();
                        break;
                    case 5:
                        message.gcBinary = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return SubGC;
    })();
    return CMsgGCMsgMasterSetDirectory;
})());
exports.CMsgGCMsgMasterSetDirectory_Response = ($root.CMsgGCMsgMasterSetDirectory_Response = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetDirectory_Response.
     * @exports ICMsgGCMsgMasterSetDirectory_Response
     * @interface ICMsgGCMsgMasterSetDirectory_Response
     * @property {number|null} [eresult] CMsgGCMsgMasterSetDirectory_Response eresult
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetDirectory_Response.
     * @exports CMsgGCMsgMasterSetDirectory_Response
     * @classdesc Represents a CMsgGCMsgMasterSetDirectory_Response.
     * @implements ICMsgGCMsgMasterSetDirectory_Response
     * @constructor
     * @param {ICMsgGCMsgMasterSetDirectory_Response=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetDirectory_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetDirectory_Response eresult.
     * @member {number} eresult
     * @memberof CMsgGCMsgMasterSetDirectory_Response
     * @instance
     */
    CMsgGCMsgMasterSetDirectory_Response.prototype.eresult = 2;
    /**
     * Decodes a CMsgGCMsgMasterSetDirectory_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetDirectory_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetDirectory_Response} CMsgGCMsgMasterSetDirectory_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetDirectory_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgMasterSetDirectory_Response;
})());
exports.CMsgGCMsgWebAPIJobRequestForwardResponse = ($root.CMsgGCMsgWebAPIJobRequestForwardResponse = (() => {
    /**
     * Properties of a CMsgGCMsgWebAPIJobRequestForwardResponse.
     * @exports ICMsgGCMsgWebAPIJobRequestForwardResponse
     * @interface ICMsgGCMsgWebAPIJobRequestForwardResponse
     * @property {number|null} [dirIndex] CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex
     */
    /**
     * Constructs a new CMsgGCMsgWebAPIJobRequestForwardResponse.
     * @exports CMsgGCMsgWebAPIJobRequestForwardResponse
     * @classdesc Represents a CMsgGCMsgWebAPIJobRequestForwardResponse.
     * @implements ICMsgGCMsgWebAPIJobRequestForwardResponse
     * @constructor
     * @param {ICMsgGCMsgWebAPIJobRequestForwardResponse=} [properties] Properties to set
     */
    function CMsgGCMsgWebAPIJobRequestForwardResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex.
     * @member {number} dirIndex
     * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse
     * @instance
     */
    CMsgGCMsgWebAPIJobRequestForwardResponse.prototype.dirIndex = 0;
    /**
     * Decodes a CMsgGCMsgWebAPIJobRequestForwardResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgWebAPIJobRequestForwardResponse} CMsgGCMsgWebAPIJobRequestForwardResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgWebAPIJobRequestForwardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgWebAPIJobRequestForwardResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dirIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgWebAPIJobRequestForwardResponse;
})());
exports.CGCSystemMsg_GetPurchaseTrust_Request = ($root.CGCSystemMsg_GetPurchaseTrust_Request = (() => {
    /**
     * Properties of a CGCSystemMsg_GetPurchaseTrust_Request.
     * @exports ICGCSystemMsg_GetPurchaseTrust_Request
     * @interface ICGCSystemMsg_GetPurchaseTrust_Request
     * @property {number|Long|null} [steamid] CGCSystemMsg_GetPurchaseTrust_Request steamid
     */
    /**
     * Constructs a new CGCSystemMsg_GetPurchaseTrust_Request.
     * @exports CGCSystemMsg_GetPurchaseTrust_Request
     * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Request.
     * @implements ICGCSystemMsg_GetPurchaseTrust_Request
     * @constructor
     * @param {ICGCSystemMsg_GetPurchaseTrust_Request=} [properties] Properties to set
     */
    function CGCSystemMsg_GetPurchaseTrust_Request(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetPurchaseTrust_Request steamid.
     * @member {number|Long} steamid
     * @memberof CGCSystemMsg_GetPurchaseTrust_Request
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Request.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * Decodes a CGCSystemMsg_GetPurchaseTrust_Request message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetPurchaseTrust_Request
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetPurchaseTrust_Request} CGCSystemMsg_GetPurchaseTrust_Request
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetPurchaseTrust_Request.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetPurchaseTrust_Request();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetPurchaseTrust_Request;
})());
exports.CGCSystemMsg_GetPurchaseTrust_Response = ($root.CGCSystemMsg_GetPurchaseTrust_Response = (() => {
    /**
     * Properties of a CGCSystemMsg_GetPurchaseTrust_Response.
     * @exports ICGCSystemMsg_GetPurchaseTrust_Response
     * @interface ICGCSystemMsg_GetPurchaseTrust_Response
     * @property {boolean|null} [hasPriorPurchaseHistory] CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory
     * @property {boolean|null} [hasNoRecentPasswordResets] CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets
     * @property {boolean|null} [isWalletCashTrusted] CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted
     * @property {number|null} [timeAllTrusted] CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted
     */
    /**
     * Constructs a new CGCSystemMsg_GetPurchaseTrust_Response.
     * @exports CGCSystemMsg_GetPurchaseTrust_Response
     * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Response.
     * @implements ICGCSystemMsg_GetPurchaseTrust_Response
     * @constructor
     * @param {ICGCSystemMsg_GetPurchaseTrust_Response=} [properties] Properties to set
     */
    function CGCSystemMsg_GetPurchaseTrust_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory.
     * @member {boolean} hasPriorPurchaseHistory
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasPriorPurchaseHistory = false;
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets.
     * @member {boolean} hasNoRecentPasswordResets
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasNoRecentPasswordResets = false;
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted.
     * @member {boolean} isWalletCashTrusted
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.isWalletCashTrusted = false;
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted.
     * @member {number} timeAllTrusted
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.timeAllTrusted = 0;
    /**
     * Decodes a CGCSystemMsg_GetPurchaseTrust_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetPurchaseTrust_Response} CGCSystemMsg_GetPurchaseTrust_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetPurchaseTrust_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetPurchaseTrust_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hasPriorPurchaseHistory = reader.bool();
                    break;
                case 2:
                    message.hasNoRecentPasswordResets = reader.bool();
                    break;
                case 3:
                    message.isWalletCashTrusted = reader.bool();
                    break;
                case 4:
                    message.timeAllTrusted = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetPurchaseTrust_Response;
})());
exports.CMsgGCHAccountVacStatusChange = ($root.CMsgGCHAccountVacStatusChange = (() => {
    /**
     * Properties of a CMsgGCHAccountVacStatusChange.
     * @exports ICMsgGCHAccountVacStatusChange
     * @interface ICMsgGCHAccountVacStatusChange
     * @property {number|Long|null} [steamId] CMsgGCHAccountVacStatusChange steamId
     * @property {number|null} [appId] CMsgGCHAccountVacStatusChange appId
     * @property {number|null} [rtimeVacbanStarts] CMsgGCHAccountVacStatusChange rtimeVacbanStarts
     * @property {boolean|null} [isBannedNow] CMsgGCHAccountVacStatusChange isBannedNow
     * @property {boolean|null} [isBannedFuture] CMsgGCHAccountVacStatusChange isBannedFuture
     */
    /**
     * Constructs a new CMsgGCHAccountVacStatusChange.
     * @exports CMsgGCHAccountVacStatusChange
     * @classdesc Represents a CMsgGCHAccountVacStatusChange.
     * @implements ICMsgGCHAccountVacStatusChange
     * @constructor
     * @param {ICMsgGCHAccountVacStatusChange=} [properties] Properties to set
     */
    function CMsgGCHAccountVacStatusChange(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCHAccountVacStatusChange steamId.
     * @member {number|Long} steamId
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.steamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgGCHAccountVacStatusChange appId.
     * @member {number} appId
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.appId = 0;
    /**
     * CMsgGCHAccountVacStatusChange rtimeVacbanStarts.
     * @member {number} rtimeVacbanStarts
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.rtimeVacbanStarts = 0;
    /**
     * CMsgGCHAccountVacStatusChange isBannedNow.
     * @member {boolean} isBannedNow
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.isBannedNow = false;
    /**
     * CMsgGCHAccountVacStatusChange isBannedFuture.
     * @member {boolean} isBannedFuture
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.isBannedFuture = false;
    /**
     * Decodes a CMsgGCHAccountVacStatusChange message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCHAccountVacStatusChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCHAccountVacStatusChange} CMsgGCHAccountVacStatusChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCHAccountVacStatusChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHAccountVacStatusChange();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.appId = reader.uint32();
                    break;
                case 3:
                    message.rtimeVacbanStarts = reader.uint32();
                    break;
                case 4:
                    message.isBannedNow = reader.bool();
                    break;
                case 5:
                    message.isBannedFuture = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCHAccountVacStatusChange;
})());
exports.CMsgGCGetPartnerAccountLink = ($root.CMsgGCGetPartnerAccountLink = (() => {
    /**
     * Properties of a CMsgGCGetPartnerAccountLink.
     * @exports ICMsgGCGetPartnerAccountLink
     * @interface ICMsgGCGetPartnerAccountLink
     * @property {number|Long|null} [steamid] CMsgGCGetPartnerAccountLink steamid
     */
    /**
     * Constructs a new CMsgGCGetPartnerAccountLink.
     * @exports CMsgGCGetPartnerAccountLink
     * @classdesc Represents a CMsgGCGetPartnerAccountLink.
     * @implements ICMsgGCGetPartnerAccountLink
     * @constructor
     * @param {ICMsgGCGetPartnerAccountLink=} [properties] Properties to set
     */
    function CMsgGCGetPartnerAccountLink(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPartnerAccountLink steamid.
     * @member {number|Long} steamid
     * @memberof CMsgGCGetPartnerAccountLink
     * @instance
     */
    CMsgGCGetPartnerAccountLink.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * Decodes a CMsgGCGetPartnerAccountLink message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPartnerAccountLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPartnerAccountLink} CMsgGCGetPartnerAccountLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPartnerAccountLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPartnerAccountLink();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetPartnerAccountLink;
})());
exports.CMsgGCGetPartnerAccountLink_Response = ($root.CMsgGCGetPartnerAccountLink_Response = (() => {
    /**
     * Properties of a CMsgGCGetPartnerAccountLink_Response.
     * @exports ICMsgGCGetPartnerAccountLink_Response
     * @interface ICMsgGCGetPartnerAccountLink_Response
     * @property {number|null} [pwid] CMsgGCGetPartnerAccountLink_Response pwid
     * @property {number|null} [nexonid] CMsgGCGetPartnerAccountLink_Response nexonid
     */
    /**
     * Constructs a new CMsgGCGetPartnerAccountLink_Response.
     * @exports CMsgGCGetPartnerAccountLink_Response
     * @classdesc Represents a CMsgGCGetPartnerAccountLink_Response.
     * @implements ICMsgGCGetPartnerAccountLink_Response
     * @constructor
     * @param {ICMsgGCGetPartnerAccountLink_Response=} [properties] Properties to set
     */
    function CMsgGCGetPartnerAccountLink_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPartnerAccountLink_Response pwid.
     * @member {number} pwid
     * @memberof CMsgGCGetPartnerAccountLink_Response
     * @instance
     */
    CMsgGCGetPartnerAccountLink_Response.prototype.pwid = 0;
    /**
     * CMsgGCGetPartnerAccountLink_Response nexonid.
     * @member {number} nexonid
     * @memberof CMsgGCGetPartnerAccountLink_Response
     * @instance
     */
    CMsgGCGetPartnerAccountLink_Response.prototype.nexonid = 0;
    /**
     * Decodes a CMsgGCGetPartnerAccountLink_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPartnerAccountLink_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPartnerAccountLink_Response} CMsgGCGetPartnerAccountLink_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPartnerAccountLink_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPartnerAccountLink_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pwid = reader.uint32();
                    break;
                case 2:
                    message.nexonid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetPartnerAccountLink_Response;
})());
exports.CMsgGCRoutingInfo = ($root.CMsgGCRoutingInfo = (() => {
    /**
     * Properties of a CMsgGCRoutingInfo.
     * @exports ICMsgGCRoutingInfo
     * @interface ICMsgGCRoutingInfo
     * @property {Array.<number>|null} [dirIndex] CMsgGCRoutingInfo dirIndex
     * @property {CMsgGCRoutingInfo.RoutingMethod|null} [method] CMsgGCRoutingInfo method
     * @property {CMsgGCRoutingInfo.RoutingMethod|null} [fallback] CMsgGCRoutingInfo fallback
     * @property {number|null} [protobufField] CMsgGCRoutingInfo protobufField
     * @property {string|null} [webapiParam] CMsgGCRoutingInfo webapiParam
     */
    /**
     * Constructs a new CMsgGCRoutingInfo.
     * @exports CMsgGCRoutingInfo
     * @classdesc Represents a CMsgGCRoutingInfo.
     * @implements ICMsgGCRoutingInfo
     * @constructor
     * @param {ICMsgGCRoutingInfo=} [properties] Properties to set
     */
    function CMsgGCRoutingInfo(properties) {
        this.dirIndex = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCRoutingInfo dirIndex.
     * @member {Array.<number>} dirIndex
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.dirIndex = $util.emptyArray;
    /**
     * CMsgGCRoutingInfo method.
     * @member {CMsgGCRoutingInfo.RoutingMethod} method
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.method = 0;
    /**
     * CMsgGCRoutingInfo fallback.
     * @member {CMsgGCRoutingInfo.RoutingMethod} fallback
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.fallback = 1;
    /**
     * CMsgGCRoutingInfo protobufField.
     * @member {number} protobufField
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.protobufField = 0;
    /**
     * CMsgGCRoutingInfo webapiParam.
     * @member {string} webapiParam
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.webapiParam = "";
    /**
     * Decodes a CMsgGCRoutingInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCRoutingInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCRoutingInfo} CMsgGCRoutingInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCRoutingInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCRoutingInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.dirIndex && message.dirIndex.length))
                        message.dirIndex = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dirIndex.push(reader.uint32());
                    }
                    else
                        message.dirIndex.push(reader.uint32());
                    break;
                case 2:
                    message.method = reader.int32();
                    break;
                case 3:
                    message.fallback = reader.int32();
                    break;
                case 4:
                    message.protobufField = reader.uint32();
                    break;
                case 5:
                    message.webapiParam = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    /**
     * RoutingMethod enum.
     * @name CMsgGCRoutingInfo.RoutingMethod
     * @enum {string}
     * @property {number} RANDOM=0 RANDOM value
     * @property {number} DISCARD=1 DISCARD value
     * @property {number} CLIENT_STEAMID=2 CLIENT_STEAMID value
     * @property {number} PROTOBUF_FIELD_UINT64=3 PROTOBUF_FIELD_UINT64 value
     * @property {number} WEBAPI_PARAM_UINT64=4 WEBAPI_PARAM_UINT64 value
     */
    CMsgGCRoutingInfo.RoutingMethod = (function () {
        const valuesById = {}, values = Object.create(valuesById);
        values[(valuesById[0] = "RANDOM")] = 0;
        values[(valuesById[1] = "DISCARD")] = 1;
        values[(valuesById[2] = "CLIENT_STEAMID")] = 2;
        values[(valuesById[3] = "PROTOBUF_FIELD_UINT64")] = 3;
        values[(valuesById[4] = "WEBAPI_PARAM_UINT64")] = 4;
        return values;
    })();
    return CMsgGCRoutingInfo;
})());
exports.CMsgGCMsgMasterSetWebAPIRouting = ($root.CMsgGCMsgMasterSetWebAPIRouting = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetWebAPIRouting.
     * @exports ICMsgGCMsgMasterSetWebAPIRouting
     * @interface ICMsgGCMsgMasterSetWebAPIRouting
     * @property {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetWebAPIRouting entries
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetWebAPIRouting.
     * @exports CMsgGCMsgMasterSetWebAPIRouting
     * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting.
     * @implements ICMsgGCMsgMasterSetWebAPIRouting
     * @constructor
     * @param {ICMsgGCMsgMasterSetWebAPIRouting=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetWebAPIRouting(properties) {
        this.entries = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetWebAPIRouting entries.
     * @member {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>} entries
     * @memberof CMsgGCMsgMasterSetWebAPIRouting
     * @instance
     */
    CMsgGCMsgMasterSetWebAPIRouting.prototype.entries = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgMasterSetWebAPIRouting message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetWebAPIRouting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetWebAPIRouting} CMsgGCMsgMasterSetWebAPIRouting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetWebAPIRouting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.CMsgGCMsgMasterSetWebAPIRouting.Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgMasterSetWebAPIRouting.Entry = (function () {
        /**
         * Properties of an Entry.
         * @memberof CMsgGCMsgMasterSetWebAPIRouting
         * @interface IEntry
         * @property {string|null} [interfaceName] Entry interfaceName
         * @property {string|null} [methodName] Entry methodName
         * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing
         */
        /**
         * Constructs a new Entry.
         * @memberof CMsgGCMsgMasterSetWebAPIRouting
         * @classdesc Represents an Entry.
         * @implements IEntry
         * @constructor
         * @param {CMsgGCMsgMasterSetWebAPIRouting.IEntry=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Entry interfaceName.
         * @member {string} interfaceName
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @instance
         */
        Entry.prototype.interfaceName = "";
        /**
         * Entry methodName.
         * @member {string} methodName
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @instance
         */
        Entry.prototype.methodName = "";
        /**
         * Entry routing.
         * @member {ICMsgGCRoutingInfo|null|undefined} routing
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @instance
         */
        Entry.prototype.routing = null;
        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgMasterSetWebAPIRouting.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.interfaceName = reader.string();
                        break;
                    case 2:
                        message.methodName = reader.string();
                        break;
                    case 3:
                        message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Entry;
    })();
    return CMsgGCMsgMasterSetWebAPIRouting;
})());
exports.CMsgGCMsgMasterSetClientMsgRouting = ($root.CMsgGCMsgMasterSetClientMsgRouting = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetClientMsgRouting.
     * @exports ICMsgGCMsgMasterSetClientMsgRouting
     * @interface ICMsgGCMsgMasterSetClientMsgRouting
     * @property {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetClientMsgRouting entries
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetClientMsgRouting.
     * @exports CMsgGCMsgMasterSetClientMsgRouting
     * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting.
     * @implements ICMsgGCMsgMasterSetClientMsgRouting
     * @constructor
     * @param {ICMsgGCMsgMasterSetClientMsgRouting=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetClientMsgRouting(properties) {
        this.entries = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetClientMsgRouting entries.
     * @member {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>} entries
     * @memberof CMsgGCMsgMasterSetClientMsgRouting
     * @instance
     */
    CMsgGCMsgMasterSetClientMsgRouting.prototype.entries = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgMasterSetClientMsgRouting message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetClientMsgRouting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetClientMsgRouting} CMsgGCMsgMasterSetClientMsgRouting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetClientMsgRouting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.CMsgGCMsgMasterSetClientMsgRouting.Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgMasterSetClientMsgRouting.Entry = (function () {
        /**
         * Properties of an Entry.
         * @memberof CMsgGCMsgMasterSetClientMsgRouting
         * @interface IEntry
         * @property {number|null} [msgType] Entry msgType
         * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing
         */
        /**
         * Constructs a new Entry.
         * @memberof CMsgGCMsgMasterSetClientMsgRouting
         * @classdesc Represents an Entry.
         * @implements IEntry
         * @constructor
         * @param {CMsgGCMsgMasterSetClientMsgRouting.IEntry=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Entry msgType.
         * @member {number} msgType
         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry
         * @instance
         */
        Entry.prototype.msgType = 0;
        /**
         * Entry routing.
         * @member {ICMsgGCRoutingInfo|null|undefined} routing
         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry
         * @instance
         */
        Entry.prototype.routing = null;
        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgMasterSetClientMsgRouting.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.msgType = reader.uint32();
                        break;
                    case 2:
                        message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Entry;
    })();
    return CMsgGCMsgMasterSetClientMsgRouting;
})());
exports.CMsgGCMsgMasterSetWebAPIRouting_Response = ($root.CMsgGCMsgMasterSetWebAPIRouting_Response = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetWebAPIRouting_Response.
     * @exports ICMsgGCMsgMasterSetWebAPIRouting_Response
     * @interface ICMsgGCMsgMasterSetWebAPIRouting_Response
     * @property {number|null} [eresult] CMsgGCMsgMasterSetWebAPIRouting_Response eresult
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetWebAPIRouting_Response.
     * @exports CMsgGCMsgMasterSetWebAPIRouting_Response
     * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting_Response.
     * @implements ICMsgGCMsgMasterSetWebAPIRouting_Response
     * @constructor
     * @param {ICMsgGCMsgMasterSetWebAPIRouting_Response=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetWebAPIRouting_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetWebAPIRouting_Response eresult.
     * @member {number} eresult
     * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response
     * @instance
     */
    CMsgGCMsgMasterSetWebAPIRouting_Response.prototype.eresult = 2;
    /**
     * Decodes a CMsgGCMsgMasterSetWebAPIRouting_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetWebAPIRouting_Response} CMsgGCMsgMasterSetWebAPIRouting_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetWebAPIRouting_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgMasterSetWebAPIRouting_Response;
})());
exports.CMsgGCMsgMasterSetClientMsgRouting_Response = ($root.CMsgGCMsgMasterSetClientMsgRouting_Response = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetClientMsgRouting_Response.
     * @exports ICMsgGCMsgMasterSetClientMsgRouting_Response
     * @interface ICMsgGCMsgMasterSetClientMsgRouting_Response
     * @property {number|null} [eresult] CMsgGCMsgMasterSetClientMsgRouting_Response eresult
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetClientMsgRouting_Response.
     * @exports CMsgGCMsgMasterSetClientMsgRouting_Response
     * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting_Response.
     * @implements ICMsgGCMsgMasterSetClientMsgRouting_Response
     * @constructor
     * @param {ICMsgGCMsgMasterSetClientMsgRouting_Response=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetClientMsgRouting_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetClientMsgRouting_Response eresult.
     * @member {number} eresult
     * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response
     * @instance
     */
    CMsgGCMsgMasterSetClientMsgRouting_Response.prototype.eresult = 2;
    /**
     * Decodes a CMsgGCMsgMasterSetClientMsgRouting_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetClientMsgRouting_Response} CMsgGCMsgMasterSetClientMsgRouting_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetClientMsgRouting_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgMasterSetClientMsgRouting_Response;
})());
exports.CMsgGCMsgSetOptions = ($root.CMsgGCMsgSetOptions = (() => {
    /**
     * Properties of a CMsgGCMsgSetOptions.
     * @exports ICMsgGCMsgSetOptions
     * @interface ICMsgGCMsgSetOptions
     * @property {Array.<CMsgGCMsgSetOptions.Option>|null} [options] CMsgGCMsgSetOptions options
     * @property {Array.<CMsgGCMsgSetOptions.IMessageRange>|null} [clientMsgRanges] CMsgGCMsgSetOptions clientMsgRanges
     */
    /**
     * Constructs a new CMsgGCMsgSetOptions.
     * @exports CMsgGCMsgSetOptions
     * @classdesc Represents a CMsgGCMsgSetOptions.
     * @implements ICMsgGCMsgSetOptions
     * @constructor
     * @param {ICMsgGCMsgSetOptions=} [properties] Properties to set
     */
    function CMsgGCMsgSetOptions(properties) {
        this.options = [];
        this.clientMsgRanges = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgSetOptions options.
     * @member {Array.<CMsgGCMsgSetOptions.Option>} options
     * @memberof CMsgGCMsgSetOptions
     * @instance
     */
    CMsgGCMsgSetOptions.prototype.options = $util.emptyArray;
    /**
     * CMsgGCMsgSetOptions clientMsgRanges.
     * @member {Array.<CMsgGCMsgSetOptions.IMessageRange>} clientMsgRanges
     * @memberof CMsgGCMsgSetOptions
     * @instance
     */
    CMsgGCMsgSetOptions.prototype.clientMsgRanges = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgSetOptions message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgSetOptions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgSetOptions} CMsgGCMsgSetOptions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgSetOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgSetOptions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.options.push(reader.int32());
                    }
                    else
                        message.options.push(reader.int32());
                    break;
                case 2:
                    if (!(message.clientMsgRanges && message.clientMsgRanges.length))
                        message.clientMsgRanges = [];
                    message.clientMsgRanges.push($root.CMsgGCMsgSetOptions.MessageRange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgSetOptions.MessageRange = (function () {
        /**
         * Properties of a MessageRange.
         * @memberof CMsgGCMsgSetOptions
         * @interface IMessageRange
         * @property {number} low MessageRange low
         * @property {number} high MessageRange high
         */
        /**
         * Constructs a new MessageRange.
         * @memberof CMsgGCMsgSetOptions
         * @classdesc Represents a MessageRange.
         * @implements IMessageRange
         * @constructor
         * @param {CMsgGCMsgSetOptions.IMessageRange=} [properties] Properties to set
         */
        function MessageRange(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MessageRange low.
         * @member {number} low
         * @memberof CMsgGCMsgSetOptions.MessageRange
         * @instance
         */
        MessageRange.prototype.low = 0;
        /**
         * MessageRange high.
         * @member {number} high
         * @memberof CMsgGCMsgSetOptions.MessageRange
         * @instance
         */
        MessageRange.prototype.high = 0;
        /**
         * Decodes a MessageRange message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgSetOptions.MessageRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgSetOptions.MessageRange} MessageRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgSetOptions.MessageRange();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.low = reader.uint32();
                        break;
                    case 2:
                        message.high = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            if (!message.hasOwnProperty("low"))
                throw $util.ProtocolError("missing required 'low'", {
                    instance: message
                });
            if (!message.hasOwnProperty("high"))
                throw $util.ProtocolError("missing required 'high'", {
                    instance: message
                });
            return message;
        };
        return MessageRange;
    })();
    /**
     * Option enum.
     * @name CMsgGCMsgSetOptions.Option
     * @enum {string}
     * @property {number} NOTIFY_USER_SESSIONS=0 NOTIFY_USER_SESSIONS value
     * @property {number} NOTIFY_SERVER_SESSIONS=1 NOTIFY_SERVER_SESSIONS value
     * @property {number} NOTIFY_ACHIEVEMENTS=2 NOTIFY_ACHIEVEMENTS value
     * @property {number} NOTIFY_VAC_ACTION=3 NOTIFY_VAC_ACTION value
     */
    CMsgGCMsgSetOptions.Option = (function () {
        const valuesById = {}, values = Object.create(valuesById);
        values[(valuesById[0] = "NOTIFY_USER_SESSIONS")] = 0;
        values[(valuesById[1] = "NOTIFY_SERVER_SESSIONS")] = 1;
        values[(valuesById[2] = "NOTIFY_ACHIEVEMENTS")] = 2;
        values[(valuesById[3] = "NOTIFY_VAC_ACTION")] = 3;
        return values;
    })();
    return CMsgGCMsgSetOptions;
})());
exports.CMsgGCHUpdateSession = ($root.CMsgGCHUpdateSession = (() => {
    /**
     * Properties of a CMsgGCHUpdateSession.
     * @exports ICMsgGCHUpdateSession
     * @interface ICMsgGCHUpdateSession
     * @property {number|Long|null} [steamId] CMsgGCHUpdateSession steamId
     * @property {number|null} [appId] CMsgGCHUpdateSession appId
     * @property {boolean|null} [online] CMsgGCHUpdateSession online
     * @property {number|Long|null} [serverSteamId] CMsgGCHUpdateSession serverSteamId
     * @property {number|null} [serverAddr] CMsgGCHUpdateSession serverAddr
     * @property {number|null} [serverPort] CMsgGCHUpdateSession serverPort
     * @property {number|null} [osType] CMsgGCHUpdateSession osType
     * @property {number|null} [clientAddr] CMsgGCHUpdateSession clientAddr
     * @property {Array.<CMsgGCHUpdateSession.IExtraField>|null} [extraFields] CMsgGCHUpdateSession extraFields
     */
    /**
     * Constructs a new CMsgGCHUpdateSession.
     * @exports CMsgGCHUpdateSession
     * @classdesc Represents a CMsgGCHUpdateSession.
     * @implements ICMsgGCHUpdateSession
     * @constructor
     * @param {ICMsgGCHUpdateSession=} [properties] Properties to set
     */
    function CMsgGCHUpdateSession(properties) {
        this.extraFields = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCHUpdateSession steamId.
     * @member {number|Long} steamId
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.steamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgGCHUpdateSession appId.
     * @member {number} appId
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.appId = 0;
    /**
     * CMsgGCHUpdateSession online.
     * @member {boolean} online
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.online = false;
    /**
     * CMsgGCHUpdateSession serverSteamId.
     * @member {number|Long} serverSteamId
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.serverSteamId = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgGCHUpdateSession serverAddr.
     * @member {number} serverAddr
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.serverAddr = 0;
    /**
     * CMsgGCHUpdateSession serverPort.
     * @member {number} serverPort
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.serverPort = 0;
    /**
     * CMsgGCHUpdateSession osType.
     * @member {number} osType
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.osType = 0;
    /**
     * CMsgGCHUpdateSession clientAddr.
     * @member {number} clientAddr
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.clientAddr = 0;
    /**
     * CMsgGCHUpdateSession extraFields.
     * @member {Array.<CMsgGCHUpdateSession.IExtraField>} extraFields
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.extraFields = $util.emptyArray;
    /**
     * Decodes a CMsgGCHUpdateSession message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCHUpdateSession
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCHUpdateSession} CMsgGCHUpdateSession
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCHUpdateSession.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHUpdateSession();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.appId = reader.uint32();
                    break;
                case 3:
                    message.online = reader.bool();
                    break;
                case 4:
                    message.serverSteamId = reader.fixed64();
                    break;
                case 5:
                    message.serverAddr = reader.uint32();
                    break;
                case 6:
                    message.serverPort = reader.uint32();
                    break;
                case 7:
                    message.osType = reader.uint32();
                    break;
                case 8:
                    message.clientAddr = reader.uint32();
                    break;
                case 9:
                    if (!(message.extraFields && message.extraFields.length))
                        message.extraFields = [];
                    message.extraFields.push($root.CMsgGCHUpdateSession.ExtraField.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCHUpdateSession.ExtraField = (function () {
        /**
         * Properties of an ExtraField.
         * @memberof CMsgGCHUpdateSession
         * @interface IExtraField
         * @property {string|null} [name] ExtraField name
         * @property {string|null} [value] ExtraField value
         */
        /**
         * Constructs a new ExtraField.
         * @memberof CMsgGCHUpdateSession
         * @classdesc Represents an ExtraField.
         * @implements IExtraField
         * @constructor
         * @param {CMsgGCHUpdateSession.IExtraField=} [properties] Properties to set
         */
        function ExtraField(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ExtraField name.
         * @member {string} name
         * @memberof CMsgGCHUpdateSession.ExtraField
         * @instance
         */
        ExtraField.prototype.name = "";
        /**
         * ExtraField value.
         * @member {string} value
         * @memberof CMsgGCHUpdateSession.ExtraField
         * @instance
         */
        ExtraField.prototype.value = "";
        /**
         * Decodes an ExtraField message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCHUpdateSession.ExtraField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCHUpdateSession.ExtraField} ExtraField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtraField.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHUpdateSession.ExtraField();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ExtraField;
    })();
    return CMsgGCHUpdateSession;
})());
exports.CMsgNotificationOfSuspiciousActivity = ($root.CMsgNotificationOfSuspiciousActivity = (() => {
    /**
     * Properties of a CMsgNotificationOfSuspiciousActivity.
     * @exports ICMsgNotificationOfSuspiciousActivity
     * @interface ICMsgNotificationOfSuspiciousActivity
     * @property {number|Long|null} [steamid] CMsgNotificationOfSuspiciousActivity steamid
     * @property {number|null} [appid] CMsgNotificationOfSuspiciousActivity appid
     * @property {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null} [multipleInstances] CMsgNotificationOfSuspiciousActivity multipleInstances
     */
    /**
     * Constructs a new CMsgNotificationOfSuspiciousActivity.
     * @exports CMsgNotificationOfSuspiciousActivity
     * @classdesc Represents a CMsgNotificationOfSuspiciousActivity.
     * @implements ICMsgNotificationOfSuspiciousActivity
     * @constructor
     * @param {ICMsgNotificationOfSuspiciousActivity=} [properties] Properties to set
     */
    function CMsgNotificationOfSuspiciousActivity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgNotificationOfSuspiciousActivity steamid.
     * @member {number|Long} steamid
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @instance
     */
    CMsgNotificationOfSuspiciousActivity.prototype.steamid = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;
    /**
     * CMsgNotificationOfSuspiciousActivity appid.
     * @member {number} appid
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @instance
     */
    CMsgNotificationOfSuspiciousActivity.prototype.appid = 0;
    /**
     * CMsgNotificationOfSuspiciousActivity multipleInstances.
     * @member {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null|undefined} multipleInstances
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @instance
     */
    CMsgNotificationOfSuspiciousActivity.prototype.multipleInstances = null;
    /**
     * Decodes a CMsgNotificationOfSuspiciousActivity message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgNotificationOfSuspiciousActivity} CMsgNotificationOfSuspiciousActivity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgNotificationOfSuspiciousActivity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotificationOfSuspiciousActivity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.multipleInstances = $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgNotificationOfSuspiciousActivity.MultipleGameInstances = (function () {
        /**
         * Properties of a MultipleGameInstances.
         * @memberof CMsgNotificationOfSuspiciousActivity
         * @interface IMultipleGameInstances
         * @property {number|null} [appInstanceCount] MultipleGameInstances appInstanceCount
         * @property {Array.<number|Long>|null} [otherSteamids] MultipleGameInstances otherSteamids
         */
        /**
         * Constructs a new MultipleGameInstances.
         * @memberof CMsgNotificationOfSuspiciousActivity
         * @classdesc Represents a MultipleGameInstances.
         * @implements IMultipleGameInstances
         * @constructor
         * @param {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances=} [properties] Properties to set
         */
        function MultipleGameInstances(properties) {
            this.otherSteamids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MultipleGameInstances appInstanceCount.
         * @member {number} appInstanceCount
         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
         * @instance
         */
        MultipleGameInstances.prototype.appInstanceCount = 0;
        /**
         * MultipleGameInstances otherSteamids.
         * @member {Array.<number|Long>} otherSteamids
         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
         * @instance
         */
        MultipleGameInstances.prototype.otherSteamids = $util.emptyArray;
        /**
         * Decodes a MultipleGameInstances message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgNotificationOfSuspiciousActivity.MultipleGameInstances} MultipleGameInstances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultipleGameInstances.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.appInstanceCount = reader.uint32();
                        break;
                    case 2:
                        if (!(message.otherSteamids && message.otherSteamids.length))
                            message.otherSteamids = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.otherSteamids.push(reader.fixed64());
                        }
                        else
                            message.otherSteamids.push(reader.fixed64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return MultipleGameInstances;
    })();
    return CMsgNotificationOfSuspiciousActivity;
})());
//# sourceMappingURL=cstrike15_usermessages.js.map