"use strict";
// tslint:disable:no-console
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const fs = require("fs");
const demo_1 = require("../demo");
function parseDemoFile(path) {
  fs.readFile(path, (err, buffer) => {
    assert.ifError(err);
    const demoFile = new demo_1.DemoFile();
    function eventNameToInterfaceName(name) {
      const camelCased = name.replace(/(^\w|_\w)/g, g =>
        g.toUpperCase().replace("_", "")
      );
      return `IEvent${camelCased}`;
    }
    /*
         * Event key types:
         * TYPE_LOCAL = 0,	// not networked
         * TYPE_STRING = 1,	// zero terminated ASCII string
         * TYPE_FLOAT = 2,		// float 32 bit
         * TYPE_LONG = 3,		// signed int 32 bit
         * TYPE_SHORT = 4,		// signed int 16 bit
         * TYPE_BYTE = 5,		// unsigned int 8 bit
         * TYPE_BOOL = 6		// unsigned int 1 bit
         * TYPE_UINT64 = 7		// unsigned int 64 bit
         * TYPE_WSTRING = 8		// wchar_t byte array
         */
    demoFile.on("svc_GameEventList", e => {
      console.log("// DO NOT MODIFY!");
      console.log("// Auto-generated by ./generators/eventtypes.ts");
      console.log("");
      for (const desc of e.descriptors) {
        console.log(
          `export interface ${eventNameToInterfaceName(desc.name)} {`
        );
        for (const key of desc.keys) {
          let typeStr;
          if (key.type === 1) {
            typeStr = "string";
          } else if (key.type <= 5) {
            typeStr = "number";
          } else if (key.type === 6) {
            typeStr = "boolean";
          } else if (key.type === 7) {
            typeStr = "Long";
          } else {
            throw new Error(`Unexpected event type ${key.type}`);
          }
          console.log(`  ${key.name}: ${typeStr};`);
        }
        console.log("}");
        console.log("");
      }
      const nonSpecificNames = [];
      for (const desc of e.descriptors) {
        const interfaceName = `INonSpecificGame${eventNameToInterfaceName(
          desc.name
        ).substring(1)}`;
        nonSpecificNames.push(interfaceName);
        console.log(`export interface ${interfaceName} {`);
        console.log(`  name: '${desc.name}';`);
        console.log(`  event: ${eventNameToInterfaceName(desc.name)};`);
        console.log(`}`);
        console.log();
      }
      console.log("export type INonSpecificGameEvent =");
      for (let i = 0; i < nonSpecificNames.length; ++i) {
        if (i < nonSpecificNames.length - 1) {
          console.log(`  ${nonSpecificNames[i]} |`);
        } else {
          console.log(`  ${nonSpecificNames[i]};`);
        }
      }
      console.log("");
      console.log(`declare module './gameevents' {`);
      console.log("  export interface GameEvents {");
      console.log(
        `    on(event: 'event', listener: (event: INonSpecificGameEvent) => void): this;`
      );
      for (const desc of e.descriptors) {
        console.log(
          `    on(event: '${
            desc.name
          }', listener: (event: ${eventNameToInterfaceName(
            desc.name
          )}) => void): this;`
        );
      }
      console.log("  }");
      console.log("}");
      // We're finished parsing now
      demoFile.cancel();
    });
    demoFile.parse(buffer);
  });
}
parseDemoFile(process.argv[2]);
//# sourceMappingURL=eventtypes.js.map
