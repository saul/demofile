"use strict";
// tslint:disable:no-console
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const fs = require("fs");
const demo_1 = require("../demo");
function parseDemoFile(path) {
    fs.readFile(path, (err, buffer) => {
        assert.ifError(err);
        const demoFile = new demo_1.DemoFile();
        function eventNameToInterfaceName(name) {
            const camelCased = name.replace(/(^\w|_\w)/g, g => g.toUpperCase().replace("_", ""));
            return `IEvent${camelCased}`;
        }
        /*
         * Event key types:
         * TYPE_LOCAL = 0,	// not networked
         * TYPE_STRING = 1,	// zero terminated ASCII string
         * TYPE_FLOAT = 2,		// float 32 bit
         * TYPE_LONG = 3,		// signed int 32 bit
         * TYPE_SHORT = 4,		// signed int 16 bit
         * TYPE_BYTE = 5,		// unsigned int 8 bit
         * TYPE_BOOL = 6		// unsigned int 1 bit
         * TYPE_UINT64 = 7		// unsigned int 64 bit
         * TYPE_WSTRING = 8		// wchar_t byte array
         */
        demoFile.on("svc_GameEventList", e => {
            console.log("// DO NOT MODIFY!");
            console.log("// Auto-generated by ./generators/eventtypes.ts");
            console.log("");
            for (const desc of e.descriptors) {
                console.log(`export interface ${eventNameToInterfaceName(desc.name)} {`);
                for (const key of desc.keys) {
                    let typeStr;
                    if (key.type === 1) {
                        typeStr = "string";
                    }
                    else if (key.type <= 5) {
                        typeStr = "number";
                    }
                    else if (key.type === 6) {
                        typeStr = "boolean";
                    }
                    else if (key.type === 7) {
                        typeStr = "Long";
                    }
                    else {
                        throw new Error(`Unexpected event type ${key.type}`);
                    }
                    console.log(`  ${key.name}: ${typeStr};`);
                }
                console.log("}");
                console.log("");
            }
            const nonSpecificNames = [];
            for (const desc of e.descriptors) {
                const interfaceName = `INonSpecificGame${eventNameToInterfaceName(desc.name).substring(1)}`;
                nonSpecificNames.push(interfaceName);
                console.log(`export interface ${interfaceName} {`);
                console.log(`  name: '${desc.name}';`);
                console.log(`  event: ${eventNameToInterfaceName(desc.name)};`);
                console.log(`}`);
                console.log();
            }
            console.log("export type INonSpecificGameEvent =");
            for (let i = 0; i < nonSpecificNames.length; ++i) {
                if (i < nonSpecificNames.length - 1) {
                    console.log(`  ${nonSpecificNames[i]} |`);
                }
                else {
                    console.log(`  ${nonSpecificNames[i]};`);
                }
            }
            console.log("");
            console.log(`declare module './gameevents' {`);
            console.log("  export interface GameEvents {");
            console.log(`    on(event: 'event', listener: (event: INonSpecificGameEvent) => void): this;`);
            for (const desc of e.descriptors) {
                console.log(`    on(event: '${desc.name}', listener: (event: ${eventNameToInterfaceName(desc.name)}) => void): this;`);
            }
            console.log("  }");
            console.log("}");
            // We're finished parsing now
            demoFile.cancel();
        });
        demoFile.parse(buffer);
    });
}
parseDemoFile(process.argv[2]);
//# sourceMappingURL=eventtypes.js.map