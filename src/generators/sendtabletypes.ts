/* eslint-disable no-console */

import * as assert from "assert";
import * as fs from "fs";
import { NUM_NETWORKED_EHANDLE_BITS } from "../consts";
import { DemoFile } from "../demo";
import {
  PropType,
  SPROP_EXCLUDE,
  SPROP_INSIDEARRAY,
  SPROP_NOSCALE,
  SPROP_UNSIGNED
} from "../props";

function parseDemoFile(path: string) {
  fs.readFile(path, (err, buffer) => {
    assert.ifError(err);

    const demoFile = new DemoFile();

    demoFile.entities.on("datatablesready", () => {
      console.log("// DO NOT MODIFY!");
      console.log("// Auto-generated by ./generators/sendtabletypes.ts");
      console.log("");
      console.log('import { EntityHandle } from "./entityhandle";');
      console.log();
      console.log(
        "export interface Vector {\n  readonly x: number;\n  readonly y: number;\n  readonly z: number;\n}"
      );
      console.log();

      const excludes: Record<string, Record<string, string[]>> = {};

      for (const dt of demoFile.entities.dataTables) {
        excludes[dt.netTableName] = {};
        console.log(`export interface ${dt.netTableName} {`);

        let lastElemType: string | undefined;
        for (const prop of dt.props) {
          let typeStr;

          if ((prop.flags & SPROP_EXCLUDE) !== 0) {
            if (!excludes[dt.netTableName]![prop.dtName]) {
              excludes[dt.netTableName]![prop.dtName] = [];
            }
            excludes[dt.netTableName]![prop.dtName]!.push(prop.varName);

            console.log(`  // ${prop.dtName}.${prop.varName} - excluded`);
            continue;
          }

          if (prop.type === PropType.Int) {
            if (prop.numBits === 1) {
              typeStr = "boolean";
            } else if (
              prop.numBits === NUM_NETWORKED_EHANDLE_BITS &&
              (prop.flags & SPROP_UNSIGNED) !== 0 &&
              (prop.flags & SPROP_NOSCALE) !== 0
            ) {
              typeStr = "EntityHandle";
            } else {
              typeStr = "number";
            }
          } else if (prop.type === PropType.Float) {
            typeStr = "number";
          } else if (prop.type === PropType.Vector) {
            typeStr = "Vector";
          } else if (prop.type === PropType.VectorXY) {
            typeStr = "Vector";
          } else if (prop.type === PropType.String) {
            typeStr = "string";
          } else if (prop.type === PropType.Array) {
            if (typeof lastElemType === "undefined")
              throw new Error(
                "Array prop type was not preceded by SPROP_INSIDEARRAY"
              );

            typeStr = `ReadonlyArray<${lastElemType}>`;
          } else if (prop.type === PropType.DataTable) {
            console.log(`  // ${prop.varName}: DataTable;`);
            continue;
          } else if (prop.type === PropType.Int64) {
            typeStr = "Long";
          } else {
            throw new Error(`Unexpected prop type ${prop.type}`);
          }

          // Skip inside array - we'll print the PropType.Array
          // which will follow immediately after this prop
          if ((prop.flags & SPROP_INSIDEARRAY) !== 0) {
            console.log(`  // ${prop.varName}: ${typeStr} - InsideArray;`);
            lastElemType = typeStr;
            continue;
          }

          let name = prop.varName;
          if (name.indexOf(`"`) !== -1) {
            // Wrap in [`foo`]
            name = "[`" + name + "`]";
          } else if (
            name.charCodeAt(0) < 65 ||
            name.indexOf(".") !== -1 ||
            name.indexOf("[") !== -1
          ) {
            // Wrap in ["foo"]
            name = `["${name}"]`;
          }

          console.log(`  ${name}: ${typeStr};`);
        }

        console.log("}");
        console.log();
      }

      for (const serverClass of demoFile.entities.serverClasses) {
        const dataTableNames = serverClass.flattenedProps.reduce(
          (names: string[], fp) => {
            if (names.indexOf(fp.table.netTableName) === -1) {
              names.push(fp.table.netTableName);
            }
            return names;
          },
          []
        );

        console.log(`export interface ${serverClass.name} {`);

        const excludedInClass = dataTableNames.reduce(
          (acc: Record<string, string[]>, dataTable) => {
            for (const [excludedTable, excludedProps] of Object.entries(
              excludes[dataTable]!
            )) {
              if (!acc[excludedTable]) {
                acc[excludedTable] = excludedProps;
              } else {
                acc[excludedTable]!.push(...excludedProps);
              }
            }
            return acc;
          },
          {}
        );

        for (const dataTable of dataTableNames) {
          if (dataTable === "DT_AnimTimeMustBeFirst") {
            continue;
          }

          const excludedProps = excludedInClass[dataTable] || [];
          const dataTableType =
            excludedProps.length > 0
              ? `Omit<${dataTable}, "${excludedProps.join('" | "')}">`
              : dataTable;

          console.log(`  ${dataTable}: ${dataTableType};`);
        }

        console.log(`}`);
        console.log("");
      }

      demoFile.cancel();
    });

    demoFile.parse(buffer);
  });
}

if (process.argv.length == 3) {
  parseDemoFile(process.argv[2]!);
} else {
  console.error("expected args: <path to .dem>");
  process.exitCode = 1;
}
